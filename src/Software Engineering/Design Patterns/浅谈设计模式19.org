#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: 浅谈设计模式十九: 责任链模式(Chain of Responsibility)
#+OPTIONS: num:nil H:3

* 实例

* 责任链模式(Chain of Responsibility)
** 目的
避免请求的发送者通过给予多个对象机会去处理这个请求的方式到它的接收者的
耦合。把接收对象组成一条链路，并把这个请求沿着这条链路传送直到一个对象
处理它。
** 实现

#+begin_src c++

#+end_src


[[https://github.com/shishougang/DesignPattern-CPP/tree/master/src/chain_of_responsibility][代码实例在这里]]。
* 总结
** 责任链模式(Chain of Responsibility)结构
[[./images/chainofresponsibility/chain_of_responsibility_structure.jpeg]]
** 组成
+ 处理者（Handler）
  1. 为处理请求定义一个接口。
  2. （可选）实现后继链接。
+ 具体处理者（ConcreteHandler）
  1. 处理它负责的请求。
  2. 能访问它的后继对象。
  3. 如果这个具体处理者能处理这个请求，它就处理它，否则它传递这个请求
     给它的后继对象。
+ 对象（Client）
  初始给链路中的具体处理者一个请求。

** 应用场景
+ 多余一个对象要处理一个请求，并且处理者不是先验的。处理者需要自动被弹
  探知。
+ 你想促发促一个请求给许多个对象之一并且不想明确指定哪个接收者时。
+ 处理请求的一组对象需要被动态指定。

** 缺点
收到不能被保证。因为一个请求没有明确的接收者，所以不能保证它将被处理——
请求也能落到链路的末端而未曾被处理。一个请求也能不被处理当链路没有被合
理的配置。
