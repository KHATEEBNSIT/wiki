#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: 浅谈设计模式十八: 享元模式(Flyweight)
#+OPTIONS: num:nil H:3

* 实例

* 享元模式(Flyweight)
** 目的
使用共享机制来有效支持大量细粒度的对象。
** 实现
#+begin_src c++

#+end_src

[[https://github.com/shishougang/DesignPattern-CPP/tree/master/src/flyweight][代码实例在这里]]。
* 总结
** 享元模式(Flyweight)结构
[[./images/flyweight/flyweight_structure.jpeg]]
** 组成
+ 抽象享元类（Flyweight）
  声明一个接口，通过这个接口享元类（Flyweight）可以接收和作用于外部状
  态。
+ 具体享元类（ConcreteFlyweight）
  实现抽象享元类的接口并为内部状态增加存储空间。具体享元类
  （ConcreteFlyweight）必须是可共享的。它存储的任何状态必须是内部的，
  也就是说它必须独立于具体享元类（ConcreteFlyweight）所处的场景。
+ 非共享的具体享元类（UnsharedConcreteFlyweight）
  不是所有的享元子类必须可共享的。享元类接口使得共享成为可能，但并不强
  制要求它。通常在享元对象结构的某些层次上，非共享的具体享元素
  （UnsharedConcreteFlyweight）对象把具体享元素（ConcreteFlyweight）对
  象作为子节点。
+ 享元工厂类（FlyweightFactory）
  1. 创建和管理享元对象。
  2. 确保合理的共享享元类。当一个客户请求一个享元类时，享元工厂对象提
     供一个已存在的实例或如果不存在就创建一个。
+ 客户
  1. 维护享元类的引用。
  2. 计算或存储享元类的外部状态。

** 应用场景
享元模式的有效性严重依赖于如何和在哪被使用。应用享元模式当 *以下条件都
相符* 时：
+ 一个应用使用大量的对象。
+ 因为大量的对象，从而造成很大的存储开销。
+ 大多数对象状态可以外部化。
+ 一旦消除外部状态后，许多组的对象能被相对较少的共享对象所替换。
+ 应用不依赖于对象的标识。因为享元对象可以被共享，那么对于概念上有别的
  对象，标识测试也会返回真值。

** 缺点
共享模式会引入运行时间开销伴随着传送，找寻，或计算外部状态，特别是如果
它之前内部存储。但是如此的开销被空间节省抵消，越是更多的享元类被共享越
是增加节省的空间。
