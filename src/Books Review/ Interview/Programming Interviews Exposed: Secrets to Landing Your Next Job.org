#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: Programming Interviews Exposed: Secrets to Landing Your Next Job Notes
#+OPTIONS: num:nil H:2


* Chapter 1: Before the Search
** Develop Marketable Skills
The appendix covers how your résumé is primarily a marketing tool to
get you job interviews. This assumes, of course, that you have
marketable skills to offer a prospective employer. You can only
stretch the truth so far, and if even you exaggerate or outright lie
about your skills and what you’ve accomplished in the past, you
probably won’t make it through technical interviews designed
specifically to weed out the liars and exaggerators of this world.
What you need to do, then, is develop skills and accomplishments that
will make you stand out from the crowd both on paper and in the
interviews, especially if you’re entering the job market for the first
time. Here are some approaches you can take:

+ Upgrade your credentials - Companies such as Google are well known
  for favoring job applicants with graduate degrees. Getting a
  master’s or doctorate degree is one way to upgrade your credentials.
  Although pursuing a graduate degree is a large commitment on your
  part, you can upgrade your credentials in other ways, such as taking
  university or professional development courses or participating in
  programming contests. 
+ Get certified - Certification is a touchy
  issue in the software development profession, but there’s no doubt
  that some jobs either prefer or require candidates to be certified
  in specific technologies, especially IT jobs. 
+ Work on a side project - A great way to expand your skill set is to
  work on a project that is not directly related to your primary work
  or study focus. Starting or joining an open-source development
  project is one way to go. Or if you’re working at a company, see if
  they’ll let you spend time on an ancillary project.

+ Do well in school - Although grades aren’t everything, they are one
  measure that companies use in order to rank new graduates with
  little job experience. The better your grades, especially in
  computer science and mathematics courses, the more you’ll impress a
  potential employer.

+ Keep learning - The end of formal education doesn’t mean you should
  stop learning, especially when there’s so much information about
  programming available from a wide variety of sources. Whether it’s
  books or blogs, there’s always a way to keep yourself current, no
  matter what type of programming you do. It’s also a great way to
  expand your horizons and discover other areas of interest.

+ Be an intern - New graduates who’ve managed to secure employment
  during their nonschool terms - especially those that participate in
  cooperative education programs - have a huge leg up over their peers
  who haven’t yet ventured into the real world. Software development
  in the field is often very different from software development in an
  academic setting, and potential employers are very cognizant of
  this.


The key is to keep learning, no matter what stage of your career
you’re at. Marketable skills don’t develop overnight; they take some
effort and initiative on your part, but they’ll have long-lasting
effects on your career.

Note that one of the best ways to develop marketable skills is to
accomplish something, whether it’s in your current job, something you
did as a side project, or something you worked on as an intern or for
a class project. Being able to talk intelligently and confidently
about a project for which you played a primary role in its success is
incredibly important. Make sure you can describe the problem clearly
and succinctly and how your project solved the problem, even to a
nontechnical person. Displaying a passion for programming is always
positive and one way to make yourself stand out from the other
candidates.

* Chapter 2: The Job Application Process
* Chapter 3: Approaches to Programming Problems
** Interactivity Is Key
The code you write in the interview is probably the only example of
your code that your interviewer will see. If you write ugly code, your
interviewer will assume you always write ugly code. This is your
chance to shine and show your best code. Take the time to make your
code solid and pretty.

 *Tip Brush up on the languages you expect to use, and write your best code.*
Programming questions are designed to see both how well you can code
and how you solve problems. If all the interviewer wanted to do were
measure your coding ability, he could give you a piece of paper with
problems and come back an hour later to evaluate how you did, just as
they do in programming contests. What the interviewer wants is to see
your thought processes as you work through each stage of the
programming problem.

The problem-solving process in these interviews is very interactive,
and if you’re having difficulty, the interviewer will generally guide
you to the correct answer via a series of hints. Of course, the less
help you need to solve the problem, the better you look, but showing
an intelligent thought process and responding well to the hints you
are given is also very important.

Even when you immediately know the answer to a problem, because it’s
something you’ve already done before, don’t just blurt it out. Break
the answer down into discrete steps and explain the thought processes
behind each step. The point is to show the interviewer that you
understand the underlying concepts, not that you’ve managed to
memorize the answer to a programming puzzle.

If you know any additional information pertaining to the problem, you
may want to mention it during the process to show your general
knowledge of programming, even if it’s not directly applicable to the
problem at hand. In answering these problems, show that you’re not
just a propeller-head coder. Demonstrate that you have logical thought
processes, are generally knowledgeable about computers, and can
communicate well.

 *Tip Keep talking! Always explain what you are doing! Otherwise, the interviewer has no way of knowing how you tackle complex programming problems.*


** Solving the Questions
Now it’s time to solve the questions, but don’t just jump in. Instead,
remember you want to fully understand the problem. You should try an
example, and then focus on the algorithm that will solve the problem.
You then want to explain your solution and code for the solution. The
following steps walk you through the process:

*** The Basic Steps

The best way to solve an interview problem is to approach it
methodically. Here are the suggested steps:

1. Make sure you understand the problem. Your initial assumptions
   about the problem may be wrong, or the interviewer’s explanation
   may be very brief or difficult to follow. You can’t demonstrate
   your skills if you don’t understand the problem. Don’t hesitate to
   ask your interviewer questions about the problem, and don’t start
   solving it until you understand it. The interviewer may be
   deliberately obscuring things in order to determine whether you can
   find and understand the real problem.

2. Once you understand the question, try an example. This example may
   lead to insights about how to solve the problem or bring to light
   any remaining misunderstandings that you have. Starting with an
   example also demonstrates a methodical, logical thought process.
   Examples are especially useful if you don’t see the solution right
   away.

Tip 	Make sure you understand the problem before you start solving it, and then start with an example to solidify your understanding.
3. Focus on the algorithm you will use to solve the problem. Often,
   this will take a long time and require additional examples. This is
   to be expected. Interactivity is important during this process. If
   you stand quietly staring at the whiteboard, the interviewer has no
   way of knowing whether you’re making productive headway or are
   simply clueless. Talk to your interviewer and tell him or her what
   you are doing. For example, you might say something like, “I’m
   wondering whether I can store the values in an array and then sort
   them, but I don’t think that will work because I can’t quickly look
   up elements in an array by value.” This demonstrates your skill,
   which is the point of the interview, and may also lead to hints
   from the interviewer, who might respond, “You’re very close to the
   solution. Do you really need to look up elements by value, or could
   you …”

    It may take a long time to solve the problem, and you may be
   tempted to begin coding before you figure out an exact solution.
   Resist this temptation. Consider who you would rather work with:
   someone who thinks about a problem for a long time and then codes
   it correctly the first time or someone who hastily jumps into a
   problem, makes several errors while coding, and doesn’t have any
   idea where he or she is going. Not a difficult decision, is it?

4. After you’ve figured out your algorithm and how you will implement
   it, explain your solution to the interviewer. This gives him or her
   an opportunity to evaluate your solution before you begin coding.
   Your interviewer may say, “Sounds great, go ahead and code it,” or
   something like, “That’s not quite right because you can’t look up
   elements in a hash table that way.” In either case, you gain
   valuable information.

5. While you code, it’s important to explain what you’re doing. For
   example, you might say, “Here, I’m initializing the array to all
   zeroes.” This narrative enables the interviewer to follow your code
   more easily.

Tip 	Explain what you are doing to your interviewer before and
while coding the solution. Keep talking!

6. Ask questions when necessary. You generally won’t be penalized for
   asking factual questions that you might otherwise look up in a
   reference. You obviously can’t ask a question like, “How do I solve
   this problem?” but it is acceptable to ask a question like, “I
   can’t remember - what format string do I use to print out a
   localized date?” While it’s better to know these things, it’s okay
   to ask this sort of question.

7. After you’ve written the code for a problem, immediately verify
   that the code is correct by tracing through it with an example.
   This step demonstrates very clearly that your code works in at
   least one case. It also illustrates a logical thought process and
   your desire to check your work and search for bugs. The example may
   also help you flush out minor bugs in your solution.

8. Make sure you check your code for all error and special cases,
   especially boundary conditions. Many error and special cases are
   overlooked by programmers; forgetting these cases in an interview
   indicates you may forget them on the job. For example, if you
   allocate memory dynamically, make sure you check that the
   allocation did not fail. (If time does not allow for extensive
   checking, at the very least explain that you should check for such
   failures.) Covering error and special cases will impress your
   interviewer and help you correctly solve the problem.

Tip Try an example, and check all error and special cases.

Once you try an example and feel comfortable that your code is
correct, the interviewer may ask you questions about what you wrote.
Commonly, these questions focus on running time, alternative
implementations, and complexity. If your interviewer does not ask you
these questions, you should volunteer the information to show that you
are cognizant of these issues. For example, you could say, “This
implementation has linear running time, which is the best possible
because I have to check all the input values. The dynamic memory
allocation will slow it down a little, as will the overhead of using
recursion.”

*** When You Get Stuck

Getting stuck on a problem is expected and an important part of the
interviewing process. Interviewers want to see how you respond when
you don’t recognize the answer to a question immediately. Giving up or
getting frustrated is the worst thing to do if this happens to you.
Instead, show interest in the problem and keep trying to solve it:

+ Go back to an example. Try performing the task and analyzing what
  you are doing. Try extending from your specific example to the
  general case. You may have to use very detailed examples. This is
  okay, because it shows the interviewer your persistence in finding
  the correct solution.

Tip 	 When all else fails, return to a specific example. Try to move from the specific example to the general case and from there to the solution.
+ Try a different data structure. Perhaps a linked list, an array, a
  hash table, or a binary search tree will help. If you’re given an
  unusual data structure, look for similarities between it and
  more-familiar data structures. Using the right data structure often
  makes a problem much easier.

+ Consider the less-commonly used or more-advanced aspects of a
  language. Sometimes the key to a problem involves one of these
  features.

Tip 	Sometimes a different data structure or advanced language feature is key to the solution.

Even when you don’t feel stuck, you may be having problems. You may be
missing an elegant or obvious way to implement something and writing
too much code. Almost all interview coding questions have short
answers. You rarely need to write more than 15 lines of code and
almost never more than 30. If you start writing a lot of code, you may
be heading in the wrong direction.

* Chapter 4: Linked Lists
** Linked List Problems
A C++ version looks like the following:
#+begin_src c++
class Stack
{
public:
    Stack();
    ~Stack();
    void push( void *data );
    void *pop();
protected:
    // Element struct needed only internally
    typedef struct Element {
        struct Element *next;
        void *data;
    } Element;

    Element *head;
};

Stack::Stack() {
    head = NULL;
    return;
}

Stack::~Stack() {
    while( head ){
        Element *next = head->next;
        delete head;
        head = next;
    }
    return;
}

void Stack::push( void *data ){
    //Allocation error will throw exception
    Element *element = new Element;
    element->data = data;
    element->next = head;
    head = element;
    return;
}

void *Stack::pop() {
    Element *popElement = head;
    void *data;

    /* Assume StackError exception class is defined elsewhere */
    if( head == NULL )
        throw StackError( E_EMPTY );

    data = head->data;
    head = head->next;
    delete popElement;
    return data;
}
#+end_src

** Null or Cycle

Important 	
You are given a linked list that is either NULL-terminated (acyclic),
as shown in Figure 4-5, or ends in a cycle (cyclic), as shown in
Figure 4-6.

Write a function that takes a pointer to the head of a list and
determines whether the list is cyclic or acyclic. Your function should
return false if the list is acyclic and true if it is cyclic. You may
not modify the list in any way.Null or Cycle

Write a function that takes a pointer to the head of a list and
determines whether the list is cyclic or acyclic. Your function should
return false if the list is acyclic and true if it is cyclic. You may
not modify the list in any way.

In outline form, this algorithm looks like this:
#+begin_src sh
Start two pointers at the head of the list
Loop infinitely
    If the fast pointer reaches a NULL pointer
        Return that the list is NULL terminated
    If the fast pointer moves onto or over the slow pointer
        Return that there is a cycle
    Advance the slow pointer one node
    Advance the fast pointer two nodes
#+end_src
You can now implement this solution:
#+begin_src c
/* Takes a pointer to the head of a linked list and determines if
 * the list ends in a cycle or is NULL terminated
 */
bool determineTermination( Node *head ){
    Node *fast, *slow;
    fast = slow = head;
    while( true ){
        if( !fast || !fast->next )
            return false;
        else if( fast == slow || fast->next == slow )
            return true;
     else {
         slow = slow->next;
         fast = fast->next->next;
     }
  }
}
#+end_src

* Chapter 5: Trees and Graphs
** Following is some additional tree-related vocabulary:
+ Parent - A node that points to other nodes is the parent of those
  nodes. Every node except the root has one parent. In Figure 5-1, B
  is the parent of D, E, and F.

+ Child - A node is the child of any node that points to it. In Figure
  5-1, each of the nodes D, E, and F is a child of B.

+ Descendant - All the nodes that can be reached by following a path
  of child nodes from a particular node are the descendants of that
  node. In Figure 5-1, D, E, F, H, I, J, and K are the descendants of
  B.

+ Ancestor - An ancestor of a node is any other node for which the
  node is a descendant. For example, A, B, and D are the ancestors of
  I.

+ Leaves - The leaves are nodes that do not have any children. G, H,
  I, and K are leaves.

** Common Searches
*** Breadth-First Search
One way to search a tree is to do a breadth-first search (BFS). In a
BFS you start with the root, move left to right across the second
level, then move left to right across the third level, and so forth.
You continue the search until either you have examined all of the
nodes or you find the node you are searching for. The time to find a
node is O(n), so this type of search is best avoided for large trees.
A BFS also uses a large amount of memory because it is necessary to
track the child nodes for all nodes on a given level while searching
that level.

*** Depth-First Search
Another common way to search for a node is by using a depth-first
search (DFS). A depth-first search follows one branch of the tree down
as many levels as possible until the target node is found or the end
is reached. When the search can’t go down any farther, it is continued
at the nearest ancestor with unexplored children. DFS has much lower
memory requirements than BFS because it is not necessary to store all
of the child pointers at each level. In addition, DFS has the
advantage that it doesn’t examine any single level last (BFS examines
the lowest level last). This is useful if you suspect that the node
you are searching for will be in the lower levels. For example, if you
were searching a job hierarchy tree looking for an employee who
started less than three months ago, you would suspect that lower-level
employees are more likely to have started recently. In this case, if
the assumption were true, a DFS would usually find the target node
more quickly than a BFS.




** Traversals
+ Preorder traversal of a node performs the operation first on the
  node itself, then on its left descendants, and finally on its right
  descendants. In other words, a node is always visited before any of
  its children.

+ Inorder traversal performs the operation first on the node’s left
  descendants, then on the node itself, and finally on its right
  descendants. In other words, the left subtree is visited first, then
  the node itself, and then the node’s right subtree.

+ Postorder traversal performs the operation first on the node’s left
  descendants, then on the node’s right descendants, and finally on
  the node itself. In other words, all of a node’s children are
  visited before the node itself.


** Binary Tree Problems
*** Preorder Traversal, No Recursion
#+begin_src sh
Create the stack
Push the root node on the stack
While the stack is not empty
    Pop a node
    If the node is not null
        Print its value
        Push the node's right child on the stack
        Push the node's left child on the stack
#+end_src

#+begin_src java
void preorderTraversal( Node root ){
    NodeStack stack = new NodeStack();
    stack.push( root );
    while( true ){
        Node curr = stack.pop();
        if( curr == null ) break;
        curr.printValue();
        Node n = curr.getRight();
        if( n != null ) stack.push( n );
        n = curr.getLeft();
        if( n != null ) stack.push( n );
    }
}
#+end_src

*** Lowest Common Ancestor
* Chapter 6: Arrays and Strings
** Arrays
An array is a sequence of variables of the same type arranged
contiguously in a block of memory. 

** Strings
Strings are sequences of characters. However, what constitutes a
character depends greatly on the language being used and the settings
of the operating system on which the application runs.

** Array and String Problems
Both hash tables and arrays provide constant-time lookup; you need to
decide which one you will use. On the one hand, hash tables have a
higher lookup overhead than arrays. On the other hand, an array would
initially contain random values that you would have to take time to
set to zero, whereas a hash table initially has no values. Perhaps the
greatest difference is in memory requirements. An array would need an
element for every possible value of a character. This would amount to
a relatively reasonable 128 elements if you were processing ASCII
strings, but if you had to process Unicode strings you would need more
than 65,000 elements, assuming a 16-bit Unicode encoding. In contrast,
a hash table would require storage for only the characters that
actually exist in the input string. Therefore, arrays are a better
choice for long strings with a limited set of possible character
values; hash tables are more efficient for shorter strings or when
there are many possible character values.
* Chapter 7: Recursion
Although recursion is a very powerful technique, it is not always the
best approach, and rarely is it the most efficient approach. This is
due to the relatively large overhead for routine calls on most
platforms. For a simple recursive routine like factorial, many
computer architectures spend more time on call overhead than the
actual calculation. Iterative routines, which use looping constructs
instead of recursive routine calls, do not suffer from this overhead
and are frequently more efficient.

Tip Iterative solutions are usually more efficient than recursive solutions.

This implementation is significantly more efficient than our previous
recursive implementation because no routine calls are involved.
Although it represents a different way of thinking about the problem,
it’s not really any more difficult to write than the recursive
implementation


Tip 	
A recursive algorithm can be implemented without recursive calls by
using a stack, but it’s usually more trouble than it’s worth.

In an interview, a working solution is of primary importance; an
efficient solution is secondary. Unless you’ve been told otherwise, go
with whatever type of working solution comes to you first. If it’s a
recursive solution, you might want to mention the inefficiencies
inherent in recursive solutions to your interviewer, so it’s clear
that you know about them. In the rare instance that you see a
recursive solution and an iterative solution of roughly equal
complexity, you should probably mention them both to the interviewer,
indicating that you’re going to work out the iterative solution
because it’s likely to be more efficient.

** Recursion Problems

* Chapter 8: Concurrency
** Basic Thread Concepts
*** Threads

A thread is the fundamental unit of execution within an application: A
running application consists of at least one thread. Each thread has
its own stack and runs independently from the application’s other
threads. Threads share the resources used by the application as it
runs, such as file handles or memory, which is why problems can occur.
Data corruption is a common side effect of having two threads
simultaneously write data to the same block of memory, for example.

*** Monitors and Semaphores

In order to avoid data corruption and other problems, applications
must control how threads interact with shared resources, referred to
as thread synchronization. The two fundamental thread synchronization
constructs are monitors and semaphores. Which you use depends on what
your system or language supports.

** Concurrency Problems
*** Busy Waiting
*** Producer/Consumer
#+begin_src java
public class IntBuffer {
    private int   index;
    private int[] buffer = new int[8];

    public synchronized void add( int num ){
        while( index == buffer.length - 1 ){
            try {
                wait();
            }
            catch( InterruptedException e ){
            }
        }

        buffer[index++] = num;
        notifyAll();
    }

    public synchronized int remove(){
        while( index == 0 ){
            try {
                wait();
            }
            catch( InterruptedException e ){
            }
        }

        int ret = buffer[--index];
        notifyAll();
        return ret;
    }
}

public class Producer extends Thread {
    private IntBuffer buffer;

    public Producer( IntBuffer buffer ){
        this.buffer = buffer;
    }

    public void run(){
        Random r = new Random();
        while( true ){
            int num = r.nextInt();
            buffer.add( num );
            System.out.println( "Produced " + num );
        }
    }
}

public class Consumer extends Thread {
    private IntBuffer buffer;

    public Consumer( IntBuffer buffer ){
        this.buffer = buffer;
    }

    public void run(){
        while( true ){
            int num = buffer.remove();
            System.out.println( "Consumed " + num );
        }
    }
}


IntBuffer b = new IntBuffer();
Producer p = new Producer( b );
Consumer c = new Consumer( b );
p.start();
c.start();
#+end_src

*** The Dining Philosophers
This application deadlocks when all philosophers have simultaneously
picked up their left fork: Because no right fork is available to any
philosopher, no philosopher can eat.

One solution is to add a timeout to the waiting: If a philosopher is
not able to eat within a predetermined amount of time after acquiring
the first fork, then the philosopher drops the fork and tries again.
The flaw with this solution is that it’s possible for one or more
philosophers to starve because they never acquire both forks. This is
referred to as livelock.

The best solution requires a very simple change to the application.
Instead of having all the philosophers pick up the left fork first,
have one of the philosophers pick up the right fork first:

* Chapter 9: Object-Oriented Programming
** Interfaces and Abstract Classes	
Explain the difference between an interface and an abstract class in
object-oriented programming.


+ An interface declares a set of related methods, outside of any
  class.

+ An abstract class is an incomplete class definition that declares
  but does not define all of its methods.

Conceptually, then, an interface defines an application programming
interface (API) that is independent of any class hierarchy. In fact,
interfaces can be used in non-OO programming models, such as
componentbased models like COM and CORBA. However, you’re focusing on
the use of interfaces in an object-oriented context, where they are
useful in their own right. Interfaces are the ultimate encapsulators,
because they hide all the details of the classes that implement their
methods from the user of the interface. They’re particularly
important - almost necessary, in fact - in languages that only support
single inheritance (classes can only inherit from one base class). A
class that exposes its members via an interface is said to implement
the interface.

Unlike an interface, an abstract class is a proper class: It can have
data members and can be a subclass of other classes. Unlike a concrete
(nonabstract) class, however, some of its behaviors are deliberately
left to be defined by its own subclasses. Abstract classes cannot be
instantiated because of this - only instances of concrete subclasses
can be created.

** Virtual Methods
Describe what virtual methods are and why they are useful.

A virtual method is a method whose implementation is determined at run
time based on the actual type (class) of the invoking object.
Nonstatic Java methods are always virtual, so Java programmers may
have trouble answering this one; but in C# and C++, methods are only
virtual when declared with the virtual keyword - nonvirtual methods
are the default.

Once you explain what virtual methods are and why they’re useful, talk
about their advantages and disadvantages. The primary advantage was
just described: the run-time method selection. Virtual methods are
also used to declare abstract methods. The disadvantages are that it
takes longer to invoke a virtual method (at a minimum, one lookup
needs to be done in a table to find the right method - you can’t jump
directly to the method as you can with nonvirtuals) and that extra
memory is required to store the information needed for the lookup.



** Multiple Inheritance
Why do C# and Java disallow the multiple inheritance of classes?

In C++ it’s legal for a class to inherit (directly or indirectly) from
more than one class, which is referred to as multiple inheritance. C#
and Java, however, limit classes to single inheritance - each class
inherits from a single parent class.

Multiple inheritance is a useful way to create classes that combine
aspects of two disparate class hierarchies, something that often
happens when using different class frameworks within a single
application. If two frameworks define their own base classes for
exceptions, for example, you can use multiple inheritance to create
exception classes that can be used with either framework.

The problem with multiple inheritance is that it can lead to
ambiguity. The classic example is when a class inherits from two other
classes, each of which inherits from the same class:

#+begin_src c++
 class A {
  protected:
    bool flag;
};

class B : public A {};

class C : public A {};

class D : public B, public C {
  public:
    void setFlag( bool nflag ){
        flag = nflag; // ambiguous
    }
};
#+end_src
In this example, the flag data member is defined by class A. But class
D descends from class B and class C, which both derive from A, so in
essence two copies of flag are available because there are two
instances of A in D’s class hierarchy. Which one do you want to set?
The compiler will complain that the reference to flag in D is
ambiguous. One fix is to explicitly disambiguate the reference:

=B::flag = nflag;=

Another fix is to declare B and C as virtual base classes, which means
that only one copy of A will exist in the hierarchy, eliminating any
ambiguity.


There are other complexities with multiple inheritance, such as the
order in which the base classes are initialized when a derived object
is constructed, or the way members can be inadvertently hidden from
derived classes. Because of these complexities, some languages
restrict themselves to the much simpler single inheritance model. On
the other hand, single inheritance is also very restrictive, because
only classes with a common ancestor can share behaviors. Interfaces
mitigate this restriction somewhat by allowing classes in different
hierarchies to expose common interfaces even if they’re not
implemented by sharing code.

* Chapter 10: Databases
** Database Fundamentals
Data in a relational database is stored in tables, which consist of
rows and columns. (A set of tables is referred to as a schema.) Each
table has at least one column, but there may be no rows. Each column
has a type associated with it, which limits the type of data that can
be stored in the column, as well as additional constraints. Although
the columns are ordered, the rows aren’t. Any ordering that is
required is done when the data is fetched (via a query) from the
database.

Most tables have keys, although it’s not a requirement (but it is good
design). A key is a column or set of columns that uniquely identifies
a particular row in the table. One of the keys is designated to be the
primary key. For example, in a table of employees, you would use the
employee identification number - guaranteed to be unique for each
employee - as the primary key.

A table can be linked to another table using a foreign key. A foreign
key is usually a primary key value taken from the other table. Foreign
keys ensure that data isn’t deleted prematurely: You can’t delete a
row from a table if the foreign key of another table references the
row. This is known as referential integrity, and it ensures that
related tables are always in a consistent state with respect to each
other.
** Structured Query Language (SQL)
** Database Transactions

The integrity of the data stored in a database is paramount: If the
data is ever corrupted, every application that depends on the database
may fail or be in error. While referential integrity helps keep the
data consistent, the best way to ensure data integrity is to use a
database transaction.

A transaction groups a set of related database manipulations together
into a single unit. If any operation within the transaction fails, the
entire transaction fails and any changes made by the transaction are
abandoned (rolled back). Conversely, if all the operations succeed,
then all the changes are committed together as a group.

The four properties of a transaction are as follows:
+ Atomicity - The database system guarantees that either all
  operations with the transaction succeed or else they all fail.

+ Consistency - The transaction must ensure that the database is in a
  correct, consistent state at the start and the end of the
  transaction. No referential integrity constraints can be broken, for
  example.

+ Isolation - All changes to the database within a transaction are
  isolated from all other queries and transactions until the
  transaction is committed.

+ Durability - Once committed, changes made in a transaction are
  permanent. The database system must have some way to recover from
  crashes and other problems so that the current state of the database
  is never lost.

** Database Problems
*** Simple SQL
Given a database with the table
#+begin_src sh
Olympics(
    city CHAR(16),

    year INT(4)
)
#+end_src
write a SQL statement to insert Montreal and 1976 into the database.

#+begin_src sql
INSERT INTO Olympics VALUES( 'Montreal', 1976 )
#+end_src

*** Company and Employee Database

Important 	
You are given a database with the following tables:
#+begin_src sh
Company (
    companyName CHAR(30),
    id          INT(4) PRIMARY KEY
)

EmployeesHired (
    id            INT(4) PRIMARY KEY,
    numHired      INT(4),
    fiscalQuarter INT(4),
    FOREIGN KEY id REFERENCES Company
)
#+end_src

+ Write a SQL statement that returns the names of all the companies
  that hired employees in fiscal quarter 4.
#+begin_src sql
SELECT companyName FROM Company, EmployeesHired
WHERE Company.id = EmpolyeesHired.id AND fiscalQuarter = 4 AND numHired > 0
#+end_src

+ Now, using the same schema, write a SQL statement that returns the
  names of all companies that did not hire anyone in fiscal quarters 1
  through 4.
#+begin_src sql
SELECT companyName FROM Company WHERE id NOT IN
(SELECT id from EmployeesHired WHERE numHired > 0)
#+end_src

+ Finally, return the names of all companies and the total number of
  employees that each company hired during fiscal quarters 1
  through 4.
#+begin_src sql
SELECT companyName, SUM(numHired)
FROM Company, EmployeesHired
WHERE Company.id = EmployeesHired.id
GROUP BY companyName
#+end_src

*** Max, No Aggregates
Important 	
Given the following SQL database schema
#+begin_src sh
Test (
    num INT(4)

)
#+end_src
write a SQL statement that returns the maximum value from num without
using an aggregate (MAX, MIN, etc.).

There is one minor bug in this query. If the maximum value is repeated
in the Test table, it will be returned twice. To prevent this, use the
=DISTINCT= keyword. This changes the query to the following:
#+begin_src sql
SELECT DISTINCT num FROM Test WHERE num NOT IN
(SELECT Lesser.num FROM Test AS Greater, Test AS Lesser
WHERE Lesser.num < Greater.num)
#+end_src


*** Three-Valued Logic

Important 	
Given the following table
#+begin_src sh
Address (
    street CHAR(30) NOT NULL,
    apartment CHAR(10),

    city CHAR(40) NOT NULL,

)
#+end_src
write a SQL statement that returns nonapartment addresses only.

The trick is in the use of the equality operator (‘=’) to test for a
NULL column value. In most databases, a comparison to NULL returns
UNKNOWN - even when comparing NULL to NULL. The proper way to check
for a NULL or non-NULL column is to use the IS NULL or IS NOT NULL
syntax. Thus, the original query should be restated as follows:

=SELECT * FROM Address WHERE apartment IS NULL=

* Chapter 11: Other Programming Topics
** Bit Manipulation
** Graphics and Bit Operations Problems
** Rectangle Overlap
The two rectangles do not overlap when
+ A’s UL’s x value is greater than B’s LR’s x value or
+ A’s UL’s y value is less than B’s LR’s y value or
+ A’s LR’s x value is less than B’s UL’s x value or
+ A’s LR’s y value is greater than B’s UL’s y value.
This solution is much simpler, requiring only four comparisons and one
negation. You can implement the function as follows:
#+begin_src java
boolean overlap( Rect a, Rect b ){
    return !( a.ul.x > b.lr.x ||
              a.ul.y < b.lr.y ||
              a.lr.x < b.ul.x ||
              a.lr.y > b.ul.y );
}
#+end_src
Working through these rules, you’ll get the following function:
#+begin_src java
boolean overlap( Rect a, Rect b){
    return( a.ul.x <= b.lr.x &&
            a.ul.y >= b.lr.y &&
            a.lr.x >= b.ul.x &&
            a.lr.y <= b.ul.y );
}
#+end_src
To ensure that you didn’t make a mistake, it’s a good idea to verify
that these conditions make sense. The preceding function determines
that two rectangles overlap if

+ A’s left edge is to the left of B’s right edge and
+ A’s upper edge is above B’s bottom edge and
+ A’s right edge is to the right of B’s left edge and
+ A’s bottom edge is below B’s upper edge.
** Big-endian or Little-endian
Write a function that determines whether a computer is big-endian or
little-endian.

Endianness is important to know when reading or writing data
structures, especially across networks, so that different applications
can communicate with each other. Sometimes the endianness is hidden
from the developer: Java uses a fixed endianness to store data,
regardless of the underlying platform’s endianness, so data exchanges
between two Java applications won’t normally be affected by
endianness. But other languages, C in particular, don’t specify an
endianness for data storage, leaving the implementation free to choose
the endianness that works best for the platform. C is used to solve
this problem.

If you set the value of the integer to 1, you can distinguish between
the MSB and the LSB because in an integer with the value 1, the LSB
has the value 1 and the MSB has the value 0.

The code for this test is as follows:
#+begin_src c
/* Returns true if the machine is little-endian, false if the
 * machine is big-endian
 */
bool endianness(){
    int   testNum;
    char *ptr;

    testNum = 1;
    ptr = (char *) &testNum;
    return (*ptr); /* Returns the byte at the lowest address */
}
#+end_src

This solution is sufficient for an interview. However, as the goal of
an interview is not just to solve problems, but also to impress your
interviewer, you may want to consider a slightly more elegant way to
solve this problem. It involves using a feature of C/C++ called union
types. A union is like a struct, except that all of the members are
allocated starting at the same location in memory.
#+begin_src c
/* Returns true if the machine is little-endian, false if the
 * machine is big-endian
 */
bool endianness(){
    union {
        int theInteger;
        char singleByte;
    } endianTest;

    endianTest.theInteger = 1;
    return endianTest.singleByte;
}
#+end_src

** Number of Ones
Write a function that determines the number of 1 bits in the
computer’s internal representation of a given integer.

The number will be shifted to the right, but the new bit added on the
left will depend on how the shift operator treats negative values.
Let’s avoid the problem entirely and use Java’s >>> operator for our
example. In the other C-like languages, you can also avoid the problem
by reading the value as an unsigned integer. (That solution doesn’t
work with Java because there are no unsigned integer types in Java.)
Using either the >>> or an unsigned integer means that the shift
operator will not sign extend, and the new bits that are added during
the right shifting will be 0’s. The number will eventually become all
0’s. Finally, consider the case where you are given a positive
integer. This is the sample case that you worked with, and the
algorithm works correctly here.

The code for this algorithm is as follows:
#+begin_src java
int numOnesInBinary( int number )
{
     int numOnes = 0;
     while( number != 0 ){
          if( ( number & 1 ) == 1 )
              numOnes++;
          number = number >>> 1;
     } 
     return numOnes;
}
#+end_src

You can count the number of times that you can perform this process
before the integer’s value reaches 0. This is the number of 1’s in the
computer’s representation of the number. In outline form this
algorithm is as follows:
#+begin_src sh
Start with count = 0
While the integer is not zero
    AND the integer with the integer – 1
    Increment count
Return count
#+end_src
Here is the code:
#+begin_src java
int numOnesInBinary( int number ){
     int numOnes = 0;
     while( number != 0 ){
          number = number & (number – 1);
          numOnes++;
     }
     return numOnes;
}
#+end_src
This solution has a running time of O(m), where m is the number of 1’s
in the solution.


* Chapter 12: Counting, Measuring, and Ordering Puzzles
** Tackling Brainteasers
This property of brainteasers works most strongly to your advantage
when you are faced with a problem that has only two possible answers
(for example, any yes or no question). Whichever answer seems at first
to be correct is probably wrong. Of course, it’s probably not a good
idea to say, “The answer must be yes because if it were no this would
be a very simple problem and you wouldn’t have bothered to ask it.”
You can, however, use this knowledge to guide your thinking.

Tip Remember that the obvious answer is almost never the right answer.

** Solve the Right Problem
 For example, suppose you are given the problem of finding an
 arrangement that maximizes the number of oranges you can fit in the
 bottom of a square box. You would probably automatically assume that
 the oranges are small spherical fruit, that they are all about the
 same size, that “in the bottom” means in contact with the bottom
 surface of the box, and that the oranges must remain intact (you
 can’t puree them and pour them in). These assumptions may seem
 ridiculous - they are all rather obvious and they are all correct.
 The point is that assumptions are inherent in all communication or
 thought; you can’t begin to work on a problem without assumptions.


Tip 	
If the solution that seems logical is wrong, you made a false
assumption. Categorize your assumptions, and try to identify those
that are false.

** Don’t Be Intimidated
You don’t have to devise a plan for getting all the way to the
solution before you start - things will come to you as you work:

+ Break a problem into parts - If you can identify a subproblem, try solving that, even if you’re not sure it’s critical to solving the main problem.
+ Try a simplified problem - Try solving a simplified version of the problem; you may gain insights that will be useful in solving the full problem.
+ Try specific examples - If the problem involves some sort of
  process, try working through a few specific examples. You may notice
  a pattern you can generalize to other cases. Above all, keep
  talking, keep thinking, and keep working.


** Estimation Problems
One estimation problem is “How many gas stations are there in the
United States?” It has been so widely reported that this problem was
posed by Microsoft that it seems almost certain to be apocryphal;
nevertheless, it is a good example.

These problems are usually not difficult compared with the more common
brainteasers. You’re not expected to know the actual statistic or
fact. Instead, you are expected to do a rough order of magnitude
calculation based on facts you do know. Because everything is an
estimate anyway, try to adjust or round your figures so that any large
numbers you use are powers (or at least multiples) of ten - this will
significantly simplify your arithmetic.

Taking the gas station problem as an example, your calculation might
go like this: “It takes me about six minutes to fill up my car. I go
to the gas station about once a week, and there are usually two other
cars there. If I assume this is average for Americans, each gas
station services about 30 cars an hour. Suppose a gas station were
open 12 hours a day, 7 days a week. That would be 84 hours a week. In
reality, a gas station is probably open more than 12 hours a day, so
I’ll say the average gas station is open 100 hours a week. That means
it services 3,000 cars a week. There’s somewhere upwards of 250
million people in the United States. Not everyone has a car, so
suppose there are 100 million cars on the road. If every car goes to
the gas station once a week, like mine does, and each station sees
3,000 cars a week, there would have to be about 33,000 gas stations in
the United States.” This figure is probably off by a lot, but it’s
likely within an order of magnitude (that is, there are more than
3,300 gas stations and fewer than 330,000). It’s much more important
that you are able to form a framework for the estimation and rapidly
work through the calculations than that you accurately estimate the
statistic. For more practice, try estimating the number of
kindergarten teachers in your state, the circumference of the earth,
and the weight of a ferry boat.

** Brainteaser Problems
