#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: Programming Interviews Exposed: Secrets to Landing Your Next Job Notes
#+OPTIONS: num:nil H:2


* Chapter 1: Before the Search
** Develop Marketable Skills
The appendix covers how your résumé is primarily a marketing tool to
get you job interviews. This assumes, of course, that you have
marketable skills to offer a prospective employer. You can only
stretch the truth so far, and if even you exaggerate or outright lie
about your skills and what you’ve accomplished in the past, you
probably won’t make it through technical interviews designed
specifically to weed out the liars and exaggerators of this world.
What you need to do, then, is develop skills and accomplishments that
will make you stand out from the crowd both on paper and in the
interviews, especially if you’re entering the job market for the first
time. Here are some approaches you can take:

+ Upgrade your credentials - Companies such as Google are well known
  for favoring job applicants with graduate degrees. Getting a
  master’s or doctorate degree is one way to upgrade your credentials.
  Although pursuing a graduate degree is a large commitment on your
  part, you can upgrade your credentials in other ways, such as taking
  university or professional development courses or participating in
  programming contests. 
+ Get certified - Certification is a touchy
  issue in the software development profession, but there’s no doubt
  that some jobs either prefer or require candidates to be certified
  in specific technologies, especially IT jobs. 
+ Work on a side project - A great way to expand your skill set is to
  work on a project that is not directly related to your primary work
  or study focus. Starting or joining an open-source development
  project is one way to go. Or if you’re working at a company, see if
  they’ll let you spend time on an ancillary project.

+ Do well in school - Although grades aren’t everything, they are one
  measure that companies use in order to rank new graduates with
  little job experience. The better your grades, especially in
  computer science and mathematics courses, the more you’ll impress a
  potential employer.

+ Keep learning - The end of formal education doesn’t mean you should
  stop learning, especially when there’s so much information about
  programming available from a wide variety of sources. Whether it’s
  books or blogs, there’s always a way to keep yourself current, no
  matter what type of programming you do. It’s also a great way to
  expand your horizons and discover other areas of interest.

+ Be an intern - New graduates who’ve managed to secure employment
  during their nonschool terms - especially those that participate in
  cooperative education programs - have a huge leg up over their peers
  who haven’t yet ventured into the real world. Software development
  in the field is often very different from software development in an
  academic setting, and potential employers are very cognizant of
  this.


The key is to keep learning, no matter what stage of your career
you’re at. Marketable skills don’t develop overnight; they take some
effort and initiative on your part, but they’ll have long-lasting
effects on your career.

Note that one of the best ways to develop marketable skills is to
accomplish something, whether it’s in your current job, something you
did as a side project, or something you worked on as an intern or for
a class project. Being able to talk intelligently and confidently
about a project for which you played a primary role in its success is
incredibly important. Make sure you can describe the problem clearly
and succinctly and how your project solved the problem, even to a
nontechnical person. Displaying a passion for programming is always
positive and one way to make yourself stand out from the other
candidates.

* Chapter 2: The Job Application Process
* Chapter 3: Approaches to Programming Problems
** Interactivity Is Key
The code you write in the interview is probably the only example of
your code that your interviewer will see. If you write ugly code, your
interviewer will assume you always write ugly code. This is your
chance to shine and show your best code. Take the time to make your
code solid and pretty.

 *Tip Brush up on the languages you expect to use, and write your best code.*
Programming questions are designed to see both how well you can code
and how you solve problems. If all the interviewer wanted to do were
measure your coding ability, he could give you a piece of paper with
problems and come back an hour later to evaluate how you did, just as
they do in programming contests. What the interviewer wants is to see
your thought processes as you work through each stage of the
programming problem.

The problem-solving process in these interviews is very interactive,
and if you’re having difficulty, the interviewer will generally guide
you to the correct answer via a series of hints. Of course, the less
help you need to solve the problem, the better you look, but showing
an intelligent thought process and responding well to the hints you
are given is also very important.

Even when you immediately know the answer to a problem, because it’s
something you’ve already done before, don’t just blurt it out. Break
the answer down into discrete steps and explain the thought processes
behind each step. The point is to show the interviewer that you
understand the underlying concepts, not that you’ve managed to
memorize the answer to a programming puzzle.

If you know any additional information pertaining to the problem, you
may want to mention it during the process to show your general
knowledge of programming, even if it’s not directly applicable to the
problem at hand. In answering these problems, show that you’re not
just a propeller-head coder. Demonstrate that you have logical thought
processes, are generally knowledgeable about computers, and can
communicate well.

 *Tip Keep talking! Always explain what you are doing! Otherwise, the interviewer has no way of knowing how you tackle complex programming problems.*


** Solving the Questions
Now it’s time to solve the questions, but don’t just jump in. Instead,
remember you want to fully understand the problem. You should try an
example, and then focus on the algorithm that will solve the problem.
You then want to explain your solution and code for the solution. The
following steps walk you through the process:

*** The Basic Steps

The best way to solve an interview problem is to approach it
methodically. Here are the suggested steps:

1. Make sure you understand the problem. Your initial assumptions
   about the problem may be wrong, or the interviewer’s explanation
   may be very brief or difficult to follow. You can’t demonstrate
   your skills if you don’t understand the problem. Don’t hesitate to
   ask your interviewer questions about the problem, and don’t start
   solving it until you understand it. The interviewer may be
   deliberately obscuring things in order to determine whether you can
   find and understand the real problem.

2. Once you understand the question, try an example. This example may
   lead to insights about how to solve the problem or bring to light
   any remaining misunderstandings that you have. Starting with an
   example also demonstrates a methodical, logical thought process.
   Examples are especially useful if you don’t see the solution right
   away.

Tip 	Make sure you understand the problem before you start solving it, and then start with an example to solidify your understanding.
3. Focus on the algorithm you will use to solve the problem. Often,
   this will take a long time and require additional examples. This is
   to be expected. Interactivity is important during this process. If
   you stand quietly staring at the whiteboard, the interviewer has no
   way of knowing whether you’re making productive headway or are
   simply clueless. Talk to your interviewer and tell him or her what
   you are doing. For example, you might say something like, “I’m
   wondering whether I can store the values in an array and then sort
   them, but I don’t think that will work because I can’t quickly look
   up elements in an array by value.” This demonstrates your skill,
   which is the point of the interview, and may also lead to hints
   from the interviewer, who might respond, “You’re very close to the
   solution. Do you really need to look up elements by value, or could
   you …”

    It may take a long time to solve the problem, and you may be
   tempted to begin coding before you figure out an exact solution.
   Resist this temptation. Consider who you would rather work with:
   someone who thinks about a problem for a long time and then codes
   it correctly the first time or someone who hastily jumps into a
   problem, makes several errors while coding, and doesn’t have any
   idea where he or she is going. Not a difficult decision, is it?

4. After you’ve figured out your algorithm and how you will implement
   it, explain your solution to the interviewer. This gives him or her
   an opportunity to evaluate your solution before you begin coding.
   Your interviewer may say, “Sounds great, go ahead and code it,” or
   something like, “That’s not quite right because you can’t look up
   elements in a hash table that way.” In either case, you gain
   valuable information.

5. While you code, it’s important to explain what you’re doing. For
   example, you might say, “Here, I’m initializing the array to all
   zeroes.” This narrative enables the interviewer to follow your code
   more easily.

Tip 	Explain what you are doing to your interviewer before and
while coding the solution. Keep talking!

6. Ask questions when necessary. You generally won’t be penalized for
   asking factual questions that you might otherwise look up in a
   reference. You obviously can’t ask a question like, “How do I solve
   this problem?” but it is acceptable to ask a question like, “I
   can’t remember - what format string do I use to print out a
   localized date?” While it’s better to know these things, it’s okay
   to ask this sort of question.

7. After you’ve written the code for a problem, immediately verify
   that the code is correct by tracing through it with an example.
   This step demonstrates very clearly that your code works in at
   least one case. It also illustrates a logical thought process and
   your desire to check your work and search for bugs. The example may
   also help you flush out minor bugs in your solution.

8. Make sure you check your code for all error and special cases,
   especially boundary conditions. Many error and special cases are
   overlooked by programmers; forgetting these cases in an interview
   indicates you may forget them on the job. For example, if you
   allocate memory dynamically, make sure you check that the
   allocation did not fail. (If time does not allow for extensive
   checking, at the very least explain that you should check for such
   failures.) Covering error and special cases will impress your
   interviewer and help you correctly solve the problem.

Tip Try an example, and check all error and special cases.

Once you try an example and feel comfortable that your code is
correct, the interviewer may ask you questions about what you wrote.
Commonly, these questions focus on running time, alternative
implementations, and complexity. If your interviewer does not ask you
these questions, you should volunteer the information to show that you
are cognizant of these issues. For example, you could say, “This
implementation has linear running time, which is the best possible
because I have to check all the input values. The dynamic memory
allocation will slow it down a little, as will the overhead of using
recursion.”

*** When You Get Stuck

Getting stuck on a problem is expected and an important part of the
interviewing process. Interviewers want to see how you respond when
you don’t recognize the answer to a question immediately. Giving up or
getting frustrated is the worst thing to do if this happens to you.
Instead, show interest in the problem and keep trying to solve it:

+ Go back to an example. Try performing the task and analyzing what
  you are doing. Try extending from your specific example to the
  general case. You may have to use very detailed examples. This is
  okay, because it shows the interviewer your persistence in finding
  the correct solution.

Tip 	 When all else fails, return to a specific example. Try to move from the specific example to the general case and from there to the solution.
+ Try a different data structure. Perhaps a linked list, an array, a
  hash table, or a binary search tree will help. If you’re given an
  unusual data structure, look for similarities between it and
  more-familiar data structures. Using the right data structure often
  makes a problem much easier.

+ Consider the less-commonly used or more-advanced aspects of a
  language. Sometimes the key to a problem involves one of these
  features.

Tip 	Sometimes a different data structure or advanced language feature is key to the solution.

Even when you don’t feel stuck, you may be having problems. You may be
missing an elegant or obvious way to implement something and writing
too much code. Almost all interview coding questions have short
answers. You rarely need to write more than 15 lines of code and
almost never more than 30. If you start writing a lot of code, you may
be heading in the wrong direction.

* Chapter 4: Linked Lists
** Linked List Problems
A C++ version looks like the following:
#+begin_src c++
class Stack
{
public:
    Stack();
    ~Stack();
    void push( void *data );
    void *pop();
protected:
    // Element struct needed only internally
    typedef struct Element {
        struct Element *next;
        void *data;
    } Element;

    Element *head;
};

Stack::Stack() {
    head = NULL;
    return;
}

Stack::~Stack() {
    while( head ){
        Element *next = head->next;
        delete head;
        head = next;
    }
    return;
}

void Stack::push( void *data ){
    //Allocation error will throw exception
    Element *element = new Element;
    element->data = data;
    element->next = head;
    head = element;
    return;
}

void *Stack::pop() {
    Element *popElement = head;
    void *data;

    /* Assume StackError exception class is defined elsewhere */
    if( head == NULL )
        throw StackError( E_EMPTY );

    data = head->data;
    head = head->next;
    delete popElement;
    return data;
}
#+end_src

** Null or Cycle

Important 	
You are given a linked list that is either NULL-terminated (acyclic),
as shown in Figure 4-5, or ends in a cycle (cyclic), as shown in
Figure 4-6.

Write a function that takes a pointer to the head of a list and
determines whether the list is cyclic or acyclic. Your function should
return false if the list is acyclic and true if it is cyclic. You may
not modify the list in any way.Null or Cycle

Write a function that takes a pointer to the head of a list and
determines whether the list is cyclic or acyclic. Your function should
return false if the list is acyclic and true if it is cyclic. You may
not modify the list in any way.

In outline form, this algorithm looks like this:
#+begin_src sh
Start two pointers at the head of the list
Loop infinitely
    If the fast pointer reaches a NULL pointer
        Return that the list is NULL terminated
    If the fast pointer moves onto or over the slow pointer
        Return that there is a cycle
    Advance the slow pointer one node
    Advance the fast pointer two nodes
#+end_src
You can now implement this solution:
#+begin_src c
/* Takes a pointer to the head of a linked list and determines if
 * the list ends in a cycle or is NULL terminated
 */
bool determineTermination( Node *head ){
    Node *fast, *slow;
    fast = slow = head;
    while( true ){
        if( !fast || !fast->next )
            return false;
        else if( fast == slow || fast->next == slow )
            return true;
     else {
         slow = slow->next;
         fast = fast->next->next;
     }
  }
}
#+end_src

* Chapter 5: Trees and Graphs
** Following is some additional tree-related vocabulary:
+ Parent - A node that points to other nodes is the parent of those
  nodes. Every node except the root has one parent. In Figure 5-1, B
  is the parent of D, E, and F.

+ Child - A node is the child of any node that points to it. In Figure
  5-1, each of the nodes D, E, and F is a child of B.

+ Descendant - All the nodes that can be reached by following a path
  of child nodes from a particular node are the descendants of that
  node. In Figure 5-1, D, E, F, H, I, J, and K are the descendants of
  B.

+ Ancestor - An ancestor of a node is any other node for which the
  node is a descendant. For example, A, B, and D are the ancestors of
  I.

+ Leaves - The leaves are nodes that do not have any children. G, H,
  I, and K are leaves.

** Common Searches
*** Breadth-First Search
One way to search a tree is to do a breadth-first search (BFS). In a
BFS you start with the root, move left to right across the second
level, then move left to right across the third level, and so forth.
You continue the search until either you have examined all of the
nodes or you find the node you are searching for. The time to find a
node is O(n), so this type of search is best avoided for large trees.
A BFS also uses a large amount of memory because it is necessary to
track the child nodes for all nodes on a given level while searching
that level.

*** Depth-First Search
Another common way to search for a node is by using a depth-first
search (DFS). A depth-first search follows one branch of the tree down
as many levels as possible until the target node is found or the end
is reached. When the search can’t go down any farther, it is continued
at the nearest ancestor with unexplored children. DFS has much lower
memory requirements than BFS because it is not necessary to store all
of the child pointers at each level. In addition, DFS has the
advantage that it doesn’t examine any single level last (BFS examines
the lowest level last). This is useful if you suspect that the node
you are searching for will be in the lower levels. For example, if you
were searching a job hierarchy tree looking for an employee who
started less than three months ago, you would suspect that lower-level
employees are more likely to have started recently. In this case, if
the assumption were true, a DFS would usually find the target node
more quickly than a BFS.




** Traversals
+ Preorder traversal of a node performs the operation first on the
  node itself, then on its left descendants, and finally on its right
  descendants. In other words, a node is always visited before any of
  its children.

+ Inorder traversal performs the operation first on the node’s left
  descendants, then on the node itself, and finally on its right
  descendants. In other words, the left subtree is visited first, then
  the node itself, and then the node’s right subtree.

+ Postorder traversal performs the operation first on the node’s left
  descendants, then on the node’s right descendants, and finally on
  the node itself. In other words, all of a node’s children are
  visited before the node itself.


** Binary Tree Problems
*** Preorder Traversal, No Recursion
#+begin_src sh
Create the stack
Push the root node on the stack
While the stack is not empty
    Pop a node
    If the node is not null
        Print its value
        Push the node's right child on the stack
        Push the node's left child on the stack
#+end_src

#+begin_src java
void preorderTraversal( Node root ){
    NodeStack stack = new NodeStack();
    stack.push( root );
    while( true ){
        Node curr = stack.pop();
        if( curr == null ) break;
        curr.printValue();
        Node n = curr.getRight();
        if( n != null ) stack.push( n );
        n = curr.getLeft();
        if( n != null ) stack.push( n );
    }
}
#+end_src

*** Lowest Common Ancestor
* Chapter 6: Arrays and Strings
** Arrays
An array is a sequence of variables of the same type arranged
contiguously in a block of memory. 

** Strings
Strings are sequences of characters. However, what constitutes a
character depends greatly on the language being used and the settings
of the operating system on which the application runs.

** Array and String Problems
Both hash tables and arrays provide constant-time lookup; you need to
decide which one you will use. On the one hand, hash tables have a
higher lookup overhead than arrays. On the other hand, an array would
initially contain random values that you would have to take time to
set to zero, whereas a hash table initially has no values. Perhaps the
greatest difference is in memory requirements. An array would need an
element for every possible value of a character. This would amount to
a relatively reasonable 128 elements if you were processing ASCII
strings, but if you had to process Unicode strings you would need more
than 65,000 elements, assuming a 16-bit Unicode encoding. In contrast,
a hash table would require storage for only the characters that
actually exist in the input string. Therefore, arrays are a better
choice for long strings with a limited set of possible character
values; hash tables are more efficient for shorter strings or when
there are many possible character values.
* Chapter 7: Recursion
Although recursion is a very powerful technique, it is not always the
best approach, and rarely is it the most efficient approach. This is
due to the relatively large overhead for routine calls on most
platforms. For a simple recursive routine like factorial, many
computer architectures spend more time on call overhead than the
actual calculation. Iterative routines, which use looping constructs
instead of recursive routine calls, do not suffer from this overhead
and are frequently more efficient.

Tip Iterative solutions are usually more efficient than recursive solutions.

This implementation is significantly more efficient than our previous
recursive implementation because no routine calls are involved.
Although it represents a different way of thinking about the problem,
it’s not really any more difficult to write than the recursive
implementation


Tip 	
A recursive algorithm can be implemented without recursive calls by
using a stack, but it’s usually more trouble than it’s worth.

In an interview, a working solution is of primary importance; an
efficient solution is secondary. Unless you’ve been told otherwise, go
with whatever type of working solution comes to you first. If it’s a
recursive solution, you might want to mention the inefficiencies
inherent in recursive solutions to your interviewer, so it’s clear
that you know about them. In the rare instance that you see a
recursive solution and an iterative solution of roughly equal
complexity, you should probably mention them both to the interviewer,
indicating that you’re going to work out the iterative solution
because it’s likely to be more efficient.

** Recursion Problems

* Chapter 8: Concurrency
** Basic Thread Concepts
*** Threads

A thread is the fundamental unit of execution within an application: A
running application consists of at least one thread. Each thread has
its own stack and runs independently from the application’s other
threads. Threads share the resources used by the application as it
runs, such as file handles or memory, which is why problems can occur.
Data corruption is a common side effect of having two threads
simultaneously write data to the same block of memory, for example.

*** Monitors and Semaphores

In order to avoid data corruption and other problems, applications
must control how threads interact with shared resources, referred to
as thread synchronization. The two fundamental thread synchronization
constructs are monitors and semaphores. Which you use depends on what
your system or language supports.

** Concurrency Problems
*** Busy Waiting
*** Producer/Consumer
#+begin_src java
public class IntBuffer {
    private int   index;
    private int[] buffer = new int[8];

    public synchronized void add( int num ){
        while( index == buffer.length - 1 ){
            try {
                wait();
            }
            catch( InterruptedException e ){
            }
        }

        buffer[index++] = num;
        notifyAll();
    }

    public synchronized int remove(){
        while( index == 0 ){
            try {
                wait();
            }
            catch( InterruptedException e ){
            }
        }

        int ret = buffer[--index];
        notifyAll();
        return ret;
    }
}

public class Producer extends Thread {
    private IntBuffer buffer;

    public Producer( IntBuffer buffer ){
        this.buffer = buffer;
    }

    public void run(){
        Random r = new Random();
        while( true ){
            int num = r.nextInt();
            buffer.add( num );
            System.out.println( "Produced " + num );
        }
    }
}

public class Consumer extends Thread {
    private IntBuffer buffer;

    public Consumer( IntBuffer buffer ){
        this.buffer = buffer;
    }

    public void run(){
        while( true ){
            int num = buffer.remove();
            System.out.println( "Consumed " + num );
        }
    }
}


IntBuffer b = new IntBuffer();
Producer p = new Producer( b );
Consumer c = new Consumer( b );
p.start();
c.start();
#+end_src

*** The Dining Philosophers
This application deadlocks when all philosophers have simultaneously
picked up their left fork: Because no right fork is available to any
philosopher, no philosopher can eat.

One solution is to add a timeout to the waiting: If a philosopher is
not able to eat within a predetermined amount of time after acquiring
the first fork, then the philosopher drops the fork and tries again.
The flaw with this solution is that it’s possible for one or more
philosophers to starve because they never acquire both forks. This is
referred to as livelock.

The best solution requires a very simple change to the application.
Instead of having all the philosophers pick up the left fork first,
have one of the philosophers pick up the right fork first:

* Chapter 9: Object-Oriented Programming
