#    -*- mode: org -*-


Archived entries from file /home/felix/Dropbox/Blog/wiki/src/Embedded-System/kernel/system-calls.org


* Dispatching and Parameter Passing
  :PROPERTIES:
  :ARCHIVE_TIME: 2014-11-27 Thu 12:08
  :ARCHIVE_FILE: ~/Dropbox/Blog/wiki/src/Embedded-System/kernel/system-calls.org
  :ARCHIVE_OLPATH: Implementation of System Calls/Structure of System Calls
  :ARCHIVE_CATEGORY: system-calls
  :END:
System calls唯一的以一个数字来标识.所有的calls由一个中心代码处理,使用
这个数字去调用特定函数通过查询一个静态表.参数传递也由这个中心代码处理,
所以代码传递的实现与system call是独立的.

从user转到kernel模式,参数的传递以汇编代码实现来适应特定的平台特性. 参
数传递直接在寄存器中在所有平台上.更多一个寄存器需要来存储system call的
数字被使用来之后查找到相应的处理函数.

IA-32为例, 指令 =int $0x80= 转到kernel模式, system call数字在寄存器
=eax= ,其他参数在 ebx, ecx, edx,esi,和edi.

=sys_call_table= 的表格维护一组指向处理函数的函数指针,并在所有平台上.因
为这个表格由汇编代码生成,所有在平台见不一样.但理念是一样的,通过system
call的数字标识,kernel在表中找到相应位置的处理函数.比如ARM定义的如下表
格:

#+begin_src c
// arch/arm/kernel/calls.S

#+end_src

