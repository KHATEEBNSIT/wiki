#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE:  C puzzles and FAQ
#+OPTIONS: num:nil H:2

* read() and write() truncate buffer length

https://bugzilla.redhat.com/show_bug.cgi?id=612839

* 在宏定义中使用 do...while[fn:1]
** do...while(0)消除goto语句
通常，如果在一个函数中开始要分配一些资源，然后在中途执行过程中如果遇到
错误则退出函数，当然，退出前先释放资源，我们的代码可能是这样：

*** version 1
#+begin_src c
bool Execute()
{
   // 分配资源
   int *p = new int;
   bool bOk(true);

   // 执行并进行错误处理
   bOk = func1();
   if(!bOk) 
   {
      delete p;   
      p = NULL;
      return false;
   }

   bOk = func2();
   if(!bOk) 
   {
      delete p;   
      p = NULL;
      return false;
   }

   bOk = func3();
   if(!bOk) 
   {
      delete p;   
      p = NULL;
      return false;
   }

   // ..........

   // 执行成功，释放资源并返回
    delete p;   
    p = NULL;
    return true;
   
}
#+end_src
这里一个最大的问题就是代码的冗余，而且我每增加一个操作，就需要做相应的
错误处理，非常不灵活。于是我们想到了goto:

*** version 2
#+begin_src c
bool Execute()
{
   // 分配资源
   int *p = new int;
   bool bOk(true);

   // 执行并进行错误处理
   bOk = func1();
   if(!bOk) goto errorhandle;

   bOk = func2();
   if(!bOk) goto errorhandle;

   bOk = func3();
   if(!bOk) goto errorhandle;

   // ..........

   // 执行成功，释放资源并返回
    delete p;   
    p = NULL;
    return true;

errorhandle:
    delete p;   
    p = NULL;
    return false;
   
}
#+end_src
代码冗余是消除了，但是我们引入了C++中身份比较微妙的goto语句，虽然正确
的使用goto可以大大提高程序的灵活性与简洁性，但太灵 活的东西往往是很危
险的，它会让我们的程序捉摸不定，那么怎么才能避免使用goto语句，又能消除
代码冗余呢，请看do...while(0)循环：

*** version 3
#+begin_src c
bool Execute()
{
   // 分配资源
   int *p = new int;

   bool bOk(true);
   do
   {
      // 执行并进行错误处理
      bOk = func1();
      if(!bOk) break;

      bOk = func2();
      if(!bOk) break;

      bOk = func3();
      if(!bOk) break;

      // ..........

   }while(0);

    // 释放资源
    delete p;   
    p = NULL;
    return bOk;
   
}
#+end_src
* Swap
 *swap1*
#+begin_src c
void swap1(int *q1,int *q2)
{
  int temp;
  temp = *q1;
  *q1 = *q2;
  *q2 = temp;
}
#+end_src
 *swap2*
#+begin_src c
void swap2(int *q1, int *q2)
{
  int *temp;
  temp = q1;
  q1 = q2;
  q2 = temp;
}
#+end_src
* 指针数组和数组指针
=int *p[2];= 首先声明了一个数组，数组的元素是int型的指针。用于存储指针的
数组

=int (*p)[2];= 声明了一个指针， 指向了一个有两个int元素的数组。指向数组
的指针

#+begin_src c
typedef int* intPtr;
intPtr p[2];

typedef int intArray[2];
intArray *p;
#+end_src

#+begin_src c
  int array[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};/* 定义二维数组m并初始化*/
  int (*p)[4];/*指向数组的指针  p是指针，指向一维数组,每个一维数组有4个int元素*/
  int *q[3];/*用于存储指针的数组 q是数组，数组元素是指针，3个int指针*/
  
  p=m;    //p是指针，可以直接指向二维数组
  
  for(i=0;i<3;i++)
    q[i]=m[i];//q是数组，元素q[i]是指针
#+end_src

* pointer
http://see.xidian.edu.cn/cpp/html/476.html
http://see.xidian.edu.cn/cpp/html/477.html
http://abruzzi.iteye.com/blog/416199
http://topic.csdn.net/u/20080710/15/01ca0f15-4403-45c1-91a8-a0326ceed700.html
http://blog.csdn.net/qq515383106/article/details/7370241
http://blog.csdn.net/dtmine/article/details/7366750

* Footnotes

[fn:1] http://blog.csdn.net/carry1314lele/article/details/2191113


* What is the significance of the keyword “volatile” in C?
		
SOLUTION
Volatile informs the compiler that the value of the variable can
change from the outside, without any update done by the code.
Declaring a simple volatile variable:
#+begin_src c
volatile int x;
int volatile x;
#+end_src
Declaring a pointer variable for a volatile memory (only the pointer
address is volatile):
#+begin_src c
volatile int * x;
int volatile * x;
#+end_src
Declaring a volatile pointer variable for a non-volatile memory (only
memory contained is volatile):
#+begin_src c
int * volatile x;
#+end_src 
Declaring a volatile variable pointer for a volatile memory (both
pointer address and memory contained are volatile):
#+begin_src c
volatile int * volatile x;
int volatile * volatile x;
#+end_src
Volatile variables are not optimized, but this can actually be useful.
Imagine this function:
#+begin_src c
int opt = 1;
void Fn(void) {
	
start:
		
if (opt == 1) goto start;
		
else break;
}
#+end_src
At first glance, our code appears to loop infinitely. The compiler
will try to optimize it to:
#+begin_src c
void Fn(void) {
	
start:
		
int opt = 1;
		
if (true)
		
goto start;
}
#+end_src
This becomes an infinite loop. However, an external program might
write ‘0’ to the location of variable opt. Volatile variables are also
useful when multi-threaded programs have global variables and any
thread can modify these shared variables. Of course, we don’t want
optimization on them.

