#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE:  C puzzles and FAQ
#+OPTIONS: num:nil H:2

* read() and write() truncate buffer length

https://bugzilla.redhat.com/show_bug.cgi?id=612839

* 在宏定义中使用 do...while[fn:1]
** do...while(0)消除goto语句
通常，如果在一个函数中开始要分配一些资源，然后在中途执行过程中如果遇到
错误则退出函数，当然，退出前先释放资源，我们的代码可能是这样：

*** version 1
#+begin_src c
bool Execute()
{
   // 分配资源
   int *p = new int;
   bool bOk(true);

   // 执行并进行错误处理
   bOk = func1();
   if(!bOk) 
   {
      delete p;   
      p = NULL;
      return false;
   }

   bOk = func2();
   if(!bOk) 
   {
      delete p;   
      p = NULL;
      return false;
   }

   bOk = func3();
   if(!bOk) 
   {
      delete p;   
      p = NULL;
      return false;
   }

   // ..........

   // 执行成功，释放资源并返回
    delete p;   
    p = NULL;
    return true;
   
}
#+end_src
这里一个最大的问题就是代码的冗余，而且我每增加一个操作，就需要做相应的
错误处理，非常不灵活。于是我们想到了goto:

*** version 2
#+begin_src c
bool Execute()
{
   // 分配资源
   int *p = new int;
   bool bOk(true);

   // 执行并进行错误处理
   bOk = func1();
   if(!bOk) goto errorhandle;

   bOk = func2();
   if(!bOk) goto errorhandle;

   bOk = func3();
   if(!bOk) goto errorhandle;

   // ..........

   // 执行成功，释放资源并返回
    delete p;   
    p = NULL;
    return true;

errorhandle:
    delete p;   
    p = NULL;
    return false;
   
}
#+end_src
代码冗余是消除了，但是我们引入了C++中身份比较微妙的goto语句，虽然正确
的使用goto可以大大提高程序的灵活性与简洁性，但太灵 活的东西往往是很危
险的，它会让我们的程序捉摸不定，那么怎么才能避免使用goto语句，又能消除
代码冗余呢，请看do...while(0)循环：

*** version 3
#+begin_src c
bool Execute()
{
   // 分配资源
   int *p = new int;

   bool bOk(true);
   do
   {
      // 执行并进行错误处理
      bOk = func1();
      if(!bOk) break;

      bOk = func2();
      if(!bOk) break;

      bOk = func3();
      if(!bOk) break;

      // ..........

   }while(0);

    // 释放资源
    delete p;   
    p = NULL;
    return bOk;
   
}
#+end_src
* Swap
 *swap1*
#+begin_src c
void swap1(int *q1,int *q2)
{
  int temp;
  temp = *q1;
  *q1 = *q2;
  *q2 = temp;
}
#+end_src
 *swap2*
#+begin_src c
void swap2(int *q1, int *q2)
{
  int *temp;
  temp = q1;
  q1 = q2;
  q2 = temp;
}
#+end_src
* 指针数组和数组指针
=int *p[2];= 首先声明了一个数组，数组的元素是int型的指针。用于存储指针的
数组

=int (*p)[2];= 声明了一个指针， 指向了一个有两个int元素的数组。指向数组
的指针

#+begin_src c
typedef int* intPtr;
intPtr p[2];

typedef int intArray[2];
intArray *p;
#+end_src

#+begin_src c
  int array[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};/* 定义二维数组m并初始化*/
  int (*p)[4];/*指向数组的指针  p是指针，指向一维数组,每个一维数组有4个int元素*/
  int *q[3];/*用于存储指针的数组 q是数组，数组元素是指针，3个int指针*/
  
  p=m;    //p是指针，可以直接指向二维数组
  
  for(i=0;i<3;i++)
    q[i]=m[i];//q是数组，元素q[i]是指针
#+end_src

* pointer
http://see.xidian.edu.cn/cpp/html/476.html
http://see.xidian.edu.cn/cpp/html/477.html
http://abruzzi.iteye.com/blog/416199
http://topic.csdn.net/u/20080710/15/01ca0f15-4403-45c1-91a8-a0326ceed700.html
http://blog.csdn.net/qq515383106/article/details/7370241
http://blog.csdn.net/dtmine/article/details/7366750

* the sizes of the standard types aren't precisely defined
Though C is considered relatively low-level as high-level languages
go, it does take the position that the exact size of an object (i.e.
in bits) is an implementation detail. Type int is supposed to
represent a machine's natural word size. 
* donot use gets()
** Example 1
#+begin_src c
char buf[256];
gets(buf);
#+end_src
One should never use gets, since there is no way to limit the amount of input it will
read. This leads to security problems(get the root priviledge). 
* strings are represented as null-terminated arrays[fn:2]
It makes some confusing problems.
** Example 1
#+begin_src c
char *p, buf[256];
p = malloc(strlen(buf)+1);
strcpy(p, buf);
#+end_src
=strlen= does not count the '\0' that terminates a string, while
=strcpy= copies it. So not enough space is allocated, and =strcpy= writes
past the end of the allocated space.
* What is the significance of the keyword “volatile” in C?
		
SOLUTION
Volatile informs the compiler that the value of the variable can
change from the outside, without any update done by the code.
Declaring a simple volatile variable:
#+begin_src c
volatile int x;
int volatile x;
#+end_src
Declaring a pointer variable for a volatile memory (only the pointer
address is volatile):
#+begin_src c
  volatile int * x;
  int volatile * x;
#+end_src
Declaring a volatile pointer variable for a non-volatile memory (only
memory contained is volatile):
#+begin_src c
int * volatile x;
#+end_src 
Declaring a volatile variable pointer for a volatile memory (both
pointer address and memory contained are volatile):
#+begin_src c
volatile int * volatile x;
int volatile * volatile x;
#+end_src
Volatile variables are not optimized, but this can actually be useful.
Imagine this function:
#+begin_src c
int opt = 1;
void Fn(void) {
	
start:
		
if (opt == 1) goto start;
		
else break;
}
#+end_src
At first glance, our code appears to loop infinitely. The compiler
will try to optimize it to:
#+begin_src c
void Fn(void) {
	
start:
		
int opt = 1;
		
if (true)
		
goto start;
}
#+end_src
This becomes an infinite loop. However, an external program might
write ‘0’ to the location of variable opt. Volatile variables are also
useful when multi-threaded programs have global variables and any
thread can modify these shared variables. Of course, we don’t want
optimization on them.

More:
+ Volatile: A programmer’s best friend:
  http://www.drdobbs.com/cpp/volatile-the-multithreaded-programmers-b/184403766

+ Do not use volatile as a synchronization primitive:
  https://www.securecoding.cert.org/confluence/display/cplusplus/CON01-CPP.+Do+not+use+volatile+as+a+synchronization+primitive

* Scope rules in C
Block Scope: A Block is a set of statements enclosed within left and
right braces ({ and } respectively). Blocks may be nested in C (a
block may contain other blocks inside it). A variable declared in a
block is accessible in the block and all inner blocks of that block,
but not accessible outside the block.

Can variables of block be accessed in another subsequent block?

No, a variabled declared in a block can only be accessed inside the
block and all inner blocks of this block. For example, following
program produces compiler error.

#+begin_src c
int main()
{
  {
      int x = 10;
  }
  {
      printf("%d", x);  // Error: x is not accessible here
  }
  return 0;
}
#+end_src
Output:
=error: 'x' undeclared (first use in this function)=

* What are the default values of static variables in C?
In C, if an object that has static storage duration is not initialized explicitly, then:
+ if it has pointer type, it is initialized to a NULL pointer;
+ if it has arithmetic type, it is initialized to (positive or unsigned) zero;
+ if it is an aggregate, every member is initialized (recursively) according to these rules;
+ if it is a union, the first named member is initialized (recursively) according to these rules.

* Scansets in C
scanf family functions support scanset specifiers which are
represented by %[]. Inside scanset, we can specify single character or
range of characters. While processing scanset, scanf will process only
those characters which are part of scanset.

** store only capital letters to character array ‘str’
#+begin_src c
#include <stdio.h>
 
int main(void)
{
    char str[128];
 
    printf("Enter a string: ");
    scanf("%[A-Z]s", str);
 
    printf("You entered: %s\n", str);
 
    return 0;
}
#+end_src
#+begin_src  sh
  # ./scan-set 
  Enter a string: WIKI_aa
  You entered: WIKI
#+end_src
** stop reading
If first character of scanset is ‘^’, then the specifier will stop
reading after first occurence of that character.

#+begin_src c
#include <stdio.h>
 
int main(void)
{
    char str[128];
 
    printf("Enter a string: ");
    scanf("%[^o]s", str);
 
    printf("You entered: %s\n", str);
 
    return 0;
}
#+end_src
#+begin_src sh
#./scan-set
Enter a string: http://geeks for geeks
You entered: http://geeks f
#+end_src


* What is use of %n in printf() ?
In C printf(), %n is a special format specifier which instead of
printing something causes printf() to load the variable pointed by the
corresponding argument with a value equal to the number of characters
that have been printed by printf() before the occurrence of %n.

More printf:
http://swoolley.org/man.cgi/3/printf

#+begin_src c
#include<stdio.h>
 
int main()
{
  int c;
  printf("geeks for %ngeeks ", &c);
  printf("%d", c);
  getchar();
  return 0;
}
#+end_src

* Precedence of postfix ++ and prefix ++ in C/C++
In C/C++, precedence of Prefix ++ (or Prefix –) and dereference (*)
operators is same, and precedence of Postfix ++ (or Postfix –) is
higher than both Prefix ++ and *.

If p is a pointer then *p++ is equivalent to *(p++) and ++*p is
equivalent to ++(*p) (both Prefix ++ and * are right associative).
* Modulus on Negative Numbers
he emphasis is, sign of left operand is appended to result in case of
modulus operator in C.

* aa
#+begin_src c

#+end_src

* Footnotes

[fn:1] http://blog.csdn.net/carry1314lele/article/details/2191113

[fn:2] The Practice of Programming page 14



