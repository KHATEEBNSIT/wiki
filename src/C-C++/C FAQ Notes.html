<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>C FAQ Notes</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="C FAQ Notes"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-08-12 12:34:52 HKT"/>
<meta name="author" content="Shi Shougang"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../assets/stylesheet.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="org-div-home-and-up" style="text-align:right;font-size:70%;white-space:nowrap;">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">C FAQ Notes</h1>

<p>Offical Site: <a href="http://c-faq.com/">http://c-faq.com/</a>
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Declarations and Initializations</a>
<ul>
<li><a href="#sec-1-1">Q1.1 How should I decide which integer type to use?</a></li>
<li><a href="#sec-1-2">Q1.3 You no longer have to define your own typedefs, because the Standard header &lt;inttypes.h&gt; contains a complete set.</a></li>
<li><a href="#sec-1-3">Q1.10 Do all declarations for the same static function or variable have to include the storage class static?</a></li>
<li><a href="#sec-1-4">Q1.20b What does it mean for a function parameter to be const? What do the two const's in</a></li>
<li><a href="#sec-1-5">Q1.21  How do I construct declarations of complicated types such as ``array of N pointers to functions returning pointers to functions returning pointers to char'', or figure out what similarly complicated declarations mean?</a></li>
<li><a href="#sec-1-6">Q1.29 How can I determine which identifiers are safe for me to use and which are reserved?</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Structures, Unions, and Enumerations</a>
<ul>
<li><a href="#sec-2-1">Q2.6  I came across some code that declared a structure like this:</a></li>
<li><a href="#sec-2-2">Q2.10 How can I pass constant values to functions which accept structure arguments? How can I create nameless, immediate, constant structure values?</a></li>
<li><a href="#sec-2-3">Q2.11 How can I read/write structures from/to data files?</a></li>
<li><a href="#sec-2-4">Q2.12 Why is my compiler leaving holes in structures, wasting space and preventing ``binary'' I/O to external data files? Can I turn this off, or otherwise control the alignment of structure fields?</a></li>
<li><a href="#sec-2-5">Q2.14 How can I determine the byte offset of a field within a structure?</a></li>
<li><a href="#sec-2-6">Q2.21 Is there an automatic way to keep track of which field of a union is in use?</a></li>
<li><a href="#sec-2-7">Q2.25 I came across some structure declarations with colons and numbers next to certain fields, like this:</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Expressions</a>
<ul>
<li><a href="#sec-3-1">Q</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">1. Declarations and Initializations</h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">Q1.1 How should I decide which integer type to use?</h3>
<div class="outline-text-3" id="text-1-1">

<p> Under ANSI C, the maximum and minimum values for a particular machine
 can be found in the header file &lt;limits.h&gt;; here is a summary:
</p>


<pre class="src src-c">Base type       <span style="color: #98fb98;">Minimum</span> <span style="color: #87cefa;">size</span> (bits)     <span style="color: #98fb98;">Minimum</span> <span style="color: #87cefa;">value</span> (<span style="color: #98fb98;">signed</span>)  <span style="color: #98fb98;">Maximum</span> <span style="color: #87cefa;">value</span> (<span style="color: #98fb98;">signed</span>)  <span style="color: #98fb98;">Maximum</span> <span style="color: #87cefa;">value</span> (<span style="color: #98fb98;">unsigned</span>)
<span style="color: #98fb98;">char</span>    8       -127    127     255
<span style="color: #98fb98;">short</span>   16      -32,767 32,767  65,535
<span style="color: #98fb98;">int</span>     16      -32,767 32,767  65,535
<span style="color: #98fb98;">long</span>    32      -2,147,483,647  2,147,483,647   4,294,967,295

<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">char</span>) &lt;= <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">short</span>) &lt;= <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>) &lt;= <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">long</span>) &lt;= <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span>)
</pre>


</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">Q1.3 You no longer have to define your own typedefs, because the Standard header &lt;inttypes.h&gt; contains a complete set.</h3>
<div class="outline-text-3" id="text-1-2">

<p>The file path: <code>/usr/include/inttypes.h</code>.
</p>
<p>
The <code>inttypes.h</code> file is a C header file that is part of the C standard
library and API. It was added with the 1999 version of the ISO C
standard (known as C99). It includes the stdint.h header and defines a
number of macros for using it with the <code>printf</code> and <code>scanf</code> family of
functions, as well as functions for working with the intmax<sub>t</sub> type.<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup>
</p>
<ul>
<li id="sec-1-2-1">Naming Convention and format specifiers for Macros<br/>
The macros defined in inttypes.h follow a regular pattern to simplify
usage. The pattern followed is as follows:

<ul>
<li>First three characters
<ul>
<li>PRI for output format (printf, fwprintf, wprintf, etc.)
</li>
<li>SCN for input format (scanf, fwscanf, etc.)
</li>
</ul>

</li>
<li>Fourth character
<ul>
<li>d for decimal formatting
</li>
<li>x for hexadecimal formatting
</li>
<li>o for octal formatting
</li>
<li>u for unsigned int formatting
</li>
<li>i for integer formatting
</li>
</ul>

</li>
<li>Remaining Characters
<ul>
<li>N for N bit size assignment to the data type (Eg. 32 for 32-bit size for integer, 16 for 16-bit size for unsigned int and so on)
</li>
<li>PTR for pointer
</li>
<li>MAX for maximum supported bit size
</li>
<li>FAST, whose meaning is not clearly defined and is left to the implementation to decide what is meant by a "fast" integer data type.
</li>
</ul>

</li>
</ul>







<p>
Question 2.25
bit-fields; 
<a href="http://publications.gbdirect.co.uk/c_book/chapter6/bitfields.html">http://publications.gbdirect.co.uk/c_book/chapter6/bitfields.html</a>
<a href="http://www.linuxforu.com/2012/01/joy-of-programming-understanding-bit-fields-c/">http://www.linuxforu.com/2012/01/joy-of-programming-understanding-bit-fields-c/</a>
<a href="http://en.wikipedia.org/wiki/Single_precision">http://en.wikipedia.org/wiki/Single_precision</a>
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">Q1.10 Do all declarations for the same static function or variable have to include the storage class static?</h3>
<div class="outline-text-3" id="text-1-3">

<p>Additional links: An <a href="http://c-faq.com/decl/static.jd.html">article by Jutta Degener</a> explaining the subtly
different rules for static variables versus static functions.
</p>
<p>
Example:
</p>


<pre class="src src-c"><span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">object </span><span style="color: #ff7f24;">*/</span>      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">function </span><span style="color: #ff7f24;">*/</span>

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">o1</span>;           <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">f1</span>();             <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">external linkage </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">o2</span>;    <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">f2</span>();      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">internal linkage </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">o3</span>;    <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">f3</span>();      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">internal linkage </span><span style="color: #ff7f24;">*/</span>

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">o1</span>;    <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">f1</span>();      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">ERROR, both have external linkage </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">o2</span>;                                 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">ERROR, o2 has internal linkage </span><span style="color: #ff7f24;">*/</span>
                  <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">f2</span>();             <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">OK, picks up internal linkage </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">o3</span>;    <span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">f3</span>();      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">OK, both pick up internal linkage </span><span style="color: #ff7f24;">*/</span>
</pre>

<p>
The difference is case (2); where functions do pick up a previous
linkage even without "extern", objects don't.
</p>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">Q1.20b What does it mean for a function parameter to be const? What do the two const's in</h3>
<div class="outline-text-3" id="text-1-4">

<p><code>int f(const * const p)</code> mean?
</p>
<p>
The first of the two const's is perfectly appropriate and quite
useful; many functions declare parameters which are pointers to const
data, and doing so documents (and tends to enforce) the function's
promise that it won't modify the pointed-to data in the caller. The
second const, on the other hand, is almost useless; all it says is
that the function won't alter its own copy of the pointer, even though
it wouldn't cause the caller or the function any problems if it did,
nor is this anything the caller should care about in any case. The
situation is the same as if a function declared an ordinary
(non-pointer) parameter as const:
</p>
<p>
        <code>int f2(const int x)</code>
This says that nowhere in the body of f2() will the function assign a
different value to x. 
</p></div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">Q1.21  How do I construct declarations of complicated types such as ``array of N pointers to functions returning pointers to functions returning pointers to char'', or figure out what similarly complicated declarations mean?</h3>
<div class="outline-text-3" id="text-1-5">


<ol>
<li><code>char *(*(*a[N])())();</code>
</li>
</ol>

<p>Build the declaration up incrementally, using <code>typedefs</code>:
</p>


<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">char</span> *<span style="color: #98fb98;">pc</span>;       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">pointer to char </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">pc</span> <span style="color: #98fb98;">fpc</span>();       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">function returning pointer to char </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">fpc</span> *<span style="color: #98fb98;">pfpc</span>;      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">pointer to above </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">pfpc</span> <span style="color: #98fb98;">fpfpc</span>();   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">function returning... </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">fpfpc</span> *<span style="color: #98fb98;">pfpfpc</span>;  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">pointer to... </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">pfpfpc</span> <span style="color: #eedd82;">a</span>[N];            <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">array of... </span><span style="color: #ff7f24;">*/</span>
</pre>

<p>
Use the <b>cdecl</b> program, which turns English into C and vice versa.
You provide a longhand description of the type you want, and cdecl
responds with the equivalent C declaration:
</p>


<pre class="src src-sh">cdecl&gt; declare a as array of pointer to <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">returning</span>
        pointer to <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">returning</span> pointer to char

char *(*(*a[])())()
</pre>

<p>
 <b>cdecl</b> can also explain complicated declarations (you give it a
complicated declaration and it responds with an English description),
help with casts, and indicate which set of parentheses the parameters
go in (for complicated function definitions, like the one above).
</p>
<p>
One way to make sense of complicated C declarations is by reading them
``inside out,'' remembering that [] and () bind more tightly than *.
For example, given
</p>
<p>
        <code>char *(*pfpc)();</code>
</p>
<p>
we can see that pfpc is a pointer (the inner *) to a function (the ())
to a pointer (the outer *) to char. When we later use pfpc, the
expression *(*pfpc)() (the value pointed to by the return value of a
function pointed to by pfpc) will be a char.
</p>
<p>
Another way of analyzing these declarations is to decompose the
declarator while composing the description, maintaining the
``declaration mimics use'' relationship: 
</p>


<pre class="src src-c">*(*pfpc)()      is a    <span style="color: #98fb98;">char</span>
(*<span style="color: #87cefa;">pfpc</span>)()       is a    pointer to <span style="color: #98fb98;">char</span>
(*<span style="color: #eedd82;">pfpc</span>) is a    function returning pointer to <span style="color: #98fb98;">char</span>
<span style="color: #eedd82;">pfpc</span>    is a    pointer to function returning pointer to <span style="color: #98fb98;">char</span>
</pre>

<p>
If you'd like to make things clearer when declaring complicated types
        like these, you can make the analysis explicit by using a
        chain of typedefs as in option 2 above.
 <b>Additional links:</b>
David Anderson's <a href="http://c-faq.com/decl/spiral.anderson.html">``Clockwise/Spiral Rule''</a>
</p>
<p>
There is a technique known as the ``Clockwise/Spiral Rule'' which
enables any C programmer to parse in their head any C declaration!
</p>
<p>
There are three simple steps to follow:
</p>
<ol>
<li>Starting with the unknown element, move in a spiral/clockwise direction; when ecountering the following elements replace them with the corresponding english statements:
</li>
</ol>

<p>[X] or []
=&gt; Array X size of&hellip; or Array undefined size of&hellip;
(type1, type2)
<code>&gt; function passing type1 and type2 returning... =*</code>
=&gt; pointer(s) to&hellip;
</p><ol>
<li>Keep doing this in a spiral/clockwise direction until all tokens have been covered.
</li>
<li>Always resolve anything in parenthesis first!
 <b>Example #1: Simple declaration</b>
</li>
</ol>




<pre class="src src-sh">     +-------+
     | +-+   |
     | ^ |   |
char *str[10];
 ^   ^   |   |
 |   +---+   |
 +-----------+
</pre>

<p>
Question we ask ourselves: What is str?
</p>
<p>
``str is an&hellip;
</p><ul>
<li>We move in a spiral clockwise direction starting with `str' and the first character we see is a `[' so, that means we have an array, so&hellip;
</li>
</ul>

<p>``str is an array 10 of&hellip;
</p><ul>
<li>Continue in a spiral clockwise direction, and the next thing we encounter is the `*' so, that means we have pointers, so&hellip;
</li>
</ul>

<p>``str is an array 10 of pointers to&hellip;
</p><ul>
<li>Continue in a spiral direction and we see the end of the line (the `;'), so keep going and we get to the type `char', so&hellip;
</li>
</ul>

<p>``str is an array 10 of pointers to char''
</p><ul>
<li>We have now ``visited'' every token; therefore we are done!
 <b>Example #2: Pointer to Function declaration</b>
</li>
</ul>




<pre class="src src-c">     +--------------------+
     | +---+              |
     | |+-+|              |
     | |^ ||              |
<span style="color: #98fb98;">char</span> *(*fp)( <span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">float</span> *);
 ^   ^ ^  ||              |
 |   | +--+|              |
 |   +-----+              |
 +------------------------+
</pre>

<p>
Question we ask ourselves: What is fp?
</p>
<p>
``fp is a&hellip;
</p><ul>
<li>Moving in a spiral clockwise direction, the first thing we see is a `)'; therefore, fp is inside parenthesis, so we continue the spiral inside the parenthesis and the next character seen is the `*', so&hellip;
</li>
</ul>

<p>``fp is a pointer to&hellip;
</p><ul>
<li>We are now out of the parenthesis and continuing in a spiral clockwise direction, we see the `('; therefore, we have a function, so&hellip;
</li>
</ul>

<p>``fp is a pointer to a function passing an int and a pointer to float returning&hellip;
</p><ul>
<li>Continuing in a spiral fashion, we then see the `*' character, so&hellip;
</li>
</ul>

<p>``fp is a pointer to a function passing an int and a pointer to float returning a pointer to&hellip;
</p><ul>
<li>Continuing in a spiral fashion we see the `;', but we haven't visited all tokens, so we continue and finally get to the type `char', so&hellip;
</li>
</ul>

<p>``fp is a pointer to a function passing an int and a pointer to float returning a pointer to a char''
 *Example #3: The ``Ultimate''*
</p>


<pre class="src src-c">      +-----------------------------+
      |                  +---+      |
      |  +---+           |+-+|      |
      |  ^   |           |^ ||      |
<span style="color: #98fb98;">void</span> (*signal(<span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">fp</span>)(<span style="color: #98fb98;">int</span>)))(<span style="color: #98fb98;">int</span>);
 ^    ^      |      ^    ^  ||      |
 |    +------+      |    +--+|      |
 |                  +--------+      |
 +----------------------------------+
</pre>

<p>
Question we ask ourselves: What is `signal'?
</p>
<p>
Notice that signal is inside parenthesis, so we must resolve this first!
</p>
<ul>
<li>Moving in a clockwise direction we see `(' so we have&hellip;
 ``signal is a function passing an int and a&hellip;
</li>
<li>Hmmm, we can use this same rule on `fp', so&hellip; What is fp? fp is also inside parenthesis so continuing we see an `*', so&hellip;
 fp is a pointer to&hellip;
</li>
<li>Continue in a spiral clockwise direction and we get to `(', so&hellip;
 ``fp is a pointer to a function passing int returning&hellip;''
</li>
<li>Now we continue out of the function parenthesis and we see void, so&hellip;
 ``fp is a pointer to a function passing int returning nothing (void)''
</li>
<li>We have finished with fp so let's catch up with `signal', we now have&hellip;
 ``signal is a function passing an int and a pointer to a function passing an int returning nothing (void) returning&hellip;
</li>
<li>We are still inside parenthesis so the next character seen is a `*', so&hellip;
 ``signal is a function passing an int and a pointer to a function passing an int returning nothing (void) returning a pointer to&hellip;
</li>
<li>We have now resolved the items within parenthesis, so continuing clockwise, we then see another `(', so&hellip;
 ``signal is a function passing an int and a pointer to a function passing an int returning nothing (void) returning a pointer to a function passing an int returning&hellip;
</li>
<li>Finally we continue and the only thing left is the word `void', so the final complete definition for signal is:
 ``signal is a function passing an int and a pointer to a function passing an int returning nothing (void) returning a pointer to a function passing an int returning nothing (void)''
</li>
</ul>


<p>
The same rule is applied for const and volatile. For Example:
</p>
<p>
        <code>const char *chptr;</code>
</p><ul>
<li>Now, what is chptr??
</li>
</ul>

<p>``chptr is a pointer to a char constant''
</p>
<p>
How about this one:
</p>
<p>
        char * const chptr;
</p><ul>
<li>Now, what is chptr??
</li>
</ul>

<p>``chptr is a constant pointer to char''
</p>
<p>
Finally:
</p>
<p>
        volatile char * const chptr;
</p><ul>
<li>Now, what is chptr??
</li>
</ul>

<p>``chptr is a constant pointer to a char volatile.''
</p></div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">Q1.29 How can I determine which identifiers are safe for me to use and which are reserved?</h3>
<div class="outline-text-3" id="text-1-6">

<p>What do the above rules really mean? If you want to be on the safe side:
</p>
<p>
1,2. Don't give anything a name with a leading underscore.
</p><ol>
<li>Don't give anything a name which is already a standard macro (including the ``future directions'' patterns).
</li>
<li>Don't give any functions or global variables names which are already taken by functions or variables in the standard library, or which match any of the ``future directions'' patterns. (Strictly speaking, ``matching'' means matching in the first six characters, without regard to case; see question 11.27.)
</li>
<li>Don't redefine standard typedef or tag names.
</li>
</ol>


<p>
In fact, the preceding subparagraphs are overly conservative. If you wish, you may remember the following exceptions:
</p>
<p>
1,2. You may use identifiers consisting of an underscore followed by a digit or lower case letter for labels and structure/union members.
1,2. You may use identifiers consisting of an underscore followed by a digit or lower case letter at function, block, or prototype scope.
</p><ol>
<li>You may use names matching standard macro names if you don't #include any header files which #define them.
</li>
<li>You may use names of standard library routines as static or local variables (strictly speaking, as identifiers with internal or no linkage).
</li>
<li>You may use standard typedef and tag names if you don't #include any header files which declare them.
</li>
</ol>


<p>
However, before making use of any of these exceptions, recognize that
some of them are pretty risky (especially exceptions 3 and 5, since
you could accidentally #include the relevant header file at a later
time, perhaps through a chain of nested #include files), and others
(especially the ones labeled 1,2) represent sort of a ``no man's
land'' between the user namespaces and the namespaces reserved to the
implementation.
</p></div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">2. Structures, Unions, and Enumerations</h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1">Q2.6  I came across some code that declared a structure like this:</h3>
<div class="outline-text-3" id="text-2-1">




<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> {
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">namelen</span>;
        <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">namestr</span>[1];
};
</pre>

<p>
and then did some tricky allocation to make the <code>namestr</code> array act like
        it had several elements, with the number recorded by namelen.
        How does this work? Is it legal or portable?
</p>
<p>
An implementation of the technique might look something like this:
</p>


<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> *<span style="color: #87cefa;">makename</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">newname</span>)
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> *<span style="color: #eedd82;">ret</span> =
                malloc(<span style="color: #00ffff;">sizeof</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span>)-1 + strlen(newname)+1);
                                <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">-1 for initial [1]; +1 for \0 </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">if</span>(ret != <span style="color: #7fffd4;">NULL</span>) {
                ret-&gt;namelen = strlen(newname);
                strcpy(ret-&gt;namestr, newname);
        }

        <span style="color: #00ffff;">return</span> ret;
}
</pre>

<p>
This function allocates an instance of the name structure with the
size adjusted so that the namestr field can hold the requested name
(not just one character, as the structure declaration would suggest).
</p>
<p>
Another possibility is to declare the variable-size element very
large, rather than very small. The above example could be rewritten
like this:
</p>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXSIZE</span> 100

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> {
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">namelen</span>;
        <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">namestr</span>[MAXSIZE];
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> *<span style="color: #87cefa;">makename</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">newname</span>)
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> *<span style="color: #eedd82;">ret</span> =
                malloc(<span style="color: #00ffff;">sizeof</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span>)-MAXSIZE+strlen(newname)+1);
                                                                <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">+1 for \0 </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">if</span>(ret != <span style="color: #7fffd4;">NULL</span>) {
                ret-&gt;namelen = strlen(newname);
                strcpy(ret-&gt;namestr, newname);
        }

        <span style="color: #00ffff;">return</span> ret;
}
</pre>

<p>
where MAXSIZE is larger than any name which will be stored. 
</p>
<p>
Of course, to be truly safe, the right thing to do is use a character
pointer instead of an array:
</p>


<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> {
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">namelen</span>;
        <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">namep</span>;
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> *<span style="color: #87cefa;">makename</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">newname</span>)
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> *<span style="color: #eedd82;">ret</span> = malloc(<span style="color: #00ffff;">sizeof</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span>));
        <span style="color: #00ffff;">if</span>(ret != <span style="color: #7fffd4;">NULL</span>) {
                ret-&gt;namelen = strlen(newname);
                ret-&gt;namep = malloc(ret-&gt;namelen + 1);
                <span style="color: #00ffff;">if</span>(ret-&gt;namep == <span style="color: #7fffd4;">NULL</span>) {
                        free(ret);
                        <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
                }
                strcpy(ret-&gt;namep, newname);
        }

        <span style="color: #00ffff;">return</span> ret;
}
</pre>

<p>
(Obviously, the ``convenience'' of having the length and the string
stored in the same block of memory has now been lost, and freeing
instances of this structure will require two calls to free; see
question 7.23.)
</p></div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2">Q2.10 How can I pass constant values to functions which accept structure arguments? How can I create nameless, immediate, constant structure values?</h3>
<div class="outline-text-3" id="text-2-2">

<p>C99 introduces ``compound literals'', one form of which provides for structure constants. For example, to pass a constant coordinate pair to a hypothetical plotpoint function which expects a struct point, you can call
</p>
<p>
        <code>plotpoint((struct point){1, 2});</code>
Combined with ``designated initializers'' (another C99 feature), it is also possible to specify member values by name:
        <code>plotpoint((struct point){.x=1, .y=2});</code>
</p></div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3">Q2.11 How can I read/write structures from/to data files?</h3>
<div class="outline-text-3" id="text-2-3">

<p>It is relatively straightforward to write a structure out using fwrite:
</p>
<p>
        <code>fwrite(&amp;somestruct, sizeof somestruct, 1, fp);</code>
and a corresponding <code>fread</code> invocation can read it back in. What happens
here is that <code>fwrite</code> receives a pointer to the structure, and writes
(or <code>fread</code> correspondingly reads) the memory image of the structure as
a stream of bytes. The sizeof operator determines how many bytes the
structure occupies.
</p>
<p>
However, data files written as memory images in this way will not be
portable, particularly if they contain floating-point fields or
pointers. The memory layout of structures is machine and compiler
dependent. Different compilers may use different amounts of padding
(see question 2.12), and the sizes and byte orders of fundamental
types vary across machines.
</p></div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4">Q2.12 Why is my compiler leaving holes in structures, wasting space and preventing ``binary'' I/O to external data files? Can I turn this off, or otherwise control the alignment of structure fields?</h3>
<div class="outline-text-3" id="text-2-4">

<p>Additional <a href="http://c-faq.com/struct/align.esr.html">ideas on working with alignment and padding</a> by Eric Raymond, couched in the form of six new FAQ list questions 
</p>
<p>
Corrections to the above from <a href="http://c-faq.com/struct/align.esr2.html">Norm Diamond</a> and <a href="http://c-faq.com/struct/align.esr3.html">Clive Feather</a>
</p></div>

</div>

<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5">Q2.14 How can I determine the byte offset of a field within a structure?</h3>
<div class="outline-text-3" id="text-2-5">

<p> ANSI C defines the <code>offsetof()</code> macro in <code>&lt;stddef.h&gt;</code>, which lets you
 compute the offset of field f in struct s as offsetof(struct s, f).
 If for some reason you have to code this sort of thing yourself, one
 possibility is
</p>


<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">offsetof</span>(<span style="color: #eedd82;">type</span>, <span style="color: #eedd82;">f</span>) ((<span style="color: #98fb98;">size_t</span>) \
        ((<span style="color: #98fb98;">char</span> *)&amp;((<span style="color: #98fb98;">type</span> *)0)-&gt;f - (<span style="color: #98fb98;">char</span> *)(<span style="color: #98fb98;">type</span> *)0))
</pre>

<p>
This implementation is not 100% portable; some compilers may
legitimately refuse to accept it.
</p></div>

</div>

<div id="outline-container-2-6" class="outline-3">
<h3 id="sec-2-6">Q2.21 Is there an automatic way to keep track of which field of a union is in use?</h3>
<div class="outline-text-3" id="text-2-6">

<p>No. You can implement an explicitly ``tagged'' union yourself:
</p>


<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">taggedunion</span> {
        <span style="color: #00ffff;">enum</span> {<span style="color: #eedd82;">UNKNOWN</span>, <span style="color: #eedd82;">INT</span>, <span style="color: #eedd82;">LONG</span>, <span style="color: #eedd82;">DOUBLE</span>, <span style="color: #eedd82;">POINTER</span>} <span style="color: #eedd82;">code</span>;
        <span style="color: #00ffff;">union</span> {
                <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
                <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">l</span>;
                <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">d</span>;
                <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">p</span>;
        } <span style="color: #eedd82;">u</span>;
};
</pre>

</div>

</div>

<div id="outline-container-2-7" class="outline-3">
<h3 id="sec-2-7">Q2.25 I came across some structure declarations with colons and numbers next to certain fields, like this:</h3>
<div class="outline-text-3" id="text-2-7">




<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">record</span> {
        <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>;
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">refcount</span> : 4;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">dirty</span> : 1;
};
</pre>

<p>
What gives?
</p>
<p>
 Those are bit-fields; the number gives the exact size of the field,
 in bits.
</p>
<ul>
<li id="sec-2-7-1">Example 1<br/>
Consider the example of reading the components of a floating-point number. A 4-byte floating-point number in the IEEE 754 standard consists of the following:

<p>
= The first bit is reserved for the sign bit — it is 1 if the number is negative and 0 if it is positive.
</p><ul>
<li>The next 8 bits are used to store the exponent in the unsigned form. When treated as a signed exponent, this exponent value ranges from -127 to +128. When treated as an unsigned value, its value ranges from 0 to 255.
</li>
<li>The remaining 23 bits are used to store the mantissa.
</li>
</ul>


<p>
Here is a program to print the value of a floating-point number into
its constituents:
</p>


<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">FP</span> {
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">the order of the members depends on the</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">endian scheme of the underlying machine</span>
      <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mantissa</span> : 23;
     <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">exponent</span> : 8;
      <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sign</span> : 1;
} *<span style="color: #eedd82;">fp</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
       <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">f</span> = -1.0f;
       fp = (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">FP</span> *)&amp;f;

printf(<span style="color: #ffc0cb; font-weight: bold;">"</span><span style="color: #ffa07a;"> sign = %s, biased exponent = %u,</span>
<span style="color: #ffa07a;">mantissa = %u "</span>, fp-&gt;sign ? <span style="color: #ffa07a;">"negative"</span> : <span style="color: #ffa07a;">"positive"</span>,
fp-&gt;exponent, fp-&gt;mantissa);
}
</pre>

<p>
For the floating-point number -1.0, this program prints:
</p>
<p>
<code>sign = negative, biased exponent = 127, mantissa = 0</code>
</p>
<p>
Since the sign of the floating-point number is negative, the value of
the sign bit is 1. Since the exponent is actual 0, in unsigned
exponent format, it is represented as 127, and hence that value is
printed. The mantissa in this case is 0, and hence it is printed as it
is.
</p>
<p>
To understand how floating-point arithmetic works, see this <a href="http://en.wikipedia.org/wiki/Single_precision">Wikipedia article</a>.
</p></li>
</ul>
<ul>
<li id="sec-2-7-2">Example 2<br/>



<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">bitfield</span> {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">bit</span> : 1;
} <span style="color: #eedd82;">BIT</span>;
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
   BIT.bit = 1;
   printf(<span style="color: #ffa07a;">" sizeof BIT is = %d\n"</span>, <span style="color: #00ffff;">sizeof</span>(BIT));
   printf(<span style="color: #ffa07a;">" value of bit is = %d "</span>, BIT.bit);

}
</pre>

<p>
It prints:
</p>


<pre class="src src-c"><span style="color: #00ffff;">sizeof</span> BIT is = 4
value of bit is = -1
</pre>

<p>
Note that we declared bit as int bit : 1; where the compiler treated the bit to be a signed integer of one bit size. Now, what is the range of a 1-bit signed integer?
</p>
<p>
It is from 0 to -1 (not 0 and 1, which is a common mistake). Remember
the formula for finding out the range of signed integers: 2<sup>(n-1)</sup> to
2<sup>(n-1)</sup>-1 where N is the number of bits. For example, if N is 8 (number
of bits in a byte), i.e., the range of a signed integer of size 8 is
-2(8-1) to 2(8-1)-1, which is -128 to +127. Now, when N is 1, i.e.,
the range of a signed integer of size 1, it is -2(1-1) to 2(1-1)-1,
which is -1 to 0!
</p>


</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">3. Expressions</h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1">Q</h3>
<div class="outline-text-3" id="text-3-1">


<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> <a href="http://en.wikibooks.org/wiki/C_Programming/C_Reference/inttypes.h#cite_note-2">http://en.wikibooks.org/wiki/C_Programming/C_Reference/inttypes.h#cite_note-2</a>
</p></div>
</div>
</div>

</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-08-12 12:34:52 HKT</p>
<p class="author">Author: Shi Shougang</p>
<p class="creator">Org version 7.8.09 with Emacs version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
