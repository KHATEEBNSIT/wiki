#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: Google C++ Style Guide Notes (Revision 3.274)
#+OPTIONS: num:nil H:2

* Homepage
+ en:http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml
+ zh:http://zh-google-styleguide.readthedocs.org/en/latest/ 

* Header Files
** The #define Guard
#+begin_html
<p class="info">
所有头文件都应该使用 #define 防止头文件被多重包含, 
命名格式当是: &ltPROJECT&gt_&ltPATH&gt_&ltFILE&gt_H_
</p>
#+end_html

For example, the file =foo/src/bar/baz.h= in project =foo= should have the
following guard:

#+begin_src c
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
#+end_src

** Forward Declarations
#+begin_html
<p class="info">
能用前置声明来避免不必要的#include.
</p>
#+end_html

A "forward declaration" is a declaration of a class, function, or
template without an associated definition.

用前置声明可以显著减少需要包含的头文件数量. 举例说明: 如果头文件中用到类 File, 但不需要访问 File 类的声明, 头文件中只需前置声明 class File; 而无须 #include "file/base/file.h".

不允许访问类的定义的前提下, 我们在一个头文件中能对类 Foo 做哪些操作?

+ 我们可以将数据成员类型声明为 Foo * 或 Foo &.
+ 我们可以将函数参数 / 返回值的类型声明为 Foo (但不能定义实现).
+ 我们可以将静态数据成员的类型声明为 Foo, 因为静态数据成员的定义在类定义之外.
反之, 如果你的类是 Foo 的子类, 或者含有类型为 Foo 的非静态数据成员, 则
必须包含 Foo 所在的头文件.

 *Decision:*
   + When using a *function* declared in a header file, always #include
     that header.
   + When using a class template, prefer to #include its header file.
   + When using an ordinary class, relying on a forward declaration is
     OK, but be wary of situations where a forward declaration may be
     insufficient or incorrect; when in doubt, just #include the
     appropriate header.
   + Do not replace data members with pointers just to avoid
     an #include.

当然 .cc 文件无论如何都需要所使用类的定义部分, 自然也就会包含若干头文件.

** Inline Functions
#+begin_html
<p class="info">
只有当函数只有 10 行甚至更少时才将其定义为内联函数.
</p>
#+end_html
 *Decision:*
一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数,
析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!

另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿
失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).

有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数
和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函
数.（递归调用堆栈的展开并不像循环那么简单, 比如递归层数在
编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主
要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述
其行为, 比如精短的存取函数.

** The -inl.h Files
#+begin_html
<p class="info">
复杂的内联函数的定义, 可放在后缀名为 -inl.h 的头文件中.
</p>
#+end_html

Another use of -inl.h files is for definitions of function templates.
This can be used to keep your template definitions easy to read.

Do not forget that a -inl.h file requires a #define guard just like
any other header file.

** Function Parameter Ordering
#+begin_html
<p class="info">
When defining a function, parameter order is: inputs, then outputs.
</p>
#+end_html

** Names and Order of Includes
#+begin_html
<p class="info">
使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: C 库, C++ 库, 其他库的 .h, 本项目内的 .h.
</p>
#+end_html

For example, =google-awesome-project/src/base/logging.h= should be
included as
#+begin_src c
#include "base/logging.h"
#+end_src

In =dir/foo.cc= or =dir/foo_test.cc=, whose main purpose is to implement
or test the stuff in dir2/foo2.h, order your includes as follows:
#+begin_src sh
dir2/foo2.h (preferred location — see details below).
C system files.
C++ system files.
Other libraries' .h files.
Your project's .h files.
#+end_src

With the preferred ordering, if dir2/foo2.h omits any necessary
includes, the build of dir/foo.cc or =dir/foo_test.cc= will break. Thus,
this rule ensures that build breaks show up first for the people
working on these files, not for innocent people in other packages.

Within each section the includes should be ordered alphabetically.
Note that older code might not conform to this rule and should be
fixed when convenient.

Exception: sometimes, system-specific code needs conditional includes.
Such code can put conditional includes after other includes. Example:
#+begin_src c
#include "foo/public/fooserver.h"

#include "base/port.h"  // For LANG_CXX11.

#ifdef LANG_CXX11
#include <initializer_list>
#endif  // LANG_CXX11
#+end_src

* Scoping
** Namespaces
#+begin_html
<p class="info">
鼓励在 .cc 文件内使用匿名名字空间. 使用具名的名字空间时, 
其名称可基于项目名或相对路径. 不要使用 using 关键字.
不要使用内嵌名字空间
</p>
#+end_html

 *Decision:*
Use namespaces according to the policy described below. Terminate
namespaces with comments as shown in the given examples.
*** Unnamed Namespaces
+ Unnamed namespaces are allowed and even encouraged in .cc files, to
  avoid runtime naming conflicts:
  
  #+begin_src c
    namespace {                           // This is in a .cc file.
    
    // The content of a namespace is not indented
    enum { kUnused, kEOF, kError };       // Commonly used tokens.
    bool AtEof() { return pos_ == kEOF; }  // Uses our namespace's EOF.
    
    }  // namespace
  #+end_src
  However, file-scope declarations that are associated with a
  particular class may be declared in that class as types, static data
  members or static member functions rather than as members of an
  unnamed namespace.

+ Do not use unnamed namespaces in .h files.
*** Named Namespaces
Named namespaces should be used as follows:
+ Namespaces wrap the entire source file after includes, gflags
  definitions/declarations, and forward declarations of classes from
  other namespaces:
  #+begin_src c
    // In the .h file
    namespace mynamespace {
    
    // All declarations are within the namespace scope.
    // Notice the lack of indentation.
    class MyClass {
     public:
      ...
      void Foo();
    };
    
    }  // namespace mynamespace
    // In the .cc file
    namespace mynamespace {
    
    // Definition of functions is within scope of the namespace.
    void MyClass::Foo() {
      ...
    }
    
    }  // namespace mynamespace
  #+end_src
  The typical .cc file might have more complex detail, including the
  need to reference classes in other namespaces.
  #+begin_src c
    #include "a.h"
    
    DEFINE_bool(someflag, false, "dummy flag");
    
    class C;  // Forward declaration of class C in the global namespace.
    namespace a { class A; }  // Forward declaration of a::A.
    
    namespace b {
    
    ...code for b...         // Code goes against the left margin.
    
    }  // namespace b
  #+end_src
+ Do not declare anything in namespace std, not even forward
  declarations of standard library classes.
+ You may not use a using-directive to make all names from a namespace
  available.
  #+begin_src c
    // Forbidden -- This pollutes the namespace.
    using namespace foo;
  #+end_src
+ You may use a using-declaration anywhere in a .cc file, and in
  functions, methods or classes in .h files.
  #+begin_src c
    // OK in .cc files.
    // Must be in a function, method or class in .h files.
    using ::foo::bar;
  #+end_src
+ Namespace aliases are allowed anywhere in a .cc file, anywhere
  inside the named namespace that wraps an entire .h file, and in
  functions and methods.
  #+begin_src c
    // Shorten access to some commonly used names in .cc files.
    namespace fbz = ::foo::bar::baz;
    
    // Shorten access to some commonly used names (in a .h file).
    namespace librarian {
    // The following alias is available to all files including
    // this header (in namespace librarian):
    // alias names should therefore be chosen consistently
    // within a project.
    namespace pd_s = ::pipeline_diagnostics::sidetable;
    
    inline void my_inline_function() {
      // namespace alias local to a function (or method).
      namespace fbz = ::foo::bar::baz;
      ...
    }
    }  // namespace librarian
  #+end_src
+ Do not use inline namespaces.
** Nested Classes
#+begin_html
<p class="info">
当公有嵌套类作为接口的一部分时, 
虽然可以直接将他们保持在全局作用域中, 但将嵌套类的声明置于名字空间内是更好的选择.
</p>
#+end_html
Do not make nested classes public unless they are actually part of the
interface, e.g., a class that holds a set of options for some method.
** Nonmember, Static Member, and Global Functions
#+begin_html
<p class="info">
使用静态成员函数或名字空间内的非成员函数, 尽量不要用裸的全局函数.
</p>
#+end_html

Sometimes it is useful, or even necessary, to define a function not
bound to a class instance. Such a function can be either a static
member or a nonmember function. Nonmember functions should not depend
on external variables, and should nearly always exist in a namespace.
Rather than creating classes only to group static member functions
which do not share static data, use namespaces instead.

Functions defined in the same compilation unit as production classes
may introduce unnecessary coupling and link-time dependencies when
directly called from other compilation units; static member functions
are particularly susceptible to this. Consider extracting a new class,
or placing the functions in a namespace possibly in a separate
library.

If you must define a nonmember function and it is only needed in its
.cc file, use an unnamed namespace or static linkage (eg static int
Foo() {...}) to limit its scope.
** Local Variables
#+begin_html
<p class="info">
将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.
</p>
#+end_html

There is one caveat: if the variable is an object, its constructor is
invoked every time it enters scope and is created, and its destructor
is invoked every time it goes out of scope.

#+begin_src c
// Inefficient implementation:
for (int i = 0; i < 1000000; ++i) {
  Foo f;  // My ctor and dtor get called 1000000 times each.
  f.DoSomething(i);
}
#+end_src
It may be more efficient to declare such a variable used in a loop
outside that loop:

#+begin_src c
Foo f;  // My ctor and dtor get called once each.
for (int i = 0; i < 1000000; ++i) {
  f.DoSomething(i);
}
#+end_src
** Static and Global Variables
#+begin_html
<p class="info">
禁止使用 class 类型的静态或全局变量: 它们会导致很难发现的 
bug 和不确定的构造和析构函数调用顺序.但是，允许这些变量，
当他们是没有动态初始和析构的constexpr:时。
</p>
#+end_html

Objects with static storage duration, including global variables,
static variables, static class member variables, and function static
variables, must be Plain Old Data (POD): only ints, chars, floats, or
pointers, or arrays/structs of POD.

The order in which class constructors and initializers for static
variables are called is only partially specified in C++ and can even
change from build to build, which can cause bugs that are difficult to
find. Therefore in addition to banning globals of class type, we do
not allow static POD variables to be initialized with the result of a
function, unless that function (such as getenv(), or getpid()) does
not itself depend on any other globals.

One way to alleviate the destructor problem is to terminate the
program by calling =quick_exit()= instead of =exit()=. The difference is
that =quick_exit()= does not invoke destructors and does not invoke any
handlers that were registered by calling =atexit()=. If you have a
handler that needs to run when a program terminates via =quick_exit()=
(flushing logs, for example), you can register it using
=at_quick_exit()=. (If you have a handler that needs to run at both
=exit()= and =quick_exit()=, you need to register it in both places.)、

If you need a static or global variable of a class type, consider
initializing a pointer (which will never be freed), from either your
main() function or from pthread_once(). Note that this must be a raw
pointer, not a "smart" pointer, since the smart pointer's destructor
will have the order-of-destructor issue that we are trying to avoid.

* Classes
** Doing Work in Constructors
#+begin_html
<p class="info">
在构造函数中避免做复杂的初始化（特别，能失败或需要调用虚函数）
</p>
#+end_html

 *Decision:*
Constructors should never call virtual functions or attempt to raise
non-fatal failures. If your object requires non-trivial
initialization, consider using a factory function or Init() method.

** Initialization
#+begin_html
<p class="info">
如果类定义了成员变量，必须在类中定义一个初始化所有成员变量的初始化函数
或构造函数（可以是默认构造函数）。如果没有定义任何默认构造函数. 编译器
将自动生产一个默认的构造函数，使得一些没被初始化或初始化位不合理的值。
</p>
#+end_html
 *Decision:*
Use in-class member initialization for simple initializations,
especially when a member variable must be initialized the same way in
more than one constructor.

If your class defines member variables that aren't initialized
in-class, and if it has no other constructors, you must define a
default constructor (one that takes no arguments).

If your class inherits from an existing class but you add no new
member variables, you are not required to have a default constructor.

** Explicit Constructors
#+begin_html
<p class="info">
对单个参数的构造函数使用 C++ 关键字 explicit.
</p>
#+end_html
 *Decision:*
We require all single argument constructors to be explicit. Always put
explicit in front of one-argument constructors in the class
definition: explicit Foo(string name); 

The exception is copy constructors, which, in the rare cases when we
allow them, should probably not be explicit. Classes that are intended
to be transparent wrappers around other classes are also exceptions.
Such exceptions should be clearly marked with comments. 

Finally, constructors that take only an initializer_list may be
non-explicit. This is to permit construction of your type using the
assigment form for brace init lists (i.e. MyType m = {1, 2} ).

** Copy Constructors
#+begin_html
<p class="info">
仅在代码中需要拷贝一个类对象的时候使用拷贝构造函数; 
大部分情况下都不需要, 此时应使用 DISALLOW_COPY_AND_ASSIGN.
</p>
#+end_html

 *Decision:*
Few classes need to be copyable. Most should have neither a copy
constructor nor an assignment operator. In many situations, a pointer
or reference will work just as well as a copied value, with better
performance. For example, you can pass function parameters by
reference or pointer instead of by value, and you can store pointers
rather than objects in an STL container. 

If your class needs to be copyable, prefer providing a copy method,
such as CopyFrom() or Clone(), rather than a copy constructor, because
such methods cannot be invoked implicitly. If a copy method is
insufficient in your situation (e.g. for performance reasons, or
because your class needs to be stored by value in an STL container),
provide both a copy constructor and assignment operator. 

If your class does not need a copy constructor or assignment operator,
you must explicitly disable them. To do so, add dummy declarations for
the copy constructor and assignment operator in the private: section
of your class, but do not provide any corresponding definition (so
that any attempt to use them results in a link error). 

For convenience, a =DISALLOW_COPY_AND_ASSIGN= macro can be used:
#+begin_src c
// A macro to disallow the copy constructor and operator= functions
// This should be used in the private: declarations for a class
#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
  TypeName(const TypeName&);               \
  void operator=(const TypeName&)
#+end_src
Then, in =class Foo=:
#+begin_src c
class Foo {
 public:
  Foo(int f);
  ~Foo();

 private:
  DISALLOW_COPY_AND_ASSIGN(Foo);
};
#+end_src

** Delegating and inheriting constructors
#+begin_html
<p class="info">
使用委托和继承构造函数，当他们减少重复代码。
</p>
#+end_html

*Decision:*
Use delegating and inheriting constructors when they reduce
boilerplate and improve readability. Be cautious about inheriting
constructors when your derived class has new member variables.
Inheriting constructors may still be appropriate in that case if you
can use in-class member initialization for the derived class's member
variables. 

** Structs vs. Classes
#+begin_html
<p class="info">
仅当只有数据时使用 struct, 其它一概使用 class.
</p>
#+end_html
structs should be used for passive objects that carry data, and may
have associated constants, but lack any functionality other than
access/setting the data members. The accessing/setting of fields is
done by directly accessing the fields rather than through method
invocations. Methods should not provide behavior but should only be
used to set up the data members, e.g., constructor, destructor,
Initialize(), Reset(), Validate(). 

If more functionality is required, a class is more appropriate. If in
doubt, make it a class.

For consistency with STL, you can use struct instead of class for
functors(仿函数) and traits(特性). 

Note that member variables in structs and classes have *different
naming rules*.

** Inheritance
#+begin_html
<p class="info">
使用组合常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承.
</p>
#+end_html
 *定义:*
当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继
承主要用于两种场合: 实现继承 (implementation inheritance), 子类继承父
类的实现代码; 接口继承 (interface inheritance), 子类仅继承父类的方法名
称. 

 *Decision:*
All inheritance should be public. If you want to do private
inheritance, you should be including an instance of the base class as
a member instead. 

Do not overuse implementation inheritance. Composition is often more
appropriate. Try to restrict use of inheritance to the "is-a" case:
Bar subclasses Foo if it can reasonably be said that Bar "is a kind
of" Foo. 

Make your destructor virtual if necessary. If your class has virtual
methods, its destructor should be virtual. 

Limit the use of protected to those member functions that might need
to be accessed from subclasses. Note that *data members should be
private*. 

When redefining an inherited virtual function, explicitly declare it
virtual in the declaration of the derived class. Rationale: If virtual
is omitted, the reader has to check all ancestors of the class in
question to determine if the function is virtual or not.

** Multiple Inheritance
#+begin_html
<p class="info">
真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 
最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.
</p>
#+end_html
 *Decision:*
Multiple inheritance is allowed only when all superclasses, with the
possible exception of the first one, are pure interfaces. In order to
ensure that they remain pure interfaces, they must end with the
Interface suffix. 

Note: There is an exception to this rule on Windows.

** Interfaces
#+begin_html
<p class="info">
接口是指满足特定条件的类, 这些类以 Interface 为后缀,不强制.
</p>
#+end_html

 *定义:*
当一个类满足以下要求时, 称之为纯接口:

+ 只有纯虚函数 (“=0”) 和静态函数 (除了下文提到的析构函数).
+ 没有非静态数据成员.
+ 没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 protected.
+ 如果它是一个子类, 也只能从满足上述条件并以 Interface 为后缀的类继承.

 *Decision:*
A class may end with Interface only if it meets the above
requirements. however: classes that meet the above requirements are
not required to end with Interface.  

** Operator Overloading
#+begin_html
<p class="info">
除少数特定环境外，不要重载运算符. 不要自己定义字义。
</p>
#+end_html

 *Decision:*
In general, do not overload operators. The assignment operator
(operator=), in particular, is insidious and should be avoided. You
can define functions like Equals() and CopyFrom() if you need them.
Likewise, avoid the dangerous unary operator& at all costs, if there's
any possibility the class might be forward-declared. 

Do not overload operator"", i.e. do not introduce user-defined
literals. 

However, there may be rare cases where you need to overload an
operator to interoperate with templates or "standard" C++ classes
(such as operator<<(ostream&, const T&) for logging). These are
acceptable if fully justified, but you should try to avoid these
whenever possible. In particular, do not overload operator== or
operator< just so that your class can be used as a key in an STL
container; instead, you should create equality and comparison functor
types when declaring the container. 

Some of the STL algorithms do require you to overload operator==, and
you may do so in these cases, provided you document why.

** Access Control
#+begin_html
<p class="info">
将所有数据成员声明为 private, 并根据需要提供相应的存取函数(一些技术原
因，允许测试类的数据成员位protected，当使用Google Test). 例如, 某个名
为 foo_ 的变量, 其取值函数是 foo(). 还可能需要一个赋值函数set_foo().
例外：static const的数据成员（通常称为kFoo)不需要private.
</p>
#+end_html

The definitions of accessors are usually inlined in the header file.

** Declaration Order
#+begin_html
<p class="info">
在类中使用特定的声明顺序: public: 在 private: 之前, 成员函数在数据成员 (变量) 前;
</p>
#+end_html
Your class definition should start with its public: section, followed
by its protected: section and then its private: section. If any of
these sections are empty, omit them. 

Within each section, the declarations generally should be in the
following order: 

+ Typedefs and Enums
+ Constants (static const data members)
+ Constructors
+ Destructor
+ Methods, including static methods
+ Data Members (except static const data members)

Friend declarations should always be in the private section, and the
=DISALLOW_COPY_AND_ASSIGN= macro invocation should be at the end of the
private: section. It should be the last thing in the class.

Method definitions in the corresponding .cc file should be the same as
the declaration order, as much as possible. 

Do not put large method definitions inline in the class definition.
Usually, only trivial or performance-critical, and very short, methods
may be defined inline. 

** Write Short Functions
#+begin_html
<p class="info">
倾向编写简短, 凝练的函数.
</p>
#+end_html
 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.

* Google-Specific Magic
** Ownership and Smart Pointers
#+begin_html
<p class="info">
对动态分配的对象只有一个固定的隶属折。传递隶属使用智能指针。
</p>
#+end_html

*** Definition:
"Ownership" is a bookkeeping technique for managing dynamically
allocated memory (and other resources). The owner of a dynamically
allocated object is an object or function that is responsible for
ensuring that it is deleted when no longer needed. Ownership can
sometimes be shared, in which case the last owner is typically
responsible for deleting it. Even when ownership is not shared, it can
be transferred from one piece of code to another. 

"Smart" pointers are classes that act like pointers, e.g. by
overloading the * and -> operators. Some smart pointer types can be
used to automate ownership bookkeeping, to ensure these
responsibilities are met. =std::unique_ptr= is a smart pointer type
introduced in C++11, which expresses exclusive ownership of a
dynamically allocated object; the object is deleted when the
=std::unique_ptr= goes out of scope. It cannot be copied, but can be
moved to represent ownership transfer. =shared_ptr= is a smart pointer
type which expresses shared ownership of a dynamically allocated
object. =shared_ptrs= can be copied; ownership of the object is shared
among all copies, and the object is deleted when the last =shared_ptr=
is destroyed.

*** Cons:
+ Ownership must be represented and transferred via pointers (whether
  smart or plain). Pointer semantics are more complicated than value
  semantics, especially in APIs: you have to worry not just about
  ownership, but also aliasing, lifetime, and mutability, among other
  issues. 
+ The performance costs of value semantics are often overestimated, so
  the performance benefits of ownership transfer might not justify the
  readability and complexity costs. 
+ APIs that transfer ownership force their clients into a single
  memory management model.
+ Code using smart pointers is less explicit about where the resource
  releases take place. 
+ std::unique_ptr expresses ownership transfer using C++11's move
  semantics, which are generally forbidden in Google code, and may
  confuse some programmers. 
+ Shared ownership can be a tempting alternative to careful ownership
  design, obfuscating the design of a system. 
+ Shared ownership requires explicit bookkeeping at run-time, which
  can be costly. 
+ In some cases (e.g. cyclic references), objects with shared
  ownership may never be deleted. 
+ Smart pointers are not perfect substitutes for plain pointers.
*** Decision:
If dynamic allocation is necessary, prefer to keep ownership with the
code that allocated it. If other code needs access to the object,
consider passing it a copy, or passing a pointer or reference without
transferring ownership. Prefer to use =std::unique_ptr= to make
ownership transfer explicit. For example: 
#+begin_src c
std::unique_ptr<Foo> FooFactory();
void FooConsumer(std::unique_ptr<Foo> ptr);
#+end_src
Do not design your code to use shared ownership without a very good
reason. One such reason is to avoid expensive copy operations, but you
should only do this if the performance benefits are significant, and
the underlying object is immutable (i.e. =shared_ptr<const Foo>=). If
you do use shared ownership, prefer to use =shared_ptr=. 

Do not use =scoped_ptr= in new code unless you need to be compatible
with older versions of C++. Never use =linked_ptr= or =std::auto_ptr=. In
all three cases, use =std::unique_ptr= instead.

** cpplint
#+begin_html
<p class="info">
使用 cpplint.py 检查风格错误.
</p>
#+end_html

False positives can be ignored by putting // NOLINT at the end of the line.

download [[http://google-styleguide.googlecode.com/svn/trunk/cpplint/cpplint.py][cpplint.py]] separately.

* Other C++ Features
** Reference Arguments
#+begin_html
<p class="info">
所有按引用传递的参数必须加上 const.
</p>
#+end_html

 *Decision:*
Within function parameter lists all references must be const:
#+begin_src c
void Foo(const string &in, string *out);
#+end_src
In fact it is a very strong convention in Google code that input
arguments are values or const references while output arguments are
pointers. Input parameters may be const pointers, but we never allow
non-const reference parameters except when required by convention,
e.g., =swap()=. 

However, there are some instances where using =const T*= is preferable
to =const T&= for input parameters. For example: 

+ You want to pass in a null pointer.
+ The function saves a pointer or reference to the input. 

So if you choose =const T*= rather than =const T&=, do so for a concrete
reason; otherwise it will likely confuse readers by making them look
for an explanation that doesn't exist.
** Rvalue references
#+begin_html
<p class="info">
Do not use rvalue references, std::forward, std::move_iterator, or
std::move_if_noexcept. Use the single-argument form of std::move only
with non-copyable arguments. 
</p>
#+end_html
*Decision:*
Do not use rvalue references, and do not use the =std::forward= or
=std::move_if_noexcept= utility functions (which are essentially just
casts to rvalue reference types), or =std::move_iterator=. Use
single-argument =std::move= only with objects that are not copyable
(e.g. =std::unique_ptr=), or in templated code with objects that might
not be copyable.
** Function Overloading
#+begin_html
<p class="info">
仅在读者看到调用能很好的知道发生了啥而不是首先去搞清楚哪个重载被调用时
使用重载函数 (含构造函数). 
</p>
#+end_html

*Decision:*
If you want to overload a function, consider qualifying the name with
some information about the arguments, e.g., AppendString(),
AppendInt() rather than just Append().
** Default Arguments
#+begin_html
<p class="info">
我们不允许使用缺省函数参数，除了以下说明的有限场合。如果合适，用函数重
载来模仿它们。
</p>
#+end_html

*Decision:*
So except as described below, we require all arguments to be
explicitly specified. 

One specific exception is when the function is a static function (or
in an unnamed namespace) in a .cc file. In this case, the cons don't
apply since the function's use is so localized. 

Another specific exception is when default arguments are used to
simulate variable-length argument lists. 
#+begin_src c
// Support up to 4 params by using a default empty AlphaNum.
string StrCat(const AlphaNum &a,
              const AlphaNum &b = gEmptyAlphaNum,
              const AlphaNum &c = gEmptyAlphaNum,
              const AlphaNum &d = gEmptyAlphaNum);
#+end_src
** Variable-Length Arrays and alloca()
#+begin_html
<p class="info">
我们不允许使用变长数组和 alloca().
</p>
#+end_html

*Decision:*
Use a safe allocator instead, such as =scoped_ptr/scoped_array=.
** Friends
#+begin_html
<p class="info">
我们允许合理的使用友元类及友元函数.
</p>
#+end_html

Friends should usually be defined in the same file so that the reader
does not have to look in another file to find uses of the private
members of a class. A common use of friend is to have a FooBuilder
class be a friend of Foo so that it can construct the inner state of
Foo correctly, without exposing this state to the world. In some cases
it may be useful to make a unittest class a friend of the class it
tests.
** Exceptions
#+begin_html
<p class="info">
我们不使用 C++ 异常.
</p>
#+end_html

On their face, the benefits of using exceptions outweigh the costs,
especially in new projects. However, for existing code, the
introduction of exceptions has implications on all dependent code. If
exceptions can be propagated beyond a new project, it also becomes
problematic to integrate the new project into existing exception-free
code. Because most existing C++ code at Google is not prepared to deal
with exceptions, it is comparatively difficult to adopt new code that
generates exceptions.

Given that Google's existing code is not exception-tolerant, the costs
of using exceptions are somewhat greater than the costs in a new
project. 

This prohibition also applies to the exception-related features added
in C++11, such as =noexcept=, =std::exception_ptr=, and
=std::nested_exception=. 

There is an exception to this rule (no pun intended) for Windows code.
** Run-Time Type Information (RTTI)
#+begin_html
<p class="info">
禁止使用 RTTI.
</p>
#+end_html
RTTI allows a programmer to query the C++ class of an object at run
time. This is done by use of =typeid= or =dynamic_cast=. 

*Decision:*
RTTI has legitimate uses but is prone to abuse, so you must be careful
when using it. You may use it freely in unittests, but avoid it when
possible in other code. In particular, think twice before using RTTI
in new code. If you find yourself needing to write code that behaves
differently based on the class of an object, consider one of the
following alternatives to querying the type: 

+ Virtual methods are the preferred way of executing different code
  paths depending on a specific subclass type. This puts the work
  within the object itself. 
+ If the work belongs outside the object and instead in some
  processing code, consider a double-dispatch solution, such as the
  Visitor design pattern. This allows a facility outside the object
  itself to determine the type of class using the built-in type
  system.

When the logic of a program guarantees that a given instance of a base
class is in fact an instance of a particular derived class, then a
=dynamic_cast= may be used freely on the object. Usually one can use a
=static_cast= as an alternative in such situations. 

Do not hand-implement an RTTI-like workaround. The arguments against
RTTI apply just as much to workarounds like class hierarchies with
type tags. Moreover, workarounds disguise your true intent.
** Casting
#+begin_html
<p class="info">
使用 C++ 的类型转换, 如 static_cast<>(). 不要使用 int y = (int)x 或
int y = int(x) 等转换方式; 
</p>
#+end_html

*Decision:*
Do not use C-style casts. Instead, use these C++-style casts.

+ Use =static_cast= as the equivalent of a C-style cast that does value
  conversion, or when you need to explicitly up-cast a pointer from a
  class to its superclass. 
+ Use =const_cast= to remove the const qualifier (see const).
+ Use =reinterpret_cast= to do unsafe conversions of pointer types to
  and from integer and other pointer types. Use this only if you know
  what you are doing and you understand the aliasing issues. 
+ You may use =dynamic_cast= freely in unittests, but avoid it when
  possible in other code.
** Streams
#+begin_html
<p class="info">
只在记录日志时使用流
</p>
#+end_html

*Decision:*
Do not use streams, except where required by a logging interface. Use
printf-like routines instead. 

Either path would yield different advantages and disadvantages, and
there is not a clearly superior solution. The simplicity doctrine
mandates we settle on one of them though, and the majority decision
was on =printf + read/write=.
** Preincrement and Predecrement
#+begin_html
<p class="info">
对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符.
</p>
#+end_html

*Decision:*
For simple scalar (non-object) values there is no reason to prefer one
form and we allow either. For iterators and other template types, use
pre-increment.
** Use of const
#+begin_html
<p class="info">
我们强烈建议你在任何可能的情况下都要使用 const. 对于C++11中一些const，
constexpr 是更好的选择。
</p>
#+end_html

=const= variables, data members, methods and arguments add a level of
compile-time type checking; it is better to detect errors as soon as
possible. Therefore we strongly recommend that you use const whenever
it makes sense to do so: 

+ If a function does not modify an argument passed by reference or by
  pointer, that argument should be const. 
+ Declare methods to be const whenever possible. Accessors should
  almost always be const. Other methods should be const if they do not
  modify any data members, do not call any non-const methods, and do
  not return a non-const pointer or non-const reference to a data
  member. 
+ Consider making data members const whenever they do not need to be
  modified after construction. 

The =mutable= keyword is allowed but is unsafe when used with threads,
so thread safety should be carefully considered first. 

That said, while we encourage putting =const= first, we do not require
it. But be consistent with the code around you!
** Use of constexpr
#+begin_html
<p class="info">
In C++11, use constexpr to define true constants or to ensure constant
initialization. 
</p>
#+end_html

*Decision:*
=constexpr= definitions enable a more robust specification of the
constant parts of an interface. Use =constexpr= to specify true
constants and the functions that support their definitions. Avoid
complexifying function definitions to enable their use with =constexpr=.
Do not use constexpr to force inlining.
** Integer Types
Of the built-in C++ integer types, the only one used is int. If a
program needs a variable of a different size, use a precise-width
integer type from =<stdint.h>=, such as =int16_t=. If your variable
represents a value that could ever be greater than or equal to 2^31
(2GiB), use a 64-bit type such as =int64_t=. Keep in mind that even if
your value won't ever be too large for an int, it may be used in
intermediate calculations which may require a larger type. When in
doubt, choose a larger type.

*Decision:*
=<stdint.h>= defines types like =int16_t=, =uint32_t=, =int64_t=, etc. You
should always use those in preference to short, unsigned long long and
the like, when you need a guarantee on the size of an integer. Of the
C integer types, only int should be used. When appropriate, you are
welcome to use standard types like =size_t= and =ptrdiff_t=. 

For integers we know can be "big", use =int64_t=.

You should not use the unsigned integer types such as uint32_t, unless
there is a valid reason such as representing a bit pattern rather than
a number, or you need defined overflow modulo 2^N. In particular, do
not use unsigned types to say a number will never be negative.
Instead, use *assertions* for this. 

Use care when converting integer types. Integer conversions and
promotions can cause non-intuitive behavior.

So, document that a variable is non-negative using assertions. Don't
use an unsigned type. 

** 64-bit Portability
#+begin_html
<p class="info">
代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记:
</p>
#+end_html

+ printf() specifiers for some types are not cleanly portable between
  32-bit and 64-bit systems. C99 defines some portable format
  specifiers. Unfortunately, MSVC 7.1 does not understand some of
  these specifiers and the standard is missing a few, so we have to
  define our own ugly versions in some cases (in the style of the
  standard include file inttypes.h): 
  #+begin_src c
    // printf macros for size_t, in the style of inttypes.h
    #ifdef _LP64
    #define __PRIS_PREFIX "z"
    #else
    #define __PRIS_PREFIX
    #endif
    
    // Use these macros after a % in a printf format string
    // to get correct 32/64 bit behavior, like this:
    // size_t size = records.size();
    // printf("%"PRIuS"\n", size);
    
    #define PRIdS __PRIS_PREFIX "d"
    #define PRIxS __PRIS_PREFIX "x"
    #define PRIuS __PRIS_PREFIX "u"
    #define PRIXS __PRIS_PREFIX "X"
    #define PRIoS __PRIS_PREFIX "o"
  #+end_src
| Type                     | DO NOT use    | DO use              | Notes              |
|--------------------------+---------------+---------------------+--------------------|
| =void *=(or any pointer) | %lx           | %p                  |                    |
| =int64_t=                | %qd,%lld      | %"PRId64"           |                    |
| =uint64_t=               | %qu,%llu,%llx | %"PRIu64",%"PRIx64" |                    |
| =size_t=                 | %u            | %"PRIuS",%"PRIxS"   | C99 sepecifies %zu |
| =ptrdiff_t=              | %d            | %"PRIdS"            | C99 sepecifies %td |
Note that the PRI* macros expand to independent strings which are
concatenated by the compiler. Hence if you are using a non-constant
format string, you need to insert the value of the macro into the
format, rather than the name. It is still possible, as usual, to
include length specifiers, etc., after the % when using the PRI*
macros. So, e.g. =printf("x = %30"PRIuS"\n", x)= would expand on 32-bit
Linux to =printf("x = %30" "u" "\n", x)=, which the compiler will treat
as =printf("x = %30u\n", x)=. 

+ Remember that ~sizeof(void *) != sizeof(int)~. Use =intptr_t= if you
  want a pointer-sized integer. 
+ You may need to be careful with structure alignments, particularly
  for structures being stored on disk. Any class/structure with a
  int64_t/uint64_t member will by default end up being 8-byte aligned
  on a 64-bit system. If you have such structures being shared on disk
  between 32-bit and 64-bit code, you will need to ensure that they
  are packed the same on both architectures. Most compilers offer a
  way to alter structure alignment. For gcc, you can use
  =__attribute__((packed))=. MSVC offers =#pragma pack()= and
  =__declspec(align())=. 
+ Use the LL or ULL suffixes as needed to create 64-bit constants. For
  example:
  #+begin_src c
    int64_t my_value = 0x123456789LL;
    uint64_t my_mask = 3ULL << 48;
  #+end_src
+ If you really need different code on 32-bit and 64-bit systems,
  use #ifdef _LP64 to choose between the code variants. (But please
  avoid this if possible, and keep any such changes localized.)
** Preprocessor Macros
#+begin_html
<p class="info">
使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之. 
</p>
#+end_html

Instead of using a macro to inline performance-critical code, use an
inline function. Instead of using a macro to store a constant, use a
const variable. Instead of using a macro to "abbreviate" a long
variable name, use a reference. Instead of using a macro to
conditionally compile code ... well, don't do that at all (except, of
course, for the #define guards to prevent double inclusion of header
files). It makes testing much more difficult.

Macros can do things these other techniques cannot, and you do see
them in the codebase, especially in the lower-level libraries. And
some of their special features (like stringifying(#), concatenation(##), and
so forth) are not available through the language proper. But before
using a macro, consider carefully whether there's a non-macro way to
achieve the same result. 

The following usage pattern will avoid many problems with macros; if
you use macros, follow it whenever possible: 

+ Don't define macros in a .h file.
+ #define macros right before you use them, and #undef them right after.
+ Do not just #undef an existing macro before replacing it with your
  own; instead, pick a name that's likely to be unique. 
+ Try not to use macros that expand to unbalanced C++ constructs, or
  at least document that behavior well. 
+ Prefer not using ## to generate function/class/variable names.
** 0 and nullptr/NULL
#+begin_html
<p class="info">
整数用 0, 实数用 0.0, 指针用 nullptr(或NULL), 字符 (串) 用 '\0'.
</p>
#+end_html
For pointers (address values), there is a choice between 0, NULL, and
nullptr. For projects that allow C++11 features, use nullptr.  

In fact, some C++ compilers provide special definitions of NULL which
enable them to give useful warnings, particularly in situations where
sizeof(NULL) is not equal to sizeof(0).
** sizeof
#+begin_html
<p class="info">
尽可能用 sizeof(varname) 代替 sizeof(type).
</p>
#+end_html
Use sizeof(varname) when you take the size of a particular variable.
sizeof(varname) will update appropriately if someone changes the
variable type either now or later. You may use sizeof(type) for code
unrelated to any particular variable, such as code that manages an
external or internal data format where a variable of an appropriate
C++ type is not convenient. 
#+begin_src c
Struct data;
memset(&data, 0, sizeof(data));

memset(&data, 0, sizeof(Struct));

if (raw_size < sizeof(int)) {
  LOG(ERROR) << "compressed record not big enough for count: " << raw_size;
  return false;
}
</p>
#+end_src
** auto
#+begin_html
<p class="info">
仅使用auto来避免杂乱的类型名。继续使用明示的类型声明当有助于读取，仅对本地变量使用auto。
</p>
#+end_html

*Decision:*
auto is permitted, for local variables only. . Never assign a braced
initializer list to an auto-typed variable.

The auto keyword is also used in an unrelated C++11 feature: it's part
of the syntax for a new kind of function declaration with a trailing
return type. Function declarations with trailing return types are not
permitted.
** Brace Initialization
#+begin_html
<p class="info">
可用 brace initialization.
</p>
#+end_html

Never assign a braced-init-list to an auto local variable. In the
single element case, what this means can be confusing. 
#+begin_src c
auto d = {1.23};        // d is an initializer_list<double>
auto d = double{1.23};  // Good -- d is a double, not an initializer_list.
#+end_src
** Lambda expressions
#+begin_html
<p class="info">
不要使用lamba表达式，或相关的 std::function和std::bind程序。
</p>
#+end_html



** Boost
#+begin_html
<p class="info">
只使用 Boost 中被认可的库.
</p>
#+end_html

*Decision:*
+ =Call Traits= from =boost/call_traits.hpp=
+ =Compressed Pair= from =boost/compressed_pair.hpp=
+ =The Boost Graph Library (BGL)= from boost/graph, except serialization
  (=adj_list_serialize.hpp=) and parallel/distributed algorithms and
  data structures (=boost/graph/parallel/*= and
  =boost/graph/distributed/*=). 
+ =Property Map= from =boost/property_map=, except
  parallel/distributed property maps (=boost/property_map/parallel/*=). 
+ The part of =Iterator= that deals with defining iterators:
  =boost/iterator/iterator_adaptor.hpp=,
  =boost/iterator/iterator_facade.hpp=, and
  =boost/function_output_iterator.hpp=
+ The part of =Polygon= that deals with Voronoi diagram construction and
  doesn't depend on the rest of Polygon:
  =boost/polygon/voronoi_builder.hpp=,
  =boost/polygon/voronoi_diagram.hpp=, and
  =boost/polygon/voronoi_geometry_type.hpp=
+ =Bimap= from =boost/bimap=
+ =Statistical Distributions and Functions= from
  =boost/math/distributions=

The following libraries are permitted, but their use is discouraged
because they've been superseded by standard libraries in C++11: 

+ =Array= from =boost/array.hpp=: use =std::array instead=.
+ =Pointer Container= from =boost/ptr_container=: use containers of
  =std::unique_ptr= instead. 

* cc

#+begin_html
<p class="info">

</p>
#+end_html


#+begin_src c

#+end_src
