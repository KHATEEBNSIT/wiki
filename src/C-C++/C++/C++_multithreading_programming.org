#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: 浅谈C++ multithreading programming
#+OPTIONS: num:nil H:2

* Overview
随着多核CPU随处可见,多线程(multithreading)可以被用来实现并行,提高CPU的
利用率和性能显著的提高.掌握多线程编程也成为现代实现软件的基本要求技能
之一.[[https://computing.llnl.gov/tutorials/parallel_comp/][Introduction to Parallel Computing]]详细的介绍了 Parallel Computing;
为什么使用它;Parallel Computing的分类;Parallel Computing的limits和
costs; Parallel Computing的程序模型;如何设计Parallel程序等.

这里先介绍多线程的概念,多线程中涉及的基本概念,然后用实例介绍Pthread库
的使用,并介绍Google Code中如何把它封装成C++类,最后介绍可移植并大量使用的
[[http://www.boost.org/doc/libs/1_55_0/doc/html/thread.html][Boost Thread库]].

还有一些其他的Thread库:
+ [[http://openmp.org/wp/][OpenMP]] 是一个可移植的接口,在共享内存的多处理器上实现fork-join并行.
  OpenMP的tutorial:[[https://computing.llnl.gov/tutorials/openMP/][这里]] 和 [[http://vergil.chemistry.gatech.edu/resources/programming/OpenMP.pdf][这里]],
+ [[http://omniorb.sourceforge.net/omni42/omnithread.html][OMNI Thread]]为C++提供Thread操作的.
+ [[http://en.wikipedia.org/wiki/List_of_C%2B%2B_multi-threading_libraries][其他multithreading libraries]].

* Thread
** 定义
A *thread* is defined as an independent stream of instructions that can
be scheduled to run as such by the operating system.所以它是在程序中独
立于其他代码可由操作系统调度的一段指令.

那么是操作系统是如何具体实现这一独立性呢?

要理解thread,必须先明白process.进程由操作系统创建来运行相应的程序,进程
包含程序资源和程序执行状态的信息.以Linux的进程为例包含:
+ Process ID, process group ID, user ID, and group ID
+ Environment
+ Working directory
+ Program instructions
+ Registers
+ Stack
+ Heap
+ File descriptors
+ Signal actions
+ Shared libraries
+ Inter-process communication tools (such as message queues, pipes,
  semaphores, or shared memory).

Thread使用Process的资源,并且能成为独立的元件被操作系统调度,是因为它仅
重复那些使得它们能成为独立运行代码的必要资源.Thread维护它自己如下的信
息:
+ Stack pointer
+ Registers
+ Scheduling properties (such as policy or priority)
+ Set of pending and blocked signals
+ Thread specific data.

与Process比较,Thread可以总结如下:
+ Thread相当于一个lightweight的Process,拥有如ID,properties等相似信息,
  但仅仅包含能使得它独立运行的信息即可.
+ 信息包含的不同,与需要复制大量信息来创建Process比,Thread的创建比较快
  捷.
+ 独立的Processes不共享任何信息.每个Process运行在独立的地址空间.Threads共
  享所在Process的资源,全局变量和文件描述符.
+ Threads可以直接与所在同一Process的Threads通信.而Processes必须使用
  inter-process communication(IPC)来通信.
+ 因为Threads的资源共享性,增加并行操作资源的难度,需要引入Thread同步机
  制来达到资源并行性.

** 一些术语
Posix Thread基本模型如下图,一些有关其中Thread的术语:

[[./Files/threads_model.png]]

+ *Lightweight Process(LWP)* 可以被认为虚拟的CPU,在系统中通常LWP的个
  数大于实际CPU个数.Thread库通过与LWP沟通来调度thread.LWP也通常被称为
  kernel threads.
+ *[[http://en.wikipedia.org/wiki/System_Contention_Scope][Contention Scope]]* 是如何决定哪个线程得到调度.
+ *Bound threads* 拥有系统级别的Contention Scope,也就是,它们与其他进程
  一同竞争.
+ *Unbound threads* 拥有进程级别的Contention Scope.
+ *Thread-safe* 意味共享数据被得到保护,可以同时被多个thread调用而安全.
+ *Reentrant code* 意味程序可以被多个thread并行运行.
+ *[[https://www.securecoding.cert.org/confluence/display/seccode/BB.+Definitions][asynchronous-safe function]]* 在signal handler下被安全调用并没有任何
  副作用.
+ *Concurrency vs. Parallelism* 并不一样.Parallelism意味同时运行代码.而
  Concurrency意味许多任务可以以任何顺序执行或可以是并行运行.

** Amdahl法则和Pareto原则
Threads能提供益处 /对于相适/ 的应用.所以thread的并行性对于应用来说也有
它的限制.

*** Amdahl法则
[[http://en.wikipedia.org/wiki/Amdahl%27s_law][Amdahl法则]] 陈述到潜在的程序加速由能被并行的代码率P定义为:

\begin{equation}
\begin{align}
speedup = \dfrac{1}{1-P}
\end{align}
\end{equation}

+ 如果代码中没有能并行的部分,P=0,那么speedup=1.
+ 如果所有代码都能并行,P=1,那么speedup能达到无限(理论上).
+ 如果50%的代码能并行,那么最大的speedup=2,也就是最多2倍的加速.

引入能并行的处理器个数,那么进一步可以定义为:

\begin{equation}
\begin{align}
speedup = \dfrac{1}{\dfrac{P}{N} + (1-P)}
其中P并行率,N处理器个数
\end{align}
\end{equation}

[[./Files/amdahl1.gif]]
[[./Files/amdahl2.gif]]

*** Pareto原则
[[http://en.wikipedia.org/wiki/Pareto_principle][Pareto原则]] 陈述到80%的处理器时间花在20%的代码中.所以仔细分析代码,不要
把时间花在并行/优化那部分不重要的代码.

* Thread设计模式[fn:1]
在程序中有不同的方法使用线程,这里讨论3种线程设计模式,没有哪一种模式最
好,每种模式都有相应适合的应用场合.

** Boss/worker(Thread pool)
[[./Files/boss_workers_pattern.gif]]

如上图,一个Boss线程创建其他Worker线程,并给它们分配任务,必要的话,并等待其他线
程运行结束.通常Boss线程会在初始建立Thread Pool来为之后分配.尽管线程是
轻量级的,但是创建它们仍是有开销的.

** Peer(Workcrew)
[[./Files/peer_pattern.gif]]

Peer模式又叫做workcrew模式,一个thread创建其他peer threads当程序开始,但
是如上图,与Boss/worker模式不同,这个thread之后也变成peer thread去处理自
己的任务.

** Pipeline
[[./Files/pipeline_pattern.gif]]

Pipeline模式假定:
+ 一串连续长输入.
+ 每个输入经过一连串的子操作(熟知为stages或fliers).
+ 每个处理stage能一次处理个不同的输入.

如上图, Pipeline就像流水线一般,每个thread是一个长链中的一部分.每个
thread处理由之前thread过的数据.

* 线程同步原语
如上线程中的定义,线程们共享进程中的全局变量或资源,它们可以并行同时对这些数据
和资源操作,如果没有一定的机制协调它们,那么数据或资源将处于一个不安全状
态,引起诸如如下的一些问题:

+ [[http://en.wikipedia.org/wiki/Race_condition#Software][Race condition]]发生于不能决定行为的结果因为线程们操作共享数据或资源没
  有遵循一定的同步规则.
+ [[http://en.wikipedia.org/wiki/ABA_problem][ABA problem]]发生于一个地方被读取两次,都读到相同的值,'值是相同的'被用
  来说明'没有东西被改变'.但是,另外一个线程能在这两次读取中间执行操作并
  修改这个位置的值,然后做一些其他操作,最后把这个值改回去,以致愚弄第一
  个线程让它认为'没有东西被改变',即使第二个线程的操作已经破坏了这个假
  设.

所以我们需要如下的一些线程同步原语满足不同的线程间同步需求.

** Mutex
[[http://en.wikipedia.org/wiki/Lock_%28computer_science%29][Mutex]] 又被称为Lock,所以它就像一把Lock,一个线程Lock住一段资源,那么其他线
程就不能去访问那段资源,只有等到第一个线程Unlock那么资源,它才能访问.

在Lock和Unlock之间的代码,一般被称为 *critical section*.

Mutex也包含一些复杂的类型,如下:
+ Recursive: 允许占有锁的那一个线程再次获取同样的锁,对递归算法是必要的.
+ Queuing: 使得 *公平* 的获取锁,通过FIFO排序锁的请求.
+ Reader/Writer(rwlock): 允许多个reader同时获取锁,如果有reader占用
  锁,writer只有等到reader释放锁.
+ Scoped: [[http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization][RAII]] 类型定义的锁获取和解锁.

但Mutex也会引入其他一些问题,如[[http://en.wikipedia.org/wiki/Deadlock][deadlock]] 和 [[http://en.wikipedia.org/wiki/Priority_inversion][priority inversion]].

在Blog中之前[[http://dreamrunner.org/blog/2014/06/29/qian-tan-mutex-lock/][浅谈Mutex (Lock)]]中可以看到更多有关Mutex的性能和开销分析,并如何实现一
个轻量级的Mutex.

** Join
线程join机制能让一个线程join到另外一个线程中.比如一个子线程join回主线
程,那么主线程就会等待子线程运行结束.从而达到线程间等待的同步机制.

** Condition Variable
Condition variable 允许线程同步到某个共享资源的某个值.

比如,程序有一个计数器,当计数器达到某一个值时去激活某个线程运行.把计数
器当成一个Condition variable.这个线程可以等待这个Condition variable,其
他active线程操作完这个Condition variable,可以通过signal/broadcast去唤
醒那些等待这个Condition variable睡眠的线程.

** Barrier
Barrier是一种能让一系列线程在某个点得到同步的方法,通过让参与barrier的
线程等待直到所有参与线程都调用了这个barrier函数.本质上就是,阻塞所有参
与barrier的线程直到最慢的那个参与线程调用barrier.
** Spinlock
Spinlock与mutex类似,是种锁,但当获取锁失败时,spinlock不会让线程进入睡眠,而
是不断poll去获取这个锁直到获取成功.更多[[http://dreamrunner.org/blog/2014/06/29/qian-tan-mutex-lock/#mutex-vs-spinlock][Mutex与Spinlock的区别]].

** Semaphore
当某些资源具有多个时,简单的Mutex不能满足,引入Semphore,Semphore可以根据
资源个数初始化为任意值.当线程们占有所有资源,使得Semphore为0,那么其他线
程再获取资源只有等待.当Semphore值只能是1或0时,它相当于简单的Mutex.

* Pthread
** Overview
原始的Pthread API由ANSI/IEEE POSIX 1003.1 - 1995 standard定义.POSIX标
准也随着时间不断改进.

接下来主要把Pthread API分成如下主要5部分:
1. Thread Management
2. Mutex Variables
3. Condition Variables
4. Synchronization
5. Miscellaneous

如果想把Pthread封装成类对象或Scoped Lock,可以参考之后
[[google-wrap][Google wrap the Pthread]],或直接使用之后介绍的[[boost-thread][Boost thread library]].

如果更全面的API参考文章最后的[[pthread-library][Pthread Library Routines Reference]].更多有关资
料参考文章后的[[<<other-materials>>][其他资料]].
*** 编译Pthread程序
**** include
对于POSIX系统,包含头文件 =pthread.h=. 如果使用 =semaphore=, 包含
=semaphore.h=.

#+begin_src c
#include <pthread.h>
#include <semaphore.h>
#+end_src
**** compile
对于Gcc编译器,使用选项 =-l=,如下:
#+begin_src sh
gcc Program.o -o Program -lpthread
#+end_src

** Thread Management
*** Creating and Terminating Threads
**** APIs
#+begin_src c
int pthread_create(pthread_t *thread,
              const pthread_attr_t *attr,
              void *(*start_routine)(void*), void *arg);
void pthread_exit(void *value_ptr);
int pthread_cancel(pthread_t thread);
int pthread_attr_init(pthread_attr_t *attr);
int pthread_attr_destroy(pthread_attr_t *attr);
#+end_src
**** Creating Threads
=pthread_create= 创建一个新的线程并运行它.它能在代码的任何处被多次调用.

=pthread_create= 的参数:
+ =thread=:返回新thread程的唯一标识.
+ =attr=:设置thread的性质.NULL为默认性质.
+ =start_routine=: 新thread运行的函数指针.
+ =arg=:传给 =start_routine= 的参数,必须强制转换成 =void *=.NULL为没有
  参数传入.

Process能创建的最大thread个数由系统配置决定.如下Ubuntu打印出的结果:
#+begin_src sh
$ limit
cputime         unlimited
filesize        unlimited
datasize        unlimited
stacksize       8MB
coredumpsize    0kB
memoryuse       unlimited
maxproc         62694
descriptors     1024
memorylocked    64kB
addressspace    unlimited
maxfilelocks    unlimited
sigpending      62694
msgqueue        819200
nice            0
rt_priority     0
rt_time         unlimited
#+end_src
**** Thread Attributes
=pthread_attr_init= 和 =pthread_attr_destroy= 被用来初始化/销毁thread
性质对象.

性质包括:
+ Detached or joinable state
+ Scheduling inheritance
+ Scheduling policy
+ Scheduling parameters
+ Scheduling contention scope
+ Stack size
+ Stack address
+ Stack guard (overflow) size
**** Thread Binding
Pthread APIs并没有提供binding threads到特定cpus/cores的接口.但不同系统
可能包含这功能,比如提供非标准的[[https://computing.llnl.gov/tutorials/pthreads/man/pthread_setaffinity_np.txt][=pthread_setaffinity_np= ]] 接口.

比如设置两个线程都在core0上运行,如下设置:
#+begin_src c++
  cpu_set_t cpus;
  CPU_ZERO(&cpus);
  CPU_SET(0, &cpus);
  pthread_setaffinity_np(thread[0], sizeof(cpu_set_t), &cpus);
  pthread_setaffinity_np(thread[1], sizeof(cpu_set_t), &cpus);
#+end_src
**** Terminating Threads
**** Example: Pthread Creation and Termination
*** Joining and Detaching Threads
**** APIs
#+begin_src c
int pthread_join(pthread_t thread, void **value_ptr);
int pthread_detach(pthread_t thread);
int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
int pthread_attr_getdetachstate(const pthread_attr_t *attr,
              int *detachstate);
#+end_src
**** Example: Pthread Joining
*** Stack Management
**** APIs
#+begin_src c
int pthread_attr_getstacksize(const pthread_attr_t *restrict attr,
              size_t *restrict stacksize);
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
int pthread_attr_getstackaddr(const pthread_attr_t *restrict attr,
              void **restrict stackaddr);
int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stackaddr);
#+end_src
*** Miscellaneous
#+begin_src c
pthread_t pthread_self(void);
int pthread_equal(pthread_t t1, pthread_t t2);
int pthread_once(pthread_once_t *once_control,
              void (*init_routine)(void));
pthread_once_t once_control = PTHREAD_ONCE_INIT;
#+end_src

** Mutex Variables
*** Overview
*** Creating and Destroying Mutexes
**** APIs
#+begin_src c
int pthread_mutex_destroy(pthread_mutex_t *mutex);
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
          const pthread_mutexattr_t *restrict attr);
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
int pthread_mutexattr_init(pthread_mutexattr_t *attr);
#+end_src
*** Locking and Unlocking Mutexes
**** APIs
#+begin_src c
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
#+end_src
*** Example: Using Mutexes

** Condition Variables
*** Overview

** Synchronization

** Miscellaneous

<<google-wrap>>
* Google wrap the Pthread 

* Thread Debugging:
http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html

<<boost-thread>>
* Boost thread library

http://www.drdobbs.com/cpp/the-boostthreads-library/184401518

http://www.boost.org/doc/libs/1_55_0/doc/html/thread.html

http://remonstrate.wordpress.com/2009/12/05/boost-%E7%9A%84-thread/

http://blog.csdn.net/vagrxie/article/details/4246470



<<other-materials>>
* 其他资料
** Books:
+ [[http://shop.oreilly.com/product/9781565921153.do][PThreads Programming]] and [[http://wiki.dreamrunner.org/public_html/Books%20Review/Pthreads%20Programming/Pthreads%20Programming.html][Its notes]]
+ [[http://www.justsoftwaresolutions.co.uk/blog/][Anthony Williams’ blog]] and his book, [[http://www.amazon.com/gp/product/1933988770/ref=as_li_ss_tl?ie=UTF8&tag=preshonprogr-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=1933988770][C++ Concurrency in Action]]
+ Herlihy & Shavit's [[www.amazon.com/gp/product/0123973376/ref=as_li_ss_tl?ie=UTF8&tag=preshonprogr-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0123973376][The Art of Multiprocessor Programming]]

** Online resources:
+ [[www.1024cores.net][Dmitriy V’jukov’s website]] and various [[https://groups.google.com/forum/?fromgroups#!forum/lock-free][forum discussions]]
+ [[http://bartoszmilewski.com/][Bartosz Milewski’s blog]]
+ Charles Bloom’s [[http://cbloomrants.blogspot.ca/2012/06/06-12-12-another-threading-post-index.html][Threading Posts]] on his blog
+ Doug Lea's [[http://g.oswego.edu/dl/jmm/cookbook.html][The JSR-133 Cookbook for Compiler Writers]]
+ [[http://www.kernel.org/doc/Documentation/memory-barriers.txt][memory-barriers.txt document]]
+ Hans Boehm’s [[http://www.hboehm.info/c++mm/][collection of links about the C++11 memory model]]
+ Scott Meyers's [[http://scottmeyers.blogspot.hk/2012/04/information-on-c11-memory-model.html][Information on the C++11 Memory Model ]]
+ Herb Sutter’s [[http://www.gotw.ca/publications/][Effective Concurrency series]]
+ POSIX Standard: http://www.unix.org/version3/ieee_std.html

** 有关Mutex
+ [[http://home.roadrunner.com/~hinnant/mutexes/locking.html][Handling mutexes in C++]]
+ [[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html][Mutex, Lock, Condition Variable Rationale]]
* cc

#+begin_src c++

#+end_src

<<pthread-library>>
* Pthread Library Routines Reference
#+begin_html
<p>
<a href="man/pthread_atfork.txt">pthread_atfork</a>
<br><a href="man/pthread_attr_destroy.txt">pthread_attr_destroy</a>
<br><a href="man/pthread_attr_getdetachstate.txt">pthread_attr_getdetachstate</a>
<br><a href="man/pthread_attr_getguardsize.txt">pthread_attr_getguardsize</a>
<br><a href="man/pthread_attr_getinheritsched.txt">pthread_attr_getinheritsched</a>
<br><a href="man/pthread_attr_getschedparam.txt">pthread_attr_getschedparam</a>
<br><a href="man/pthread_attr_getschedpolicy.txt">pthread_attr_getschedpolicy</a>
<br><a href="man/pthread_attr_getscope.txt">pthread_attr_getscope</a>
<br><a href="man/pthread_attr_getstack.txt">pthread_attr_getstack</a>
<br><a href="man/pthread_attr_getstackaddr.txt">pthread_attr_getstackaddr</a>
<br><a href="man/pthread_attr_getstacksize.txt">pthread_attr_getstacksize</a>
<br><a href="man/pthread_attr_init.txt">pthread_attr_init</a>
<br><a href="man/pthread_attr_setdetachstate.txt">pthread_attr_setdetachstate</a>
<br><a href="man/pthread_attr_setguardsize.txt">pthread_attr_setguardsize</a>
<br><a href="man/pthread_attr_setinheritsched.txt">pthread_attr_setinheritsched</a>
<br><a href="man/pthread_attr_setschedparam.txt">pthread_attr_setschedparam</a>
<br><a href="man/pthread_attr_setschedpolicy.txt">pthread_attr_setschedpolicy</a>
<br><a href="man/pthread_attr_setscope.txt">pthread_attr_setscope</a>
<br><a href="man/pthread_attr_setstack.txt">pthread_attr_setstack</a>
<br><a href="man/pthread_attr_setstackaddr.txt">pthread_attr_setstackaddr</a>
<br><a href="man/pthread_attr_setstacksize.txt">pthread_attr_setstacksize</a>
<br><a href="man/pthread_barrier_destroy.txt">pthread_barrier_destroy</a>
<br><a href="man/pthread_barrier_init.txt">pthread_barrier_init</a>
<br><a href="man/pthread_barrier_wait.txt">pthread_barrier_wait</a>
<br><a href="man/pthread_barrierattr_destroy.txt">pthread_barrierattr_destroy</a>
<br><a href="man/pthread_barrierattr_getpshared.txt">pthread_barrierattr_getpshared</a>
<br><a href="man/pthread_barrierattr_init.txt">pthread_barrierattr_init</a>
<br><a href="man/pthread_barrierattr_setpshared.txt">pthread_barrierattr_setpshared</a>
<br><a href="man/pthread_cancel.txt">pthread_cancel</a>
<br><a href="man/pthread_cleanup_pop.txt">pthread_cleanup_pop</a>
<br><a href="man/pthread_cleanup_push.txt">pthread_cleanup_push</a>
<br><a href="man/pthread_cond_broadcast.txt">pthread_cond_broadcast</a>
<br><a href="man/pthread_cond_destroy.txt">pthread_cond_destroy</a>
<br><a href="man/pthread_cond_init.txt">pthread_cond_init</a>
<br><a href="man/pthread_cond_signal.txt">pthread_cond_signal</a>
<br><a href="man/pthread_cond_timedwait.txt">pthread_cond_timedwait</a>
<br><a href="man/pthread_cond_wait.txt">pthread_cond_wait</a>
<br><a href="man/pthread_condattr_destroy.txt">pthread_condattr_destroy</a>
<br><a href="man/pthread_condattr_getclock.txt">pthread_condattr_getclock</a>
<br><a href="man/pthread_condattr_getpshared.txt">pthread_condattr_getpshared</a>
<br><a href="man/pthread_condattr_init.txt">pthread_condattr_init</a>
<br><a href="man/pthread_condattr_setclock.txt">pthread_condattr_setclock</a>
<br><a href="man/pthread_condattr_setpshared.txt">pthread_condattr_setpshared</a>
<br><a href="man/pthread_create.txt">pthread_create</a>
<br><a href="man/pthread_detach.txt">pthread_detach</a>
<br><a href="man/pthread_equal.txt">pthread_equal</a>
<br><a href="man/pthread_exit.txt">pthread_exit</a>
<br><a href="man/pthread_getconcurrency.txt">pthread_getconcurrency</a>
<br><a href="man/pthread_getcpuclockid.txt">pthread_getcpuclockid</a>
<br><a href="man/pthread_getschedparam.txt">pthread_getschedparam</a>
<br><a href="man/pthread_getspecific.txt">pthread_getspecific</a>
<br><a href="man/pthread_join.txt">pthread_join</a>
<br><a href="man/pthread_key_create.txt">pthread_key_create</a>
<br><a href="man/pthread_key_delete.txt">pthread_key_delete</a>
<br><a href="man/pthread_kill.txt">pthread_kill</a>
<br><a href="man/pthread_mutex_destroy.txt">pthread_mutex_destroy</a>
<br><a href="man/pthread_mutex_getprioceiling.txt">pthread_mutex_getprioceiling</a>
<br><a href="man/pthread_mutex_init.txt">pthread_mutex_init</a>
<br><a href="man/pthread_mutex_lock.txt">pthread_mutex_lock</a>
<br><a href="man/pthread_mutex_setprioceiling.txt">pthread_mutex_setprioceiling</a>
<br><a href="man/pthread_mutex_timedlock.txt">pthread_mutex_timedlock</a>
<br><a href="man/pthread_mutex_trylock.txt">pthread_mutex_trylock</a>
<br><a href="man/pthread_mutex_unlock.txt">pthread_mutex_unlock</a>
<br><a href="man/pthread_mutexattr_destroy.txt">pthread_mutexattr_destroy</a>
<br><a href="man/pthread_mutexattr_getprioceiling.txt">pthread_mutexattr_getprioceiling</a>
<br><a href="man/pthread_mutexattr_getprotocol.txt">pthread_mutexattr_getprotocol</a>
<br><a href="man/pthread_mutexattr_getpshared.txt">pthread_mutexattr_getpshared</a>
<br><a href="man/pthread_mutexattr_gettype.txt">pthread_mutexattr_gettype</a>
<br><a href="man/pthread_mutexattr_init.txt">pthread_mutexattr_init</a>
<br><a href="man/pthread_mutexattr_setprioceiling.txt">pthread_mutexattr_setprioceiling</a>
<br><a href="man/pthread_mutexattr_setprotocol.txt">pthread_mutexattr_setprotocol</a>
<br><a href="man/pthread_mutexattr_setpshared.txt">pthread_mutexattr_setpshared</a>
<br><a href="man/pthread_mutexattr_settype.txt">pthread_mutexattr_settype</a>
<br><a href="man/pthread_once.txt">pthread_once</a>
<br><a href="man/pthread_rwlock_destroy.txt">pthread_rwlock_destroy</a>
<br><a href="man/pthread_rwlock_init.txt">pthread_rwlock_init</a>
<br><a href="man/pthread_rwlock_rdlock.txt">pthread_rwlock_rdlock</a>
<br><a href="man/pthread_rwlock_timedrdlock.txt">pthread_rwlock_timedrdlock</a>
<br><a href="man/pthread_rwlock_timedwrlock.txt">pthread_rwlock_timedwrlock</a>
<br><a href="man/pthread_rwlock_tryrdlock.txt">pthread_rwlock_tryrdlock</a>
<br><a href="man/pthread_rwlock_trywrlock.txt">pthread_rwlock_trywrlock</a>
<br><a href="man/pthread_rwlock_unlock.txt">pthread_rwlock_unlock</a>
<br><a href="man/pthread_rwlock_wrlock.txt">pthread_rwlock_wrlock</a>
<br><a href="man/pthread_rwlockattr_destroy.txt">pthread_rwlockattr_destroy</a>
<br><a href="man/pthread_rwlockattr_getpshared.txt">pthread_rwlockattr_getpshared</a>
<br><a href="man/pthread_rwlockattr_init.txt">pthread_rwlockattr_init</a>
<br><a href="man/pthread_rwlockattr_setpshared.txt">pthread_rwlockattr_setpshared</a>
<br><a href="man/pthread_self.txt">pthread_self</a>
<br><a href="man/pthread_setcancelstate.txt">pthread_setcancelstate</a>
<br><a href="man/pthread_setcanceltype.txt">pthread_setcanceltype</a>
<br><a href="man/pthread_setconcurrency.txt">pthread_setconcurrency</a>
<br><a href="man/pthread_setschedparam.txt">pthread_setschedparam</a>
<br><a href="man/pthread_setschedprio.txt">pthread_setschedprio</a>
<br><a href="man/pthread_setspecific.txt">pthread_setspecific</a>
<br><a href="man/pthread_sigmask.txt">pthread_sigmask</a>
<br><a href="man/pthread_spin_destroy.txt">pthread_spin_destroy</a>
<br><a href="man/pthread_spin_init.txt">pthread_spin_init</a>
<br><a href="man/pthread_spin_lock.txt">pthread_spin_lock</a>
<br><a href="man/pthread_spin_trylock.txt">pthread_spin_trylock</a>
<br><a href="man/pthread_spin_unlock.txt">pthread_spin_unlock</a>
<br><a href="man/pthread_testcancel.txt">pthread_testcancel</a>
</p>
#+end_html

* Footnotes

[fn:1] http://maxim.int.ru/bookshelf/PthreadsProgram/htm/r_19.html

