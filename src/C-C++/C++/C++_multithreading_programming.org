#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: 浅谈C++ multithreading programming
#+OPTIONS: num:nil H:2

* Overview
随着多核CPU随处可见,多线程(multithreading)可以被用来实现并行,提高CPU的
利用率和性能显著的提高.掌握多线程编程也成为现代实现软件的基本要求技能
之一.[[https://computing.llnl.gov/tutorials/parallel_comp/][Introduction to Parallel Computing]]详细的介绍了 Parallel Computing;
为什么使用它;Parallel Computing的分类;Parallel Computing的limits和
costs; Parallel Computing的程序模型;如何设计Parallel程序等.

这里先介绍多线程的概念,多线程中涉及的基本概念,然后用实例介绍Pthread库
的使用,并介绍Google Code中如何把它封装成C++类,最后介绍可移植并大量使用的
[[http://www.boost.org/doc/libs/1_55_0/doc/html/thread.html][Boost Thread库]].

还有一些其他的Thread库:
+ [[http://openmp.org/wp/][OpenMP]] 是一个可移植的接口,在共享内存的多处理器上实现fork-join并行.
  OpenMP的tutorial:[[https://computing.llnl.gov/tutorials/openMP/][这里]] 和 [[http://vergil.chemistry.gatech.edu/resources/programming/OpenMP.pdf][这里]],
+ [[http://omniorb.sourceforge.net/omni42/omnithread.html][OMNI Thread]]为C++提供Thread操作的.
+ [[http://en.wikipedia.org/wiki/List_of_C%2B%2B_multi-threading_libraries][其他multithreading libraries]].

* Thread
** 定义
A *thread* is defined as an independent stream of instructions that can
be scheduled to run as such by the operating system.所以它是在程序中独
立于其他代码可由操作系统调度的一段指令.

那么是操作系统是如何具体实现这一独立性呢?

要理解thread,必须先明白process.进程由操作系统创建来运行相应的程序,进程
包含程序资源和程序执行状态的信息.以Linux的进程为例包含:
+ Process ID, process group ID, user ID, and group ID
+ Environment
+ Working directory
+ Program instructions
+ Registers
+ Stack
+ Heap
+ File descriptors
+ Signal actions
+ Shared libraries
+ Inter-process communication tools (such as message queues, pipes,
  semaphores, or shared memory).

Thread使用Process的资源,并且能成为独立的元件被操作系统调度,是因为它仅
重复那些使得它们能成为独立运行代码的必要资源.Thread维护它自己如下的信
息:
+ Stack pointer
+ Registers
+ Scheduling properties (such as policy or priority)
+ Set of pending and blocked signals
+ Thread specific data.

与Process比较,Thread可以总结如下:
+ Thread相当于一个lightweight的Process,拥有如ID,properties等相似信息,
  但仅仅包含能使得它独立运行的信息即可.
+ 信息包含的不同,与需要复制大量信息来创建Process比,Thread的创建比较快
  捷.
+ 独立的Processes不共享任何信息.每个Process运行在独立的地址空间.Threads共
  享所在Process的资源,全局变量和文件描述符.
+ Threads可以直接与所在同一Process的Threads通信.而Processes必须使用
  inter-process communication(IPC)来通信.
+ 因为Threads的资源共享性,增加并行操作资源的难度,需要引入Thread同步机
  制来达到资源并行性.

** 一些术语
Posix Thread基本模型如下图,一些有关其中Thread的术语:

[[./Files/threads_model.png]]

+ *Lightweight Process(LWP)* 可以被认为虚拟的CPU,在系统中通常LWP的个
  数大于实际CPU个数.Thread库通过与LWP沟通来调度thread.LWP也通常被称为
  kernel threads.
+ *[[http://en.wikipedia.org/wiki/System_Contention_Scope][Contention Scope]]* 是如何决定哪个线程得到调度.
+ *Bound threads* 拥有系统级别的Contention Scope,也就是,它们与其他进程
  一同竞争.
+ *Unbound threads* 拥有进程级别的Contention Scope.
+ *Thread-safe* 意味共享数据被得到保护,可以同时被多个thread调用而安全.
+ *Reentrant code* 意味程序可以被多个thread并行运行.
+ *[[https://www.securecoding.cert.org/confluence/display/seccode/BB.+Definitions][asynchronous-safe function]]* 在signal handler下被安全调用并没有任何
  副作用.
+ *Concurrency vs. Parallelism* 并不一样.Parallelism意味同时运行代码.而
  Concurrency意味许多任务可以以任何顺序执行或可以是并行运行.

** Amdahl法则和Pareto原则
Threads能提供益处 /对于相适/ 的应用.所以thread的并行性对于应用来说也有
它的限制.

*** Amdahl法则
[[http://en.wikipedia.org/wiki/Amdahl%27s_law][Amdahl法则]] 陈述到潜在的程序加速由能被并行的代码率P定义为:

\begin{equation}
\begin{align}
speedup = \dfrac{1}{1-P}
\end{align}
\end{equation}

+ 如果代码中没有能并行的部分,P=0,那么speedup=1.
+ 如果所有代码都能并行,P=1,那么speedup能达到无限(理论上).
+ 如果50%的代码能并行,那么最大的speedup=2,也就是最多2倍的加速.

引入能并行的处理器个数,那么进一步可以定义为:

\begin{equation}
\begin{align}
speedup = \dfrac{1}{\dfrac{P}{N} + (1-P)}
其中P并行率,N处理器个数
\end{align}
\end{equation}

[[./Files/amdahl1.gif]]
[[./Files/amdahl2.gif]]

*** Pareto原则
[[http://en.wikipedia.org/wiki/Pareto_principle][Pareto原则]] 陈述到80%的处理器时间花在20%的代码中.

* Thread设计模式

* 保护共享资源

* 线程同步原语


* Pthread

** Overview

** Thread Management

** Mutex Variables

** Condition Variables

** Miscellaneous


POSIX Threads
Library based; requires parallel coding
Specified by the IEEE POSIX 1003.1c standard (1995).
C Language only
Commonly referred to as Pthreads.
Most hardware vendors now offer Pthreads in addition to their proprietary threads implementations.

Very explicit parallelism; requires significant programmer attention
to detail.


http://fanqiang.chinaunix.net/a4/b8/20010811/0905001105_b.html

http://www.tutorialspoint.com/cplusplus/cpp_multithreading.htm

http://softpixel.com/~cwright/programming/threads/threads.c.php

http://randu.org/tutorials/threads/

https://computing.llnl.gov/tutorials/pthreads/
* google wrap the pthread 

* Thread Debugging:
http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html




* mutex
Handling mutexes in C++
http://home.roadrunner.com/~hinnant/mutexes/locking.html

Mutex, Lock, Condition Variable Rationale adds rationale for the
design decisions made for mutexes, locks and condition variables. 

http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html
* boost thread libray

http://www.drdobbs.com/cpp/the-boostthreads-library/184401518

http://www.boost.org/doc/libs/1_55_0/doc/html/thread.html

http://remonstrate.wordpress.com/2009/12/05/boost-%E7%9A%84-thread/

http://blog.csdn.net/vagrxie/article/details/4246470



* 其他资料
** Books:
+ [[http://shop.oreilly.com/product/9781565921153.do][PThreads Programming]] and [[http://wiki.dreamrunner.org/public_html/Books%20Review/Pthreads%20Programming/Pthreads%20Programming.html][Its notes]]
+ [[http://www.justsoftwaresolutions.co.uk/blog/][Anthony Williams’ blog]] and his book, [[http://www.amazon.com/gp/product/1933988770/ref=as_li_ss_tl?ie=UTF8&tag=preshonprogr-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=1933988770][C++ Concurrency in Action]]
+ Herlihy & Shavit's [[www.amazon.com/gp/product/0123973376/ref=as_li_ss_tl?ie=UTF8&tag=preshonprogr-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0123973376][The Art of Multiprocessor Programming]]

** Online resources:
+ [[www.1024cores.net][Dmitriy V’jukov’s website]] and various [[https://groups.google.com/forum/?fromgroups#!forum/lock-free][forum discussions]]
+ [[http://bartoszmilewski.com/][Bartosz Milewski’s blog]]
+ Charles Bloom’s [[http://cbloomrants.blogspot.ca/2012/06/06-12-12-another-threading-post-index.html][Threading Posts]] on his blog
+ Doug Lea's [[http://g.oswego.edu/dl/jmm/cookbook.html][The JSR-133 Cookbook for Compiler Writers]]
+ [[http://www.kernel.org/doc/Documentation/memory-barriers.txt][memory-barriers.txt document]]
+ Hans Boehm’s [[http://www.hboehm.info/c++mm/][collection of links about the C++11 memory model]]
+ Scott Meyers's [[http://scottmeyers.blogspot.hk/2012/04/information-on-c11-memory-model.html][Information on the C++11 Memory Model ]]
+ Herb Sutter’s [[http://www.gotw.ca/publications/][Effective Concurrency series]]
+ POSIX Standard: http://www.unix.org/version3/ieee_std.html

* cc

#+begin_src c++

#+end_src

* Pthread Library Routines Reference
#+begin_html
<p>
<a href="man/pthread_atfork.txt">pthread_atfork</a>
<br><a href="man/pthread_attr_destroy.txt">pthread_attr_destroy</a>
<br><a href="man/pthread_attr_getdetachstate.txt">pthread_attr_getdetachstate</a>
<br><a href="man/pthread_attr_getguardsize.txt">pthread_attr_getguardsize</a>
<br><a href="man/pthread_attr_getinheritsched.txt">pthread_attr_getinheritsched</a>
<br><a href="man/pthread_attr_getschedparam.txt">pthread_attr_getschedparam</a>
<br><a href="man/pthread_attr_getschedpolicy.txt">pthread_attr_getschedpolicy</a>
<br><a href="man/pthread_attr_getscope.txt">pthread_attr_getscope</a>
<br><a href="man/pthread_attr_getstack.txt">pthread_attr_getstack</a>
<br><a href="man/pthread_attr_getstackaddr.txt">pthread_attr_getstackaddr</a>
<br><a href="man/pthread_attr_getstacksize.txt">pthread_attr_getstacksize</a>
<br><a href="man/pthread_attr_init.txt">pthread_attr_init</a>
<br><a href="man/pthread_attr_setdetachstate.txt">pthread_attr_setdetachstate</a>
<br><a href="man/pthread_attr_setguardsize.txt">pthread_attr_setguardsize</a>
<br><a href="man/pthread_attr_setinheritsched.txt">pthread_attr_setinheritsched</a>
<br><a href="man/pthread_attr_setschedparam.txt">pthread_attr_setschedparam</a>
<br><a href="man/pthread_attr_setschedpolicy.txt">pthread_attr_setschedpolicy</a>
<br><a href="man/pthread_attr_setscope.txt">pthread_attr_setscope</a>
<br><a href="man/pthread_attr_setstack.txt">pthread_attr_setstack</a>
<br><a href="man/pthread_attr_setstackaddr.txt">pthread_attr_setstackaddr</a>
<br><a href="man/pthread_attr_setstacksize.txt">pthread_attr_setstacksize</a>
<br><a href="man/pthread_barrier_destroy.txt">pthread_barrier_destroy</a>
<br><a href="man/pthread_barrier_init.txt">pthread_barrier_init</a>
<br><a href="man/pthread_barrier_wait.txt">pthread_barrier_wait</a>
<br><a href="man/pthread_barrierattr_destroy.txt">pthread_barrierattr_destroy</a>
<br><a href="man/pthread_barrierattr_getpshared.txt">pthread_barrierattr_getpshared</a>
<br><a href="man/pthread_barrierattr_init.txt">pthread_barrierattr_init</a>
<br><a href="man/pthread_barrierattr_setpshared.txt">pthread_barrierattr_setpshared</a>
<br><a href="man/pthread_cancel.txt">pthread_cancel</a>
<br><a href="man/pthread_cleanup_pop.txt">pthread_cleanup_pop</a>
<br><a href="man/pthread_cleanup_push.txt">pthread_cleanup_push</a>
<br><a href="man/pthread_cond_broadcast.txt">pthread_cond_broadcast</a>
<br><a href="man/pthread_cond_destroy.txt">pthread_cond_destroy</a>
<br><a href="man/pthread_cond_init.txt">pthread_cond_init</a>
<br><a href="man/pthread_cond_signal.txt">pthread_cond_signal</a>
<br><a href="man/pthread_cond_timedwait.txt">pthread_cond_timedwait</a>
<br><a href="man/pthread_cond_wait.txt">pthread_cond_wait</a>
<br><a href="man/pthread_condattr_destroy.txt">pthread_condattr_destroy</a>
<br><a href="man/pthread_condattr_getclock.txt">pthread_condattr_getclock</a>
<br><a href="man/pthread_condattr_getpshared.txt">pthread_condattr_getpshared</a>
<br><a href="man/pthread_condattr_init.txt">pthread_condattr_init</a>
<br><a href="man/pthread_condattr_setclock.txt">pthread_condattr_setclock</a>
<br><a href="man/pthread_condattr_setpshared.txt">pthread_condattr_setpshared</a>
<br><a href="man/pthread_create.txt">pthread_create</a>
<br><a href="man/pthread_detach.txt">pthread_detach</a>
<br><a href="man/pthread_equal.txt">pthread_equal</a>
<br><a href="man/pthread_exit.txt">pthread_exit</a>
<br><a href="man/pthread_getconcurrency.txt">pthread_getconcurrency</a>
<br><a href="man/pthread_getcpuclockid.txt">pthread_getcpuclockid</a>
<br><a href="man/pthread_getschedparam.txt">pthread_getschedparam</a>
<br><a href="man/pthread_getspecific.txt">pthread_getspecific</a>
<br><a href="man/pthread_join.txt">pthread_join</a>
<br><a href="man/pthread_key_create.txt">pthread_key_create</a>
<br><a href="man/pthread_key_delete.txt">pthread_key_delete</a>
<br><a href="man/pthread_kill.txt">pthread_kill</a>
<br><a href="man/pthread_mutex_destroy.txt">pthread_mutex_destroy</a>
<br><a href="man/pthread_mutex_getprioceiling.txt">pthread_mutex_getprioceiling</a>
<br><a href="man/pthread_mutex_init.txt">pthread_mutex_init</a>
<br><a href="man/pthread_mutex_lock.txt">pthread_mutex_lock</a>
<br><a href="man/pthread_mutex_setprioceiling.txt">pthread_mutex_setprioceiling</a>
<br><a href="man/pthread_mutex_timedlock.txt">pthread_mutex_timedlock</a>
<br><a href="man/pthread_mutex_trylock.txt">pthread_mutex_trylock</a>
<br><a href="man/pthread_mutex_unlock.txt">pthread_mutex_unlock</a>
<br><a href="man/pthread_mutexattr_destroy.txt">pthread_mutexattr_destroy</a>
<br><a href="man/pthread_mutexattr_getprioceiling.txt">pthread_mutexattr_getprioceiling</a>
<br><a href="man/pthread_mutexattr_getprotocol.txt">pthread_mutexattr_getprotocol</a>
<br><a href="man/pthread_mutexattr_getpshared.txt">pthread_mutexattr_getpshared</a>
<br><a href="man/pthread_mutexattr_gettype.txt">pthread_mutexattr_gettype</a>
<br><a href="man/pthread_mutexattr_init.txt">pthread_mutexattr_init</a>
<br><a href="man/pthread_mutexattr_setprioceiling.txt">pthread_mutexattr_setprioceiling</a>
<br><a href="man/pthread_mutexattr_setprotocol.txt">pthread_mutexattr_setprotocol</a>
<br><a href="man/pthread_mutexattr_setpshared.txt">pthread_mutexattr_setpshared</a>
<br><a href="man/pthread_mutexattr_settype.txt">pthread_mutexattr_settype</a>
<br><a href="man/pthread_once.txt">pthread_once</a>
<br><a href="man/pthread_rwlock_destroy.txt">pthread_rwlock_destroy</a>
<br><a href="man/pthread_rwlock_init.txt">pthread_rwlock_init</a>
<br><a href="man/pthread_rwlock_rdlock.txt">pthread_rwlock_rdlock</a>
<br><a href="man/pthread_rwlock_timedrdlock.txt">pthread_rwlock_timedrdlock</a>
<br><a href="man/pthread_rwlock_timedwrlock.txt">pthread_rwlock_timedwrlock</a>
<br><a href="man/pthread_rwlock_tryrdlock.txt">pthread_rwlock_tryrdlock</a>
<br><a href="man/pthread_rwlock_trywrlock.txt">pthread_rwlock_trywrlock</a>
<br><a href="man/pthread_rwlock_unlock.txt">pthread_rwlock_unlock</a>
<br><a href="man/pthread_rwlock_wrlock.txt">pthread_rwlock_wrlock</a>
<br><a href="man/pthread_rwlockattr_destroy.txt">pthread_rwlockattr_destroy</a>
<br><a href="man/pthread_rwlockattr_getpshared.txt">pthread_rwlockattr_getpshared</a>
<br><a href="man/pthread_rwlockattr_init.txt">pthread_rwlockattr_init</a>
<br><a href="man/pthread_rwlockattr_setpshared.txt">pthread_rwlockattr_setpshared</a>
<br><a href="man/pthread_self.txt">pthread_self</a>
<br><a href="man/pthread_setcancelstate.txt">pthread_setcancelstate</a>
<br><a href="man/pthread_setcanceltype.txt">pthread_setcanceltype</a>
<br><a href="man/pthread_setconcurrency.txt">pthread_setconcurrency</a>
<br><a href="man/pthread_setschedparam.txt">pthread_setschedparam</a>
<br><a href="man/pthread_setschedprio.txt">pthread_setschedprio</a>
<br><a href="man/pthread_setspecific.txt">pthread_setspecific</a>
<br><a href="man/pthread_sigmask.txt">pthread_sigmask</a>
<br><a href="man/pthread_spin_destroy.txt">pthread_spin_destroy</a>
<br><a href="man/pthread_spin_init.txt">pthread_spin_init</a>
<br><a href="man/pthread_spin_lock.txt">pthread_spin_lock</a>
<br><a href="man/pthread_spin_trylock.txt">pthread_spin_trylock</a>
<br><a href="man/pthread_spin_unlock.txt">pthread_spin_unlock</a>
<br><a href="man/pthread_testcancel.txt">pthread_testcancel</a>
</p>
#+end_html
