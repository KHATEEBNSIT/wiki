#+SETUPFILE: ~/.emacs.d/src/org-templates/level-3.org
#+TITLE: Algorithm Design Manual Chapter 2
#+OPTIONS: num:nil H:2

* Book Notes
Our two most important tools are (1) the RAM model of
computation and (2) the asymptotic analysis of worst-case complexity.

* Exercises
http://nbl.cewit.stonybrook.edu:60128/mediawiki/index.php/Algo-analysis-TADM2E
** 1
What value is returned by the following function? Express your answer
as a function of n. Give the worst-case running time using the Big Oh
notation.

#+begin_src sh  
function mystery(n)
      r:=0
      for i:=1 to n-1 do
          for j:=i+1 to n do
              for k:=1 to j do
                  r:=r+1
       return(r)
#+end_src

\begin{equation}
\begin{align}
\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\sum_{k=1}^{j}1 = 
\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}j =
\sum_{i=1}^{n-1}(\sum_{j=1}^{n}j - \sum_{j=1}^{i}j) = \\
\sum_{i=1}^{n-1}(\frac{n(n+1)}{2} - \frac{i(i+1)}{2} = 
\frac{1}{2}\sum_{i=1}^{n-1}(n^2+n-i^2-i) = \\
\frac{1}{2}((n-1)n^2+(n-1)n-(\frac{n(n+1)(2n+1)}{6}-n^2)-(\frac{n(n+1)}{2}-n))
\end{align}
\end{equation}

Time: O(n^3)
** 2
What value is returned by the following function? Express your answer as a
function of n. Give the worst-case running time using Big Oh notation.

#+begin_src sh
 function pesky(n)
       r:=0
       for i:=1 to n do
           for j:=1 to i do
               for k:=j to i+j do
                   r:=r+1
       return(r)
#+end_src
\begin{equation}
\begin{align}
f(n) = \frac{n(n+1)(n+2)}{3}
\end{align}
\end{equation}

Time: O(n^3).
** 3
What value is returned by the following function? Express your answer as a
function of n. Give the worst-case running time using Big Oh notation.

#+begin_src sh
function prestiferous(n)
       r:=0
       for i:=1 to n do
           for j:=1 to i do
               for k:=j to i+j do
                   for l:=1 to i+j-k do
                       r:=r+1
       return(r)
#+end_src

\begin{equation}
\begin{align}
f(n) = \frac{n(n+1)(n+2)}{3}
\end{align}
\end{equation}

Time: O(n^4).
** 19
\begin{equation}
\begin{align}
(1/3)^n < 6 < loglogn < logn = lnn < (logn)^2 < n^\frac{1}{3}+logn < \sqrt{n}
 < \frac{n}{logn} < n < nlogn < n^2 = n^2+logn < n^3 < n-n^3+7n^5 < (3/2)^2 
= 2^n < n!
\end{align}
\end{equation}
** 34
Assume that Christmas hasndays. Exactly how many presents did my “true
love” send me? (Do some research if you do not understand this
question.)

假设一共有ｎ天，每i天收到的礼物数是： 
\begin{equation}
\begin{align}
p_i = \sum_{k=1}^{i}k
\end{align}
\end{equation}

总的礼物数：
\begin{equation}
\begin{align}
\sum_{i=1}^{n} p_i = \sum_{i=1}^{n}\sum_{k=1}^{i}k=\frac{n^3+3n^2+2n}{6}
\end{align}
\end{equation}
** 43
You are given a set S of n numbers. You must pick a subset S' of k
numbers from S such that the probability of each element of S
occurring in S' is equal (i.e., each is selected with probability k /
n). You may make only one pass over the numbers. What if n is unknown?

[[http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/Reservoir%20Sampling.html][Reservoir sampling issue]].
** 44
 We have 1,000 data items to store on 1,000 nodes. Each node can store
 copies of exactly three different items. Propose a replication scheme
 to minimize data loss as nodes fail. What is the expected number of
 data entries that get lost when three random nodes fail?

不考虑RAID的XOR做法这里。

1000个数据做3份拷贝，如何做3份拷贝呢？

1. 随机的3个点失败只损失一个数据
3份拷贝以相邻一格的方式存储，如下
#+begin_src sh
nodes:    1       2        3   ...   1000
copy1:   data1    data2    data3 ..  data1000
copy2:   data1000 data1    data2 ..  data999
copy3:   data999  data1000 data1 ..  data998
#+end_src

随机选取3个点的组合个数： $\binom{1000}{3}$ 
其中丢失数据点的组合个数： 1000, 每种组合丢失一个数据
所以丢失数据期望 $1000 / \binom{1000}{3} = 6.01804e-06$ 

2. 随机的3个点失败损失3个数据
每3个点共享3个拷贝点，如下
#+begin_src sh
nodes:    1       2        3   ...   1000
copy1:   data1    data2    data3 ..  data1000
copy2:   data3    data1    data2 ..  data999
copy3:   data2    data3    data1 ..  data998
#+end_src
随机选取3个点的组合个数： $\binom{1000}{3}$ 
其中丢失数据点的组合个数： 1000/3, 每种组合丢失3个数据，
所以丢失数据期望 $1000/3×3 / \binom{1000}{3} = 6.01804e-06$ 
** 45
Consider the following algorithm to find the minimum element in an
array of numbers . One extra variable tmp is allocated to hold the
current minimum value. Start from =A[0]=; "tmp" is compared against
=A[1], A[2], , A[N]= in order. When =A[i] < tmp, tmp = A[i]=. What is the
expected number of times that the assignment operation tmp = A[i] is
performed?



** 46
You have a 100-story building and a couple of marbles. You must
identify the lowest floor for which a marble will break if you drop it
from this floor. How fast can you find this floor if you are given an
infinite supply of marbles? What if you have only two marbles?
** 47
You are given 10 bags of gold coins. Nine bags contain coins that each
weigh 10 grams. One bag contains all false coins that weigh one gram
less. You must identify this bag in just one weighing. You have a
digital balance that reports the weight of what is placed on it.
** 48
You have eight balls all of the same size. Seven of them weigh the
same, and one of them weighs slightly more. How can you find the ball
that is heavier by using a balance and only two weighings?
** 49
Suppose we start with n companies that eventually merge into one big
company. How many different ways are there for them to merge?
** 50
A Ramanujam number can be written two different ways as the sum of two
cubes---i.e., there exist distinct a, b, c, and d such that a3 + b3 =
c3 + d3. Generate all Ramanujam numbers where a,b,c,d < n.
** 51
Six pirates must divide $300 dollars among themselves. The division is
to proceed as follows. The senior pirate proposes a way to divide the
money. Then the pirates vote. If the senior pirate gets at least half
the votes he wins, and that division remains. If he doesn't, he is
killed and then the next senior-most pirate gets a chance to do the
division. Now you have to tell what will happen and why (i.e., how
many pirates survive and how the division is done)? All the pirates
are intelligent and the first priority is to stay alive and the next
priority is to get as much money as possible.
** 52
Reconsider the pirate problem above, where only one indivisible dollar
is to be divided. Who gets the dollar and how many are killed?

* cc


#+begin_src sh

#+end_src

#+begin_src c++

#+end_src


