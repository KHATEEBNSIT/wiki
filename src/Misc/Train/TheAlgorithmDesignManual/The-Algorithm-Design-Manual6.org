#+SETUPFILE: ~/.emacs.d/src/org-templates/level-3.org
#+TITLE: Algorithm Design Manual Chapter 6
#+OPTIONS: num:nil H:2


* Book Notes

** 6.1 Minimum Spanning Trees

*** 6.1.1 Prim’s Algorithm
A greedy algorithm suffices for correctness: we always add the
lowest-weight edge linking a vertex in the tree to a vertex on the
outside. （选取相邻最近的不在树内的点。）

#+begin_src c++
  prim(graph *g, int start)
  {
    int i; /* counter */
    edgenode *p; /* temporary pointer */
    bool intree[MAXV+1]; /* is the vertex in the tree yet? */
    int distance[MAXV+1]; /* cost of adding to tree */
    int v; /* current vertex to process */
    int w; /* candidate next vertex */
    int weight; /* edge weight */
    int dist; /* best current distance from start */
    for (i=1; i<=g->nvertices; i++) {
      intree[i] = FALSE;
      distance[i] = MAXINT;
      parent[i] = -1;
    }
    distance[start] = 0;
    v = start;
    while (intree[v] == FALSE) {
      intree[v] = TRUE;
      p = g->edges[v];
      while (p != NULL) {
        w = p->y;
        weight = p->weight;
        if ((distance[w] > weight) && (intree[w] == FALSE)) {
          distance[w] = weight;
          parent[w] = v;
        }
        p = p->next;
      }
      v = 1;
      dist = MAXINT;
      for (i=1; i<=g->nvertices; i++)
        if ((intree[i] == FALSE) && (dist > distance[i])) {
          dist = distance[i];
          v=i;
        }
    }
  }
#+end_src



* Exercises

* cc


#+begin_src c++

#+end_src



