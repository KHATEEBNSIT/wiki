#+SETUPFILE: ~/.emacs.d/src/org-templates/level-3.org
#+TITLE: Algorithm Design Manual Chapter 4
#+OPTIONS: num:nil H:2


* Book Notes
** 4.3 Heapsort: Fast Sorting via Data Structures
*** Where in the Heap?
Problem: Given an array-based heap on n elements and a real number x,
efficiently determine whether the kth smallest element in the heap is
greater than or equal to x. Your algorithm should be O(k) in the
worst-case, independent of the size of the heap. Hint: you do not have
to find the kth smallest element; you need only determine its
relationship to x.

Solution: There are at least two different ideas that lead to correct
but inefficient algorithms for this problem:

1. Call extract-minktimes, and test whether all of these are less
   thanx. This explicitly sorts the firstkelements and so gives us
   more information than the desired answer, but it takes O(klogn) time
   to do so.
2. The kth smallest element cannot be deeper than the kth level of the
   heap, since the path from it to the root must go through elements
   of decreasing value. Thus we can look at all the elements on the
   first k levels of the heap, and count how many of them are less
   thanx, stopping when we either find k of them or run out of
   elements. This is correct, but takes O(min(n,2^k-1)) time, since
   the top k elements have 2^k-1 elements.

An O(k) solution can look at only k elements smaller than x, plus at
most O(k) elements greater than x. Consider the following recursive
procedure, called at the root with i= 1 with count=k:

#+begin_src c++
  int heap_compare(priority_queue *q, int i, int count, int x)
  {
    if ((count <= 0) || (i > q->n)) return(count);
    if (q->q[i] < x) {
      count = heap_compare(q, pq_young_child(i), count-1, x);
      count = heap_compare(q, pq_young_child(i)+1, count, x);
    }
    return(count);
  }
#+end_src

If the root of the min-heap is ≥ x, then no elements in the heap can
be less than x, as by definition the root must be the smallest
element. This procedure searches the children of all nodes of weight
smaller than x until either (a) we have found k of them, when it returns
0, or (b) they are exhausted, when it returns a value greater than
zero. Thus it will find enough small elements if they exist.

But how long does it take? The only nodes whose children we look at
are those < x, and at most k of these in total. Each have at most
visited two children, so we visit at most 3k nodes, for a total time
of O(k).
** 4.5 Mergesort: Sorting by Divide-and-Conquer
Mergesort is a great algorithm for sorting linked lists, because it
does not rely on random access to elements as does heapsort or
quicksort. Its primary disadvantage is the need for an auxilliary
buffer when sorting arrays. It is easy to merge two sorted linked
lists without using any extra space, by just rearranging the pointers.
However, to merge two sorted arrays (or portions of an array), we need
use a third array to store the result of the merge to avoid stepping
on the component arrays

** 4.9 Binary Search and Related Algorithms
#+begin_src c++
  int binary_search(item_type s[], item_type key, int low, int high)
  {
    int middle; /* index of middle element */
    if (low > high) return (-1); /* key not found */
    middle = (low+high)/2;
    if (s[middle] == key) return(middle);
    if (s[middle] > key)
      return (binary_search(s,key,low,middle-1));
    else
      return (binary_search(s,key,middle+1,high));
  }
#+end_src

*** Counting Occurrences
This algorithm runs inO(lgn+s), wheresis the number of occurrences of
the key. This can be as bad as linear if the entire array consists of
identical keys. A faster algorithm results by modifying binary search
to search for the boundary of the block containing k, instead of
kitself. Suppose we delete the equality test

~if (s[middle] == key) return(middle);~

from the implementation above and return the index =low= instead of
=−1= on each unsuccessful search. All searches will now be
unsuccessful, since there is no equality test. The search will proceed
to the right half whenever the key is compared to an identical array
element, eventually terminating at the *right boundary*. Repeating the
search after reversing the direction of the binary comparison will
lead us to the *left boundary*. Each search takes O(lgn) time, so we can
count the occurrences in logarithmic time regardless of the size of
the block.

*** One-Sided Binary Search
Now suppose we have an array A consisting of a run of 0’s, followed
by an unbounded run of 1’s, and would like to identify the exact
point of transition between them. Binary search on the array would
provide the transition point in lgn tests, if we had a bound non the
number of elements in the array. In the absence of such
a bound, we can test repeatedly at larger intervals (~A[1], A[2],
A[4], A[8], A[16],...~) until we find a first nonzero value. Now we
have a window containing the target and can proceed with binary
search. This /one-sided binary search/ finds the transition pointpusing at
most 2lgp comparisons, regardless of how large the array actually is.

*** Square and Other Roots
First, observe that the square root ofn≥1 must be at least 1 and at
most n. Let ~l = 1~ and ~r = n~. Consider the midpoint of this
interval, ~m=(l+r)/2~. How does m^2 compare to n? If n≥m^2 , then the
square root must be greater than m, so the algorithm repeats with
~l=m~. If n<m^2 , then the square root must be less than m, so the
algorithm repeats with ~r=m~. 

Suppose that we start with values l and r such that f(l)>0 and f(r)<0.
If f is a continuous function, there must exist a root between l and
r. Depending upon the sign of f(m), where ~m=(l+r)/2~, we can cut this
window containing the root in half with each test and stop soon as our
estimate becomes sufficiently accurate.
** 4.10 Divide-and-Conquer
divide-and-conquer recurrences of the form T(n)=aT(n/b)+f(n)

1. If $f(n) = O(n^{log_{b}^{a-\epsilon}})$ for some constant $\epsilon
   > 0$, then $T(n) = \Theta(n^{log_{b}^a})$.
2. If $f(n) = O(n^{log_{b}^{a}})$, then $T(n) =
   \Theta(n^{log_{b}^a}lgn)$.
3. If $f(n) = O(n^{log_{b}^{a+\epsilon}})$ for some constant $\epsilon
   > 0$ and if $af(n/b) \leq cf(n)$ for some $c<1$, then $T(n) =
   \Theta(f(n))$.

* Exercises
** 1
The Grinch is given the job of partitioning 2n players into two teams
of n players each. Each player has a numerical rating that measures
how good he/she is at the game. He seeks to divide the players as
unfairly as possible, so as to create the biggest possible talent
imbalance between team A and team B. Show how the Grinch can do the
job in O(nlogn) time.
** 2
For each of the following problems, give an algorithm that finds the
desired numbers within the given amount of time. To keep your answers
brief, feel free to use algorithms from the book as subroutines. For
the example,S={6,13,19,3,8}, 19−3 maximizes the difference, while 8−6
minimizes the difference.


(a) LetSbe anunsortedarray ofnintegers. Give an algorithm that finds the pair
x, y∈S that maximizes|x−y|. Your algorithm must run in O(n) worst-case
time.

(b) Let Sbe asorted array ofnintegers. Give an algorithm that finds
the pair x, y∈S that maximizes |x−y|. Your algorithm must run in O(1)
worst-case time.

(c) LetSbe anunsortedarray ofnintegers. Give an algorithm that finds
the pair x, y∈S that minimizes |x−y|, for x \neq y. Your algorithm must run
in O(nlogn) worst-case time.

(d) Let Sbe asorted array ofnintegers. Give an algorithm that finds the pair
x, y∈S that minimizes |x−y|,forx \neq y. Your algorithm must run in O(n)
worst-case time.
** 3
Take a sequence of 2nreal numbers as input. Design an O(nlogn)
algorithm that partitions the numbers intonpairs, with the property
that the partition minimizes the maximum sum of a pair. For example,
say we are given the numbers (1,3,5,9). The possible partitions are
((1,3),(5,9)), ((1,5),(3,9)), and ((1,9),(3,5)). The pair sums for
these partitions are (4,14), (6,12), and (10,8). Thus the third
partition has 10 as its maximum sum, which is the minimum over the
three partitions.
** 4
Assume that we are givennpairs of items as input, where the first item
is a and the second item is one of three colors (red, blue, or
yellow). Further assume that the items are sorted by number. Give
anO(n) algorithm to sort the items by color (all reds before all blues
before all yellows) such that the numbers for identical colors stay
sorted. For example: (1,blue), (3,red), (4,blue), (6,yellow), (9,red)
should become (3,red), (9,red), (1,blue), (4,blue), (6,yellow).
** 5
Themodeof a set of numbers is the number that occurs most frequently in the
set. The set (4,6,2,4,3,1) has a mode of 4. Give an efficient and correct algorithm
to compute the mode of a set of n numbers.




* cc


#+begin_src c++

#+end_src



