<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Algorithm Design Manual Chapter 4</title>
<!-- 2014-06-07 Sat 20:37 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../../assets/stylesheet.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Algorithm Design Manual Chapter 4</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Book Notes</a>
<ul>
<li><a href="#sec-1-1">4.3 Heapsort: Fast Sorting via Data Structures</a></li>
<li><a href="#sec-1-2">4.5 Mergesort: Sorting by Divide-and-Conquer</a></li>
<li><a href="#sec-1-3">4.9 Binary Search and Related Algorithms</a></li>
<li><a href="#sec-1-4">4.10 Divide-and-Conquer</a></li>
</ul>
</li>
<li><a href="#sec-2">Exercises</a>
<ul>
<li><a href="#sec-2-1">1</a></li>
<li><a href="#sec-2-2">2</a></li>
<li><a href="#sec-2-3">3</a></li>
<li><a href="#sec-2-4">4</a></li>
<li><a href="#sec-2-5">5</a></li>
<li><a href="#sec-2-6">6</a></li>
<li><a href="#sec-2-7">7</a></li>
<li><a href="#sec-2-8">8</a></li>
<li><a href="#sec-2-9">9</a></li>
<li><a href="#sec-2-10">10</a></li>
<li><a href="#sec-2-11">11</a></li>
<li><a href="#sec-2-12">12</a></li>
<li><a href="#sec-2-13">13</a></li>
<li><a href="#sec-2-14">14</a></li>
<li><a href="#sec-2-15">15</a></li>
<li><a href="#sec-2-16">16</a></li>
<li><a href="#sec-2-17">17</a></li>
</ul>
</li>
<li><a href="#sec-3">cc</a></li>
</ul>
</div>
</div>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book Notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">4.3 Heapsort: Fast Sorting via Data Structures</h3>
<div class="outline-text-3" id="text-1-1">
</div><ul class="org-ul"><li>Where in the Heap?<br  /><div class="outline-text-4" id="text-1-1-1">
<p>
Problem: Given an array-based heap on n elements and a real number x,
efficiently determine whether the kth smallest element in the heap is
greater than or equal to x. Your algorithm should be O(k) in the
worst-case, independent of the size of the heap. Hint: you do not have
to find the kth smallest element; you need only determine its
relationship to x.
</p>

<p>
Solution: There are at least two different ideas that lead to correct
but inefficient algorithms for this problem:
</p>

<ol class="org-ol">
<li>Call extract-minktimes, and test whether all of these are less
thanx. This explicitly sorts the firstkelements and so gives us
more information than the desired answer, but it takes O(klogn) time
to do so.
</li>
<li>The kth smallest element cannot be deeper than the kth level of the
heap, since the path from it to the root must go through elements
of decreasing value. Thus we can look at all the elements on the
first k levels of the heap, and count how many of them are less
thanx, stopping when we either find k of them or run out of
elements. This is correct, but takes O(min(n,2<sup>k</sup>-1)) time, since
the top k elements have 2<sup>k</sup>-1 elements.
</li>
</ol>

<p>
An O(k) solution can look at only k elements smaller than x, plus at
most O(k) elements greater than x. Consider the following recursive
procedure, called at the root with i= 1 with count=k:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">heap_compare</span>(<span style="color: #98fb98;">priority_queue</span> *<span style="color: #eedd82;">q</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>)
{
  <span style="color: #00ffff;">if</span> ((count &lt;= 0) || (i &gt; q-&gt;n)) <span style="color: #00ffff;">return</span>(count);
  <span style="color: #00ffff;">if</span> (q-&gt;q[i] &lt; x) {
    count = heap_compare(q, pq_young_child(i), count-1, x);
    count = heap_compare(q, pq_young_child(i)+1, count, x);
  }
  <span style="color: #00ffff;">return</span>(count);
}
</pre>
</div>

<p>
If the root of the min-heap is ≥ x, then no elements in the heap can
be less than x, as by definition the root must be the smallest
element. This procedure searches the children of all nodes of weight
smaller than x until either (a) we have found k of them, when it returns
0, or (b) they are exhausted, when it returns a value greater than
zero. Thus it will find enough small elements if they exist.
</p>

<p>
But how long does it take? The only nodes whose children we look at
are those &lt; x, and at most k of these in total. Each have at most
visited two children, so we visit at most 3k nodes, for a total time
of O(k).
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">4.5 Mergesort: Sorting by Divide-and-Conquer</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Mergesort is a great algorithm for sorting linked lists, because it
does not rely on random access to elements as does heapsort or
quicksort. Its primary disadvantage is the need for an auxilliary
buffer when sorting arrays. It is easy to merge two sorted linked
lists without using any extra space, by just rearranging the pointers.
However, to merge two sorted arrays (or portions of an array), we need
use a third array to store the result of the merge to avoid stepping
on the component arrays
</p>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">4.9 Binary Search and Related Algorithms</h3>
<div class="outline-text-3" id="text-1-3">
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">binary_search</span>(<span style="color: #98fb98;">item_type</span> <span style="color: #eedd82;">s</span>[], <span style="color: #98fb98;">item_type</span> <span style="color: #eedd82;">key</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">low</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">high</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">middle</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">index of middle element */</span>
  <span style="color: #00ffff;">if</span> (low &gt; high) <span style="color: #00ffff;">return</span> (-1); <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">key not found */</span>
  middle = (low+high)/2;
  <span style="color: #00ffff;">if</span> (s[middle] == key) <span style="color: #00ffff;">return</span>(middle);
  <span style="color: #00ffff;">if</span> (s[middle] &gt; key)
    <span style="color: #00ffff;">return</span> (binary_search(s,key,low,middle-1));
  <span style="color: #00ffff;">else</span>
    <span style="color: #00ffff;">return</span> (binary_search(s,key,middle+1,high));
}
</pre>
</div>
</div>

<ul class="org-ul"><li>Counting Occurrences<br  /><div class="outline-text-4" id="text-1-3-1">
<p>
This algorithm runs inO(lgn+s), wheresis the number of occurrences of
the key. This can be as bad as linear if the entire array consists of
identical keys. A faster algorithm results by modifying binary search
to search for the boundary of the block containing k, instead of
kitself. Suppose we delete the equality test
</p>

<p>
<code>if (s[middle] == key) return(middle);</code>
</p>

<p>
from the implementation above and return the index <code>low</code> instead of
<code>−1</code> on each unsuccessful search. All searches will now be
unsuccessful, since there is no equality test. The search will proceed
to the right half whenever the key is compared to an identical array
element, eventually terminating at the <b>right boundary</b>. Repeating the
search after reversing the direction of the binary comparison will
lead us to the <b>left boundary</b>. Each search takes O(lgn) time, so we can
count the occurrences in logarithmic time regardless of the size of
the block.
</p>
</div>
</li>
<li>One-Sided Binary Search<br  /><div class="outline-text-4" id="text-1-3-2">
<p>
Now suppose we have an array A consisting of a run of 0’s, followed
by an unbounded run of 1’s, and would like to identify the exact
point of transition between them. Binary search on the array would
provide the transition point in lgn tests, if we had a bound non the
number of elements in the array. In the absence of such
a bound, we can test repeatedly at larger intervals (<code>A[1], A[2],
A[4], A[8], A[16],...</code>) until we find a first nonzero value. Now we
have a window containing the target and can proceed with binary
search. This <i>one-sided binary search</i> finds the transition pointpusing at
most 2lgp comparisons, regardless of how large the array actually is.
</p>
</div>
</li>
<li>Square and Other Roots<br  /><div class="outline-text-4" id="text-1-3-3">
<p>
First, observe that the square root ofn≥1 must be at least 1 and at
most n. Let <code>l = 1</code> and <code>r = n</code>. Consider the midpoint of this
interval, <code>m=(l+r)/2</code>. How does m<sup>2</sup> compare to n? If n≥m<sup>2</sup> , then the
square root must be greater than m, so the algorithm repeats with
<code>l=m</code>. If n&lt;m<sup>2</sup> , then the square root must be less than m, so the
algorithm repeats with <code>r=m</code>. 
</p>

<p>
Suppose that we start with values l and r such that f(l)&gt;0 and f(r)&lt;0.
If f is a continuous function, there must exist a root between l and
r. Depending upon the sign of f(m), where <code>m=(l+r)/2</code>, we can cut this
window containing the root in half with each test and stop soon as our
estimate becomes sufficiently accurate.
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">4.10 Divide-and-Conquer</h3>
<div class="outline-text-3" id="text-1-4">
<p>
divide-and-conquer recurrences of the form T(n)=aT(n/b)+f(n)
</p>

<ol class="org-ol">
<li>If \(f(n) = O(n^{log_{b}^{a-\epsilon}})\) for some constant \(\epsilon
   > 0\), then \(T(n) = \Theta(n^{log_{b}^a})\).
</li>
<li>If \(f(n) = O(n^{log_{b}^{a}})\), then \(T(n) =
   \Theta(n^{log_{b}^a}lgn)\).
</li>
<li>If \(f(n) = O(n^{log_{b}^{a+\epsilon}})\) for some constant \(\epsilon
   > 0\) and if \(af(n/b) \leq cf(n)\) for some \(c<1\), then \(T(n) =
   \Theta(f(n))\).
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Exercises</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">1</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The Grinch is given the job of partitioning 2n players into two teams
of n players each. Each player has a numerical rating that measures
how good he/she is at the game. He seeks to divide the players as
unfairly as possible, so as to create the biggest possible talent
imbalance between team A and team B. Show how the Grinch can do the
job in O(nlogn) time.
</p>

<p>
用个O(nlogn)的排序算法对2n个队根据实力排序，前n个作为一队，后n个作为一队。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">2</h3>
<div class="outline-text-3" id="text-2-2">
<p>
For each of the following problems, give an algorithm that finds the
desired numbers within the given amount of time. To keep your answers
brief, feel free to use algorithms from the book as subroutines. For
the example,S={6,13,19,3,8}, 19−3 maximizes the difference, while 8−6
minimizes the difference.
</p>


<p>
(a) Let S be an unsorted array of n integers. Give an algorithm that
finds the pair x, y∈S that maximizes|x−y|. Your algorithm must run in
O(n) worst-case time.
</p>

<p>
(b) Let S be a sorted array of n integers. Give an algorithm that finds
the pair x, y∈S that maximizes |x−y|. Your algorithm must run in O(1)
worst-case time.
</p>

<p>
(c) Let S be an unsorted array of n integers. Give an algorithm that finds
the pair x, y∈S that minimizes |x−y|, for x &ne; y. Your algorithm must run
in O(nlogn) worst-case time.
</p>

<p>
(d) Let S be a sorted array of n integers. Give an algorithm that finds the pair
x, y∈S that minimizes |x−y|, for x &ne; y. Your algorithm must run in O(n)
worst-case time.
</p>


<ul class="org-ul">
<li>(a) 扫描S一次获得最小和最大值.
</li>
<li>(b) 取首尾数。
</li>
<li>(c) O(nlogn)的算法排序，扫描排序好的S，获得最小差的相邻元素对。
</li>
<li>(d) 扫描排序好的S，获得最小差的相邻元素对。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">3</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Take a sequence of 2n real numbers as input. Design an O(nlogn)
algorithm that partitions the numbers intonpairs, with the property
that the partition minimizes the maximum sum of a pair. For example,
say we are given the numbers (1,3,5,9). The possible partitions are
((1,3),(5,9)), ((1,5),(3,9)), and ((1,9),(3,5)). The pair sums for
these partitions are (4,14), (6,12), and (10,8). Thus the third
partition has 10 as its maximum sum, which is the minimum over the
three partitions.
</p>

<ol class="org-ol">
<li>O(nlogn)的算法排序
</li>
<li><div class="org-src-container">

<pre class="src src-c++">start = 0;
end = 2n - 1;
<span style="color: #00ffff;">while</span> (start &lt; end) {
  pair(S[star], S[end]);
  start++;
  end--;
</pre>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">4</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Assume that we are given n pairs of items as input, where the first item
is a and the second item is one of three colors (red, blue, or
yellow). Further assume that the items are sorted by number. Give
an O(n) algorithm to sort the items by color (all reds before all blues
before all yellows) such that the numbers for identical colors stay
sorted. For example: (1,blue), (3,red), (4,blue), (6,yellow), (9,red)
should become (3,red), (9,red), (1,blue), (4,blue), (6,yellow).
</p>

<ol class="org-ol">
<li>创建3个分别存储red，blue，yellow的数组;
</li>
<li>扫描input，依次按颜色装入不同的数组;
</li>
<li>分别从red，blue，yellow的数组中输出结果。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">5</h3>
<div class="outline-text-3" id="text-2-5">
<p>
The mode of a set of numbers is the number that occurs most frequently
in the set. The set (4,6,2,4,3,1) has a mode of 4. Give an efficient
and correct algorithm to compute the mode of a set of n numbers.
</p>

<ul class="org-ul">
<li>O(nlogn): O(nlogn)排序，扫描Set一遍得到频率最大的数。
</li>
<li>O(n): 使用hash map扫描一遍存储数字频率，扫描hash map得到频率最大数。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">6</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Given two sets S1 and S2 (each of size n), and a number x, describe an
O(nlogn) algorithm for finding whether there exists a pair of
elements, one from S1 and one from S2, that add up to x. (For partial
credit, give a Θ(n<sup>2</sup>) algorithm for this problem.)
</p>

<ol class="org-ol">
<li>从S1中减去n，O(nlogn)排序S1和S2,然后能否找出相同的元素（binary search或扫描比较）。
</li>
<li>Sort and Scan
<div class="org-src-container">

<pre class="src src-sh">sort S1<span style="color: #00ffff;"> in</span> O(nlogn)
sort S2<span style="color: #00ffff;"> in</span> O(nlogn)
<span style="color: #eedd82;">begin</span> = 0;
<span style="color: #eedd82;">end</span> = n - 1;
<span style="color: #00ffff;">while</span> (begin &lt; n &amp;&amp; end &gt;=0) {
          <span style="color: #00ffff;">if</span> ((S1[begin] + S2[end]) &lt; X) {
                 begin++;
          }
          <span style="color: #00ffff;">else if</span> ((S1[begin] + S2[end]) &gt; X) {
                 end--;
          } <span style="color: #00ffff;">else</span> {
              <span style="color: #00ffff;">return </span><span style="color: #b0c4de;">true</span>;
          }
}
<span style="color: #00ffff;">return </span><span style="color: #b0c4de;">false</span>;
</pre>
</div>
</li>
<li>Binary Search
<ul class="org-ul">
<li>O(nlogn)排序S1
</li>
<li>X-S2[i]去binary search排序好的S1，是否找到元素。
</li>
</ul>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">7</h3>
<div class="outline-text-3" id="text-2-7">
<p>
Outline a reasonable method of solving each of the following problems.
Give the order of the worst-case complexity of your methods.
</p>

<ol class="org-ol">
<li>You are given a pile of thousands of telephone bills and thousands
of checks sent in to pay the bills. Find out who did not pay.
</li>

<li>You are given a list containing the title, author, call number and
publisher of all the books in a school library and another list of
30 publishers. Find out how many of the books in the library were
published by each company.
</li>

<li>You are given all the book checkout cards used in the campus
library during the past year, each of which contains the name of
the person who took out the book. Determine how many distinct
people checked out at least one book.
</li>
</ol>

<p>
都使用Hash Table，O(n)
</p>
</div>
</div>
<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">8</h3>
<div class="outline-text-3" id="text-2-8">
<p>
Given a set of S containing n real numbers, and a real number x. We
seek an algorithm to determine whether two elements of S exist whose
sum is exactly x.
</p>

<ul class="org-ul">
<li>Assume that S is unsorted. Give an O(nlogn) algorithm for the problem.
</li>
<li>Assume that S is sorted. Give an O(n) algorithm for the problem.
</li>
</ul>

<p>
(1):
Binary search
</p>
<div class="org-src-container">

<pre class="src src-sh">sort S<span style="color: #00ffff;"> in</span> O(nlogn);
<span style="color: #00ffff;">for</span> (int <span style="color: #eedd82;">i</span> = 0; i &lt; n; ++i) {
        binarysearch S[i]<span style="color: #00ffff;"> in</span> S[i+1,n]
}
</pre>
</div>

<p>
Scan
</p>
<div class="org-src-container">

<pre class="src src-sh">sort S<span style="color: #00ffff;"> in</span> O(nlogn);
<span style="color: #eedd82;">i</span> = 0;
<span style="color: #eedd82;">j</span> = n - 1;
<span style="color: #00ffff;">while</span> (i &lt; j) {
  <span style="color: #00ffff;">if</span> (s[i] + s[j] &lt; X) {
    i++;
  } <span style="color: #00ffff;">else if</span> (s[i] + s[j] &gt; X) {
    j--;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">break</span>;
  }
}
</pre>
</div>

<p>
(2)
</p>
<div class="org-src-container">

<pre class="src src-c++">i = 0;
j = n - 1;
<span style="color: #00ffff;">while</span> (i &lt; j) {
  <span style="color: #00ffff;">if</span> (s[i] + s[j] &lt; X) {
    i++;
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (s[i] + s[j] &gt; X) {
    j--;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">break</span>;
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">9</h3>
<div class="outline-text-3" id="text-2-9">
<p>
Give an efficient algorithm to compute the union of sets A and B,
where n = max( | A | , | B | ). The output should be an array of
distinct elements that form the union of the sets, such that they
appear more than once in the union.
</p>

<ul class="org-ul">
<li>Assume that A and B are unsorted. Give an O(nlogn) algorithm for the
problem.
</li>

<li>Assume that A and B are sorted. Give an O(n) algorithm for the problem.
</li>

<li>O(nlogn)对Ａ和Ｂ排序，然后用2的O(n)的方法。
</li>
<li>若Ａ和Ｂ以升序排序
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #b0c4de;">set</span> U to empty;
int <span style="color: #eedd82;">i</span> = 0;
int <span style="color: #eedd82;">j</span> = 0;
<span style="color: #00ffff;">while</span> (i &lt; na &amp;&amp; j &lt; na) {
  <span style="color: #00ffff;">if</span> (A[i] &lt; B[j]) {
    add A[i] into U;
    i++;
  } <span style="color: #00ffff;">else</span> (A[i] &gt; B[j]) {
      add B[j] into U;
      j++;
    }
  <span style="color: #00ffff;">else</span> {
     add A[i] into U;
    i++;
    j++;
  }
}
<span style="color: #00ffff;">if</span> (i &lt; na) {
  <span style="color: #00ffff;">while</span> (i &lt; na) {
    add A[i] into U;
    i++;
  }
<span style="color: #00ffff;">if</span> (j &lt; nb) {
  <span style="color: #00ffff;">while</span> (j &lt; nb) {
   add B[j] into U;
      j++;
    }
}
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-10" class="outline-3">
<h3 id="sec-2-10">10</h3>
<div class="outline-text-3" id="text-2-10">
<p>
Given a set S of n integers and an integer T, give an O(n<sup>k − 1</sup>logn)
algorithm to test whether k of the integers in S add up to T.
</p>

<ol class="org-ol">
<li>O(nlogn）对数组排序
</li>
<li>(k-1)个数的组合有n<sup>k-1</sup>，并计算k-1个数的和sum
</li>
<li>用binary search在数组中搜索T-sum
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-11" class="outline-3">
<h3 id="sec-2-11">11</h3>
<div class="outline-text-3" id="text-2-11">
<p>
Design an O(n) algorithm that, given a list of n elements, finds all
the elements that appear more than n / 2 times in the list. Then,
design an O(n) algorithm that, given a list of n elements, finds all
the elements that appear more than n / 4 times.
</p>

<p>
Hash Table 可以解决。或
</p>
</div>

<ul class="org-ul"><li>Find the elements that appear more than n / 2 times<br  /><div class="outline-text-4" id="text-2-11-1">
<p>
数组中最多有一个数超过重复n/2次，并且排序后的第ceiling(n/2)个数必定是这个数。
</p>
<ol class="org-ol">
<li>method1
<ul class="org-ul">
<li>利用<a href="http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/Median%20Problem.html#sec-5">BFPRT</a> 以O(n)的复杂度找到第ceiling(n/2)个小数;
</li>
<li>扫描数组，计数这个数的重复数是否大于n/2.
</li>
</ul>
</li>
<li>method2
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stack&gt;</span>
<span style="color: #00ffff;">using</span> <span style="color: #7fffd4;">std</span>::<span style="color: #98fb98;">stack</span>;

<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">FindMoreThanHalf</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">res</span>) {
  <span style="color: #98fb98;">stack</span>&lt;<span style="color: #98fb98;">int</span>&gt; <span style="color: #eedd82;">stk</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; n; ++i) {
    <span style="color: #00ffff;">if</span> (stk.empty()) {
      stk.push(array[i]);
    } <span style="color: #00ffff;">else</span> {
      <span style="color: #00ffff;">if</span> (stk.top() == array[i]) {
        stk.push(array[i]);
      } <span style="color: #00ffff;">else</span> {
        stk.pop();
      }
    }
  }
  <span style="color: #00ffff;">if</span> (stk.empty()) {
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
  }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">candidate</span> = stk.top();
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">times</span> = 0;
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; n; ++i) {
    <span style="color: #00ffff;">if</span> (array[i] == candidate) {
      times++;
    }
  }
  <span style="color: #00ffff;">if</span> (times &gt; n / 2) {
    *res = candidate;
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;
  }
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
}
</pre>
</div>
</li>
</ol>
</div>
</li>

<li>Find the elements that appear more than n / 4 times<br  /><div class="outline-text-4" id="text-2-11-2">
<ul class="org-ul">
<li>method1
<ol class="org-ol">
<li>利用<a href="http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/Median%20Problem.html#sec-5">BFPRT</a> 以O(n)的复杂度找到中间数，验证中中间数是否重复
n/4(O(n));
</li>
<li>以中间元素划分数组为两部分(O(n));
</li>
<li>在上下半部分n/2中重复n/4次数的元素，同第一个问题一样找(O(n));
</li>
</ol>
</li>
<li>method2
<ol class="org-ol">
<li>初始3个空的槽，想对应的槽的3个计数为0;
</li>
<li>对于数组中每个元素：
<ul class="org-ul">
<li>若等于其中任何一个槽中数，增加计数;
</li>
<li>若有槽空，放入这个槽，并计数为1;
</li>
<li>否则，对所有槽内数的计数减1
</li>
</ul>
</li>
<li>对槽内剩下的数，扫描一遍数组，计算它们重复次数是否符合要求。
</li>
</ol>
</li>
</ul>
</div>
</li></ul>
</div>
<div id="outline-container-sec-2-12" class="outline-3">
<h3 id="sec-2-12">12</h3>
<div class="outline-text-3" id="text-2-12">
<p>
Devise an algorithm for finding the k smallest elements of an unsorted
set of n integers in O(n + klogn).
</p>

<ol class="org-ol">
<li>O(n)的复杂度建立一个最小堆;
</li>
<li>连续k次取出最小值，最后得到第k个最小值。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-13" class="outline-3">
<h3 id="sec-2-13">13</h3>
<div class="outline-text-3" id="text-2-13">
<p>
You wish to store a set of n numbers in either a max-heap or a sorted
array. For each application below, state which data structure is
better, or if it does not matter. Explain your answers.
</p>

<ol class="org-ol">
<li>Want to find the maximum element quickly.
</li>
<li>Want to be able to delete an element quickly.
</li>
<li>Want to be able to form the structure quickly.
</li>
<li>Want to find the minimum element quickly.
</li>

<li>都开销O(1)。
</li>
<li>若知道删除的地方，max-heap花费O(logn)，sorted array花费O(n)。若不知道删除的地方，max-heap花费O(n)查找，删除花费O(logn); sorted
array binary search花费O(logn)，删除花费O(n)。
</li>
<li>max-heap花费O(n);sorted array花费O(logn)。
</li>
<li>max-heap花费O(n);sorted array花费O(1)。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-14" class="outline-3">
<h3 id="sec-2-14">14</h3>
<div class="outline-text-3" id="text-2-14">
<p>
Give an O(nlogk)-time algorithm that merges k sorted lists with a
total of n elements into one sorted list. (Hint: use a heap to speed
up the elementary O(kn)-time algorithm).
</p>
</div>
</div>
<div id="outline-container-sec-2-15" class="outline-3">
<h3 id="sec-2-15">15</h3>
<div class="outline-text-3" id="text-2-15">
<p>
(a) Give an efficient algorithm to find the second-largest key among n
keys. You can do better than 2n − 3 comparisons. (b) Then, give an
efficient algorithm to find the third-largest key among n keys. How
many key comparisons does your algorithm do in the worst case? Must
your algorithm determine which key is largest and second-largest in
the process?
</p>
</div>
</div>
<div id="outline-container-sec-2-16" class="outline-3">
<h3 id="sec-2-16">16</h3>
<div class="outline-text-3" id="text-2-16">
<p>
Use the partitioning idea of quicksort to give an algorithm that
finds the median element of an array of n integers in expected O(n)
time. (Hint: must you look at both sides of the partition?)
</p>
</div>
</div>
<div id="outline-container-sec-2-17" class="outline-3">
<h3 id="sec-2-17">17</h3>
<div class="outline-text-3" id="text-2-17">
<p>
The median of a set of n values is the \(\lceil n/2 \rceil\) th smallest
value.
</p>
<ol class="org-ol">
<li>Suppose quicksort always pivoted on the median of the current
sub-array. How many comparisons would Quicksort make then in the
worst case?
</li>

<li>Suppose quicksort were always to pivot on the \(\lceil n/3 \rceil\) th
smallest value of the current sub-array. How many comparisons would
be made then in the worst case?
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">cc</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">

<pre class="src src-c++"></pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2014-06-07 Sat 20:37</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.50.1 (<a href="http://orgmode.org">Org</a> mode 8.2.3a)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
