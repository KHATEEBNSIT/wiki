#+SETUPFILE: ~/.emacs.d/src/org-templates/level-3.org
#+TITLE: Algorithm Design Manual Chapter 3
#+OPTIONS: num:nil H:2


* Book Notes
** Contiguous vs. Linked Data Structures
+ Contiguously-allocated structuresare composed of single slabs of
  memory, and include arrays, matrices, heaps, and hash tables.
+ Linked data structuresare composed of distinct chunks of memory
  bound together bypointers, and include lists, trees, and graph
  adjacency lists.
** Arrays
Advantages of contiguously-allocated arrays include:
+ Constant-time access given the index– Because the index of each
  element maps directly to a particular memory address, we can access
  arbitrary data items instantly provided we know the index.
+ Space efficiency– Arrays consist purely of data, so no space is
  wasted with links or other formatting information. Further,
  end-of-record information is not needed because arrays are built
  from fixed-size records.
+ Memory locality– A common programming idiom involves iterating
  through all the elements of a data structure. Arrays are good for
  this because they exhibit excellent memory locality. Physical
  continuity between successive data accesses helps exploit the
  high-speedcache memory on modern computer architectures.

The downside of arrays is that we cannot adjust their size in the middle of
a program’s execution.

Actually, we can efficiently enlarge arrays as we need them, through the miracle
of dynamic arrays. The apparent waste in this procedure involves the recopying of the old contents
on each expansion. Thus, each of thenelements move only two times on average, and the total work
of managing the dynamic array is the sameO(n) as it would have been if a single
array of sufficient size had been allocated in advance! The primary thing lost using dynamic arrays is the guarantee that each array
access takes constant time /in the worst case/.
** Pointers and Linked Structures
The relative advantages of linked lists over static arrays include:
+ Overflow on linked structures can never occur unless the memory is
  actually full.
+ Insertions and deletions aresimplerthan for contiguous (array)
  lists.
+ With large records, moving pointers is easier and faster than moving
  the items themselves.

while the relative advantages of arrays include:
+ Linked structures require extra space for storing pointer fields.
+ Linked lists do not allow efficient random access to items.
+ Arrays allow better memory locality and cache performance than
  random pointer jumping.
* Exercises
** 1
A common problem for compilers and text editors is determining whether the
parentheses in a string are balanced and properly nested. For example, the string
((())())() contains properly nested pairs of parentheses, which the strings )()( and
()) do not. Give an algorithm that returns true if a string contains properly nested
and balanced parentheses, and false if otherwise. For full credit, identify the position
of the first offending parenthesis if the string is not properly
nested and balanced.

#+begin_src c++
#include <string>
using std::string;
#include <stack>
using std::stack;

bool BalancedParentheses(string parentheses, int *pos) {
  stack<int> stk;
  const int kLeftPar = 1;
  int i;
  for (i = 0; i < parentheses.size(); ++i) {
    if (parentheses[i] == '(') {
      stk.push(kLeftPar);
    } else {
      if (stk.empty()) {
        *pos = i;
        return false;
      }
      stk.pop();
    }
  }
  if (!stk.empty()) {
    *pos = --i;
    return false;
  }
  return true;
}
#+end_src
** 2
Write a program to reverse the direction of a given singly-linked list. In other
words, after the reversal all pointers should now point backwards. Your algorithm
should take linear time.

#+begin_src c++
struct Node {
  int value;
  struct Node *next;
  Node(int in_value, struct Node* in_next) : value(in_value), next(in_next) {
  }
};

void ReverseLinkedList(Node **head) {
  if (!head || *head == NULL) {
    return;
  }
  Node *prev, *p, *next;
  prev = *head;
  p = prev->next;
  prev->next = NULL;
  while (p != NULL) {
    next = p->next;
    p->next = prev;
    prev = p;
    p = next;
  }
  *head = prev;
}
#+end_src

** 3
We have seen how dynamic arrays enable arrays to grow while still achieving
constant-time amortized performance. This problem concerns extending dynamic
arrays to let them both grow and shrink on demand.

(a) Consider an underflow strategy that cuts the array size in half whenever the
array falls below half full. Give an example sequence of insertions and deletions
where this strategy gives a bad amortized cost.

(b) Then, give a better underflow strategy than that suggested above, one that
achieves constant amortized cost per deletion.

1. 容量是6的数组，当有3个元素是，insertion，然后delete。它不断收缩和扩
   展容量。
2. 当元素个数是总个数的1/4时，把容量收缩成1/2。

** 4
Design a dictionary data structure in which search, insertion, and deletion can
all be processed inO(1) time in the worst case. You may assume the set elements
are integers drawn from a finite set 1,2, .., n, and initialization
can take O(n)time.

因为元素个数是有限集合中的数，用bit array 表示每个数。
** 5
Find the overhead fraction (the ratio of data space over total space) for each
of the following binary tree implementations on n nodes:

(a) All nodes store data, two child pointers, and a parent pointer. The data field
requires four bytes and each pointer requires four bytes.

(b) Only leaf nodes store data; internal nodes store two child pointers. The data
field requires four bytes and each pointer requires two bytes.

1. 所有点都一样： 4/(4+4*3) = 1/4
2. 满树中，若页节点个数是n，那么内部节点个数是n-1,
   4*n/(4*n + 4*(n-1)) = n/(2n-1)

** 6
Describe how to modify any balanced tree data structure such that search,
insert, delete, minimum, and maximum still take O(logn) time each, but successor
and predecessor now take O(1) time each. Which operations have to be modified
to support this?

在树节点中添加指向successor和predecessor的指针。不影响操作search,
minimum, 和 maximum。只需在insert和delete操作相应更新指向successor和predecessor的指针。

** 7
Suppose you have access to a balanced dictionary data structure, which supports
each of the operations search, insert, delete, minimum, maximum, successor, and
predecessor in O(logn) time. Explain how to modify the insert and delete operations
so they still takeO(logn) but now minimum and maximum takeO(1) time. (Hint:
think in terms of using the abstract dictionary operations, instead of mucking about
with pointers and the like.)

#+begin_src c++

#+end_src
** 8
Design a data structure to support the following operations:
+ insert(x,T) – Insert item x into the set T.
+ delete(k,T)– Delete the kth smallest element from T.
+ member(x,T)–Return true iff x∈T.
All operations must take O(logn) time on an n-element set.

** 9
Aconcatenate operation takes two setsS1 andS2, where every key in S1
is smaller than any key in S2, and merges them together. Give an algorithm to
concatenate two binary search trees into one binary search tree. The worst-case
running time should beO(h), wherehis the maximal height of the two
trees.

** 10
In thebin-packing problem, we are givennmetal objects, each weighing between
zero and one kilogram. Our goal is to find the smallest number of bins that will
hold thenobjects, with each bin holding one kilogram at most.

• Thebest-fit heuristicfor bin packing is as follows. Consider the objects in the
order in which they are given. For each object, place it into the partially filled
bin with the smallest amount of extra roomafterthe object is inserted.. If
no such bin exists, start a new bin. Design an algorithm that implements the
best-fit heuristic (taking as input thenweightsw1,w2, ..., wnand outputting
the number of bins used) inO(nlogn)time.

• Repeat the above using theworst-fit heuristic, where we put the next object in
the partially filled bin with the largest amount of extra roomafterthe object
is inserted.

** 11
Suppose that we are given a sequence ofnvaluesx1,x2, ..., xn and seek to
quickly answer repeated queries of the form: giveni andj, find the smallest value
in xi,...,xj.

(a) Design a data structure that uses O(n^2) space and answers queries in O(1)
time.

(b) Design a data structure that usesO(n) space and answers queries inO(logn)
time. For partial credit, your data structure can useO(nlogn) space and have
O(logn) query time.

** 12
Suppose you are given an input setSofnnumbers, and a black box that if
given any sequence of real numbers and an integerkinstantly and correctly answers
whether there is a subset of input sequence whose sum is exactlyk. Show how to
use the black boxO(n) times to find a subset of S that adds up to k.

** 13
LetA[1..n]beanarrayofrealnumbers.Designanalgorithmtoperformany
sequence of the following operations:

• Add(i,y)– Add the valueyto theith number.

• Partial-sum(i)– Return the sum of the first i numbers

There are no insertions or deletions; the only change is to the values of the numbers.
Each operation should take O(logn) steps. You may use one additional array of size
nas a work space.

** 14
Extend the data structure of the previous problem to support insertions and
deletions. Each element now has both akeyand avalue. An element is accessed
by its key. The addition operation is applied to the values, but the elements are
accessed by its key. The Partial sum operation is different.
+ Add(k,y)– Add the valueyto the item with key k.
+ Insert(k,y)– Insert a new item with keyk and value y.
+ Delete(k)– Delete the item with key k.
+ Partial-sum(k)– Return the sum of all the elements currently in the
  set whose key is less than y,

The worst case running time should still be O(nlogn) for any sequence
of O(n) operations.

** 15
Design a data structure that allows one to search, insert, and delete an integer
X in O(1) time (i.e. , constant time, independent of the total number of integers
stored). Assume that 1≤X≤nand that there arem+nunits of space available,
wheremis the maximum number of integers that can be in the table at any one
time. (Hint: use two arraysA[1..n]andB[1..m].) You are not allowed to initialize
eitherAorB,asthatwouldtakeO(m)orO(n) operations. This means the arrays
are full of random garbage to begin with, so you must be very careful.

** 17
A Caesar shift (see Section 18.6 (page 641)) is a very simple class of ciphers for
secret messages. Unfortunately, they can be broken using statistical properties of
English. Develop a program capable of decrypting Caesar shifts of sufficiently long
texts.

** 18
What method would you use to look up a word in a dictionary?

** 19
Imagine you have a closet full of shirts. What can you do to organize your shirts
for easy retrieval?

** 20
Write a function to find the middle node of a singly-linked list.

** 21
Write a function to compare whether two binary trees are identical. Identical
trees have the same key value at each position and the same structure.

** 22
Write a program to convert a binary search tree into a linked list

** 23
Implement an algorithm to reverse a linked list. Now do it without
recursion.

** 24
What is the best data structure for maintaining URLs that have been visited by
a Web crawler? Give an algorithm to test whether a given URL has already been
visited, optimizing both space and time.

** 25
You are given a search string and a magazine. You seek to generate all the characters in search string by cutting them out from the magazine. Give an algorithm
to efficiently determine whether the magazine contains all the letters in the search
string.

** 26
Reverse the words in a sentence—i.e., “My name is Chris” becomes “Chris is
name My.” Optimize for time and space.

** 27
Determine whether a linked list contains a loop as quickly as possible without
using any extra storage. Also, identify the location of the loop.

** 28
You have an unordered arrayXofnintegers. Find the array Mcontaining
nelements whereMi is the product of all integers in Xexcept forXi. You may
not use division. You can use extra memory. (Hint: There are solutions
faster than O(n^2).)

** 29
Give an algorithm for finding an ordered word pair (e.g., “New York”) occurring
with the greatest frequency in a given webpage. Which data structures would you
use? Optimize both time and space.





* cc


#+begin_src c++

#+end_src



