#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: Programming Pearls: Column1
#+OPTIONS: num:nil H:2

* book notes
** The Bitmap Data Structure
这个数据结构用来表明在有限域中的一个密集集合，当集合中每个元素最多出现
一次且没有其他数据与这些元素相关。即使这些情况得不到满足（比如，当有多个相同
元素或其他附加数据），一个来自有限域的键能被在一个复杂数据表中用来做索
引。
#+begin_src c++
#include <cstdio>
#define BITSPERINTEGER 32
#define SHIFT 5
#define MASK 0x1F
#define MAX_BITS 10000000

int array[1 + MAX_BITS / BITSPERINTEGER];

void set_bit(int i) {
  array[i >> SHIFT] |= (1 << (i & MASK));
}

void clr_bit(int i) {
  array[i >> SHIFT] &= ~(1 << (i & MASK));
}

int test_bit(int i) {
  return array[i >> SHIFT] & (1 << (i & MASK));
}

int main(int argc, char *argv[]) {
  int i;
  for (i = 0; i < MAX_BITS; ++i) {
    clr_bit(i);
  }
  while (scanf("%d", &i) != EOF) {
    set_bit(i);
  }
  for (i = 0; i < MAX_BITS; ++i) {
    if (test_bit(i)) {
      printf("%d\n", i);
    }
  }
  return 0;
}
#+end_src
* Problems
** 1
如果内存足够大，如何用库实现排序算法。

#+begin_src c++
#include <cstdlib>
#include <cstdio>

int comp(const void *a, const void *b) {
  return (*reinterpret_cast<const int *>(a) -
          *reinterpret_cast<const int *>(b));
}

int main(int argc, char *argv[]) {
  int n = 0;
  int array[10000];
  while (scanf("%d", &array[n]) != EOF) {
    ++n;
  }
  qsort(array, n, sizeof(int), comp);
  for (int i = 0; i < n; ++i) {
      printf("%d\n", array[i]);
  }
  return 0;
}

#+end_src
** 2
如何使用bit操作来实现bit数组？

#+begin_src c++
#define BITSPERINTEGER 32
#define SHIFT 5
#define MASK 0x1F
#define MAX_BITS 10000000

int array[1 + MAX_BITS / BITSPERINTEGER];

void set_bit(int i) {
  array[i >> SHIFT] |= (1 << (i & MASK));
}

void clr_bit(int i) {
  array[i >> SHIFT] &= ~(1 << (i & MASK));
}

int test_bit(int i) {
  return array[i >> SHIFT] & (1 << (i & MASK));
}
#+end_src
** 4
如何在0到n-1间随机生成k个唯一的随机整数？
#+begin_src c++

#+end_src

类似于洗牌问题或不知道n时，选取随机数：
[[http://wiki.dreamrunner.org/public_html/Algorithms/Theory%20of%20Algorithms/Fisher%E2%80%93Yates%20shuffle.html][Fisher–Yates shuffle]]
** 5

* cc

#+begin_src c++

#+end_src

