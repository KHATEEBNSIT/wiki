#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: Android App
#+OPTIONS: num:nil H:2


* set up development environment
** Download the Android SDK.
** Install the ADT plugin for Eclipse (if youâ€™ll use the Eclipse IDE).
** Download the latest SDK tools and platforms using the SDK Manager.
http://developer.android.com/training/basics/firstapp/index.html
the ADT Bundle includes everything you need to begin developing apps:

+ Eclipse + ADT plugin
+ Android SDK Tools
+ Android Platform-tools
+ The latest Android platform
+ The latest Android system image for the emulator
** add PATH
 Add the platform-tools/ as well as the tools/ directory to your PATH
 environment variable.
* a few directories and files in the Android project
** AndroidManifest.xml
The manifest file describes the fundamental characteristics of the app
and defines each of its components. 
** src/
Directory for your app's main source files.
*** drawable-hdpi/
Directory for drawable objects (such as bitmaps) that are designed for
high-density (hdpi) screens. Other drawable directories contain assets
designed for other screen densities.

*** layout/
Directory for files that define your app's user interface.
*** values/
Directory for other various XML files that contain a collection of
resources, such as string and color definitions.




* Managing Projects
http://developer.android.com/tools/projects/index.html
 There are three types of projects, and they all share the same
 general structure but differ in function:
+ Android Projects
+ Test Projects
+ Library Projects These projects contain shareable Android source
  code and resources that you can reference in Android projects. This
  is useful when you have common code that you want to reuse. Library
  projects cannot be installed onto a device, however, they are pulled
  into the .apk file at build time.
** Android Projects
The following directories and files comprise an Android project:

+ src/ Contains your stub Activity file, which is stored at
  src/your/package/namespace/ActivityName.java. All other source code
  files (such as .java or .aidl files) go here as well.

+ bin Output directory of the build. This is where you can find the
  final .apk file and other compiled resources.

+ jni Contains native code sources developed using the Android NDK.
  For more information, see the Android NDK documentation.

+ gen/ Contains the Java files generated by ADT, such as your R.java file and interfaces created from AIDL files.
+ assets/ This is empty. You can use it to store raw asset files. Files that you save here are compiled into an .apk file as-is, and the original filename is preserved. You can navigate this directory in the same way as a typical file system using URIs and read files as a stream of bytes using the the AssetManager. For example, this is a good location for textures and game data.
+ res/ Contains application resources, such as drawable files, layout files, and string values. See Application Resources for more information.
    + anim/ For XML files that are compiled into animation objects. See the Animation resource type.
    + color/ For XML files that describe colors. See the Color Values resource type.
    + drawable/ For bitmap files (PNG, JPEG, or GIF), 9-Patch image
      files, and XML files that describe Drawable shapes or a Drawable
      objects that contain multiple states (normal, pressed, or
      focused). See the Drawable resource type.

    + layout/ XML files that are compiled into screen layouts (or part of a screen). See the Layout resource type.
    + menu/ For XML files that define application menus. See the Menus resource type.
    + raw/ For arbitrary raw asset files. Saving asset files here instead of in the assets/ directory only differs in the way that you access them. These files are processed by aapt and must be referenced from the application using a resource identifier in the R class. For example, this is a good place for media, such as MP3 or Ogg files.
    + values/ For XML files that are compiled into many kinds of resource. Unlike other resources in the res/ directory, resources written to XML files in this folder are not referenced by the file name. Instead, the XML element type controls how the resources is defined within them are placed into the R class.
    + xml/ For miscellaneous XML files that configure application components. For example, an XML file that defines a PreferenceScreen, AppWidgetProviderInfo, or Searchability Metadata. See Application Resources for more information about configuring these application components.
+ libs/ Contains private libraries.
+ AndroidManifest.xml The control file that describes the nature of the application and each of its components. For instance, it describes: certain qualities about the activities, services, intent receivers, and content providers; what permissions are requested; what external libraries are needed; what device features are required, what API Levels are supported or required; and others. See the AndroidManifest.xml documentation for more information
+ project.properties This file contains project settings, such as the build target. This file is integral to the project, so maintain it in a source revision control system. To edit project properties in Eclipse, right-click the project folder and select Properties.
+ local.properties Customizable computer-specific properties for the build system. If you use Ant to build the project, this contains the path to the SDK installation. Because the content of the file is specific to the local installation of the SDK, the local.properties should not be maintained in a source revision control system. If you use Eclipse, this file is not used.
+ ant.properties Customizable properties for the build system. You can edit this file to override default build settings used by Ant and also provide the location of your keystore and key alias so that the build tools can sign your application when building in release mode. This file is integral to the project, so maintain it in a source revision control system. If you use Eclipse, this file is not used.
+ build.xml The Ant build file for your project. This is only applicable for projects that you build with Ant.




** Library Projects
However, a library project differs from an standard Android
application project in that you cannot compile it directly to its own
.apk and run it on an Android device. Similarly, you cannot export the
library project to a self-contained JAR file, as you would do for a
true library. Instead, you must compile the library indirectly, by
referencing the library in the dependent application and building that
application

** Test Projects
Test projects contain Android applications that you write using the
Testing and Instrumentation framework. The framework is an extension
of the JUnit test framework and adds access to Android system objects.
The file structure of a test project is the same as an Android
project.

* Managing the Activity Lifecycle
http://developer.android.com/training/basics/activity-lifecycle/index.html

** Recreating an Activity
Caution: Your activity will be destroyed and recreated each time the
user rotates the screen. When the screen changes orientation, the
system destroys and recreates the foreground activity because the
screen configuration has changed and your activity might need to load
alternative resources (such as the layout).

To save additional data about the activity state, you must override
the onSaveInstanceState() callback method. The system calls this
method when the user is leaving your activity and passes it the Bundle
object that will be saved in the event that your activity is destroyed
unexpectedly. If the system must recreate the activity instance later,
it passes the same Bundle object to both the onRestoreInstanceState()
and onCreate() methods.

Instead of restoring the state during onCreate() you may choose to
implement onRestoreInstanceState(), which the system calls after the
onStart() method. The system calls onRestoreInstanceState() only if
there is a saved state to restore, so you do not need to check whether
the Bundle is null

* Supporting Different Devices
** Supporting Different Languages
*** Create Locale Directories and String Files
To add support for more languages, create additional values
directories inside res/ that include a hyphen and the ISO country code
at the end of the directory name. For example, values-es/ is the
directory containing simple resourcess for the Locales with the
language code "es". Android loads the appropriate resources according
to the locale settings of the device at run time.

In your source code, you can refer to a string resource with the
syntax R.string.<string_name>. There are a variety of methods that
accept a string resource this way.

#+begin_src java
// Get a string resource from your app's Resources
String hello = getResources().getString(R.string.hello_world);

// Or supply a string resource to a method that requires a string
TextView textView = new TextView(this);
textView.setText(R.string.hello_world);
#+end_src

In other XML files, you can refer to a string resource with the syntax
@string/<string_name> whenever the XML attribute accepts a string
value.

#+begin_src sh
<TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/hello_world" />
#+end_src


** Supporting Different Screens
Android categorizes device screens using two general properties: size
and density. 


+ There are four generalized sizes: small, normal, large, xlarge
+ And four generalized densities: low (ldpi), medium (mdpi), high
  (hdpi), extra high (xhdpi)

*** Create Different Layouts
 Each layout should be saved into the appropriate resources directory,
 named with a -<screen_size> suffix. For example, a unique layout for
 large screens should be saved under res/layout-large/.

As another example, here's a project with an alternative layout for landscape orientation:
#+begin_src sh
MyProject/
    res/
        layout/
            main.xml
        layout-land/
            main.xml
#+end_src
*** Create Different Bitmaps
To generate these images, you should start with your raw resource in vector format and generate the images for each density using the following size scale:

+ xhdpi: 2.0
+ hdpi: 1.5
+ mdpi: 1.0 (baseline)
+ ldpi: 0.75

This means that if you generate a 200x200 image for xhdpi devices, you
should generate the same resource in 150x150 for hdpi, 100x100 for
mdpi, and 75x75 for ldpi devices.

** Supporting Different Platform Versions
*** Specify Minimum and Target API Levels
The AndroidManifest.xml file describes details about your app and
identifies which versions of Android it supports. Specifically, the
minSdkVersion and targetSdkVersion attributes for the <uses-sdk
element identify the lowest API level with which your app is
compatible and the highest API level against which youâ€™ve designed
and tested your app.
#+begin_src sh
<manifest xmlns:android="http://schemas.android.com/apk/res/android" ... >
    <uses-sdk android:minSdkVersion="4" android:targetSdkVersion="15" />
    ...
</manifest>
#+end_src
*** Check System Version at Runtime

#+begin_src java
private void setUpActionBar() {
    // Make sure we're running on Honeycomb or higher to use ActionBar APIs
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
        ActionBar actionBar = getActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
    }
}
#+end_src

*** Use Platform Styles and Themes
To make your activity look like a dialog box:

<activity android:theme="@android:style/Theme.Dialog">

To make your activity have a transparent background:

<activity android:theme="@android:style/Theme.Translucent">
To apply your own custom theme defined in /res/values/styles.xml:

<activity android:theme="@style/CustomTheme">
To apply a theme to your entire app (all activities), add the android:theme attribute to the <application> element:

<application android:theme="@style/CustomTheme">
For more about creating and using themes, read the Styles and Themes
guide.

* Building a Dynamic UI with Fragments
** Using the Support Library
Update your manifest file to set the minimum API level to 4 and the target API level to the latest release:

<uses-sdk android:minSdkVersion="4" android:targetSdkVersion="15" />
Warning: To be sure that you don't accidentally use new APIs on an older system version, be certain that you import the Fragment class and related APIs from the android.support.v4.app package:

#+begin_src java
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
#+end_src

** Creating a Fragment
** Building a Flexible UI
*** Add a Fragment to an Activity at Runtime
To perform a transaction such as add or remove a fragment, you must
use the FragmentManager to create a FragmentTransaction, which
provides APIs to add, remove, replace, and perform other fragment
transactions.

Inside your activity, call getSupportFragmentManager() to get a FragmentManager using the Support Library APIs. Then call beginTransaction() to create a FragmentTransaction and call add() to add a fragment.

You can perform multiple fragment transaction for the activity using
the same FragmentTransaction. When you're ready to make the changes,
you must call commit().
*** Replace One Fragment with Another
To allow the user to navigate backward through the fragment
transactions, you must call addToBackStack() before you commit the
FragmentTransaction.
** Communicating with Other Fragments
*** Define an Interface
To allow a Fragment to communicate up to its Activity, you can define
an interface in the Fragment class and implement it within the
Activity. The Fragment captures the interface implementation during
its onAttach() lifecycle method and can then call the Interface
methods in order to communicate with the Activity.

*** Implement the Interface
In order to receive event callbacks from the fragment, the activity
that hosts it must implement the interface defined in the fragment
class.
*** Deliver a Message to a Fragment
The host activity can deliver messages to a fragment by capturing the
Fragment instance with findFragmentById(), then directly call the
fragment's public methods.

* Saving Data
** Saving Key-Value Sets






* Activities
** Fragments
** Loaders
** Tasks and Back Stack

* Providing Resources
http://developer.android.com/guide/topics/resources/providing-resources.html

* Handling Runtime Changes
http://developer.android.com/guide/topics/resources/runtime-changes.html


* Localization
http://developer.android.com/guide/topics/resources/localization.html

* Layouts
http://developer.android.com/guide/topics/ui/declaring-layout.html

* Styles and Themes
http://developer.android.com/guide/topics/ui/themes.html
* Data Storage
http://developer.android.com/guide/topics/data/index.html
** Storage Options
** Data Backup
** App Install Location

* Design
** Iconography

* Testing
http://developer.android.com/tools/testing/index.html


* other component
** social
http://sharesdk.cn/

* FAQ
** permission denied: ant
folder =adt-bundle-linux-x86-20130219/sdk/tools/ant= 

** Description Resource Path Location Type Unexpected namespace prefix "xmlns" found for tag RelativeLayout activity_a.xml
The codes were running absolutely fine in the past but now they are showing these errors....

I found a very simple solution, doesn't require any code changes (Addition, edit or deletion).

Go to the Project Tab at the tab Click on the tab Select the
"Clean...." from the list


