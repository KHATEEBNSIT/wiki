#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: Linux Netfilter and Traffic Control
#+OPTIONS: num:nil H:2


* Netfilter and iptables homepage
+ netfilter: http://www.netfilter.org/index.html
+ iptables: http://www.netfilter.org/projects/iptables/index.html
* Overview
[[http://en.wikipedia.org/wiki/Netfilter][Netfilter]] is a framework inside the Linux kernel which offers
flexibility for various networking-related operations to be
implemented in form of customized handlers. Netfilter offers various
options for packet filtering, network address translation, and port
translation.

Its components:

[[./Files/Netfilter-components.svg]]

And the flow of network packets through the Netfilter:

[[./Files/Netfilter-packet-flow.svg]]

* Netfilter Hooks in the Linux Kernel
** Netfilter places
从上网络包发送接受流程图中看出,可以在不同的地方注册Nefilter的hook函数.由
如下定义:

#+begin_src c
enum nf_inet_hooks {
	NF_INET_PRE_ROUTING,
	NF_INET_LOCAL_IN,
	NF_INET_FORWARD,
	NF_INET_LOCAL_OUT,
	NF_INET_POST_ROUTING,
	NF_INET_NUMHOOKS
};
#+end_src
+ =NF_INET_PRE_ROUTING=: incoming packets pass this hook in the
  =ip_rcv()= (=linux/net/ipv4/ip_input.c=) function before they are
  processed by the routing code.
+ =NF_INET_LOCAL_IN=: all incoming packets addressed to the local
  computer pass this hook in the function =ip_local_deliver()=.
+ =NF_INET_FORWARD=: incoming packets are passed this hook in the
  function =ip_forwared()=.
+ =NF_INET_LOCAL_OUT=: all outgoing packets created in the local
  computer pass this hook in the function =ip_build_and_send_pkt()=.
+ =NF_INET_POST_ROUTING=: this hook in the ip_finish_output() function
  before they leave the computer.

** Register the hooks
kernel 提供如下函数来注册和解除hook函数.
#+begin_src c
int nf_register_hook(struct nf_hook_ops *reg);
void nf_unregister_hook(struct nf_hook_ops *reg);
int nf_register_hooks(struct nf_hook_ops *reg, unsigned int n);
void nf_unregister_hooks(struct nf_hook_ops *reg, unsigned int n);
#+end_src

其中 =nf_hook_ops= 结构如下:
#+begin_src c
struct nf_hook_ops
{
	struct list_head list;

	/* User fills in from here down. */
	nf_hookfn *hook;
	struct module *owner;
	u_int8_t pf;
	unsigned int hooknum;
	/* Hooks are ordered in ascending priority. */
	int priority;
};
#+end_src

** hook functions
其中hook函数由 =nf_hookfn *hook= 指定,其函数声明如下:
#+begin_src c
typedef unsigned int nf_hookfn(unsigned int hooknum,
			       struct sk_buff *skb,
			       const struct net_device *in,
			       const struct net_device *out,
			       int (*okfn)(struct sk_buff *));
#+end_src

它返回如下结果之一:

#+begin_src c
// <linux/netfilter.h>
#define NF_DROP 0
#define NF_ACCEPT 1
#define NF_STOLEN 2
#define NF_QUEUE 3
#define NF_REPEAT 4
#define NF_STOP 5
#define NF_MAX_VERDICT NF_STOP
#+end_src

** =pf=
=pf= (protocol family) is the identifier of the protocol family.

#+begin_src c
enum {
	NFPROTO_UNSPEC =  0,
	NFPROTO_IPV4   =  2,
	NFPROTO_ARP    =  3,
	NFPROTO_BRIDGE =  7,
	NFPROTO_IPV6   = 10,
	NFPROTO_DECNET = 12,
	NFPROTO_NUMPROTO,
};
#+end_src
** =hooknum=
This is the hook identifier. All valid identifiers for each
protocol family are defined in a header file.

for example =<linux/netfilter_ipv4.h>=:

#+begin_src c
/* IP Hooks */
/* After promisc drops, checksum checks. */
#define NF_IP_PRE_ROUTING	0
/* If the packet is destined for this box. */
#define NF_IP_LOCAL_IN		1
/* If the packet is destined for another interface. */
#define NF_IP_FORWARD		2
/* Packets coming from a local process. */
#define NF_IP_LOCAL_OUT		3
/* Packets about to hit the wire. */
#define NF_IP_POST_ROUTING	4
#define NF_IP_NUMHOOKS		5
#+end_src
** =priority=
This is the priority of the hook. All valid identifiers for each
protocol family are defined in a header file.

for example =<linux/netfilter_ipv4.h>=:
#+begin_src c
enum nf_ip_hook_priorities {
	NF_IP_PRI_FIRST = INT_MIN,
	NF_IP_PRI_CONNTRACK_DEFRAG = -400,
	NF_IP_PRI_RAW = -300,
	NF_IP_PRI_SELINUX_FIRST = -225,
	NF_IP_PRI_CONNTRACK = -200,
	NF_IP_PRI_MANGLE = -150,
	NF_IP_PRI_NAT_DST = -100,
	NF_IP_PRI_FILTER = 0,
	NF_IP_PRI_SECURITY = 50,
	NF_IP_PRI_NAT_SRC = 100,
	NF_IP_PRI_SELINUX_LAST = 225,
	NF_IP_PRI_CONNTRACK_CONFIRM = INT_MAX,
	NF_IP_PRI_LAST = INT_MAX,
};
#+end_src



#+begin_src c
enum {
	NFPROTO_UNSPEC =  0,
	NFPROTO_IPV4   =  2,
	NFPROTO_ARP    =  3,
	NFPROTO_BRIDGE =  7,
	NFPROTO_IPV6   = 10,
	NFPROTO_DECNET = 12,
	NFPROTO_NUMPROTO,
};
#+end_src
* Netfilter hooks example
在 =NF_INET_LOCAL_IN= 处注册一个hook函数,打印包的m源和目的MAC地址和IP
地址. [[./Files/nf_test_module.zip][源码包下载]].

#+begin_src c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/types.h>
#include <linux/skbuff.h>
#include <linux/ip.h>
#include <linux/udp.h>
#include <linux/tcp.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>


MODULE_LICENSE("GPLv3");
MODULE_AUTHOR("SHI");
MODULE_DESCRIPTION("Netfliter test");

static unsigned int
nf_test_in_hook(unsigned int hook, struct sk_buff *skb, const struct net_device *in,
                const struct net_device *out, int (*okfn)(struct sk_buff*));

static struct nf_hook_ops nf_test_ops[] __read_mostly = {
  {
    .hook = nf_test_in_hook,
    .owner = THIS_MODULE,
    .pf = NFPROTO_IPV4,
    .hooknum = NF_INET_LOCAL_IN,
    .priority = NF_IP_PRI_FIRST,
  },
};
    
void hdr_dump(struct ethhdr *ehdr) {
    printk("[MAC_DES:%x,%x,%x,%x,%x,%x" 
           "MAC_SRC: %x,%x,%x,%x,%x,%x Prot:%x]\n",
           ehdr->h_dest[0],ehdr->h_dest[1],ehdr->h_dest[2],ehdr->h_dest[3],
           ehdr->h_dest[4],ehdr->h_dest[5],ehdr->h_source[0],ehdr->h_source[1],
           ehdr->h_source[2],ehdr->h_source[3],ehdr->h_source[4],
           ehdr->h_source[5],ehdr->h_proto);
}

#define NIPQUAD(addr) \
	((unsigned char *)&addr)[0], \
	((unsigned char *)&addr)[1], \
	((unsigned char *)&addr)[2], \
	((unsigned char *)&addr)[3]
#define NIPQUAD_FMT "%u.%u.%u.%u"

static unsigned int
nf_test_in_hook(unsigned int hook, struct sk_buff *skb, const struct net_device *in,
                const struct net_device *out, int (*okfn)(struct sk_buff*)) {
  struct ethhdr *eth_header;
  struct iphdr *ip_header;
  eth_header = (struct ethhdr *)(skb_mac_header(skb));
  ip_header = (struct iphdr *)(skb_network_header(skb));
  hdr_dump(eth_header);
  printk("src IP:'"NIPQUAD_FMT"', dst IP:'"NIPQUAD_FMT"' \n",
         NIPQUAD(ip_header->saddr), NIPQUAD(ip_header->daddr));
  return NF_ACCEPT;
}

static int __init init_nf_test(void) {
  int ret;
  ret = nf_register_hooks(nf_test_ops, ARRAY_SIZE(nf_test_ops));
  if (ret < 0) {
    printk("register nf hook fail\n");
    return ret;
  }
  printk(KERN_NOTICE "register nf test hook\n");
  return 0;
}

static void __exit exit_nf_test(void) {
  nf_unregister_hooks(nf_test_ops, ARRAY_SIZE(nf_test_ops));
}

module_init(init_nf_test);
module_exit(exit_nf_test);
#+end_src

=dmesg | tail= 后的结果:
#+begin_src sh
[452013.507230] [MAC_DES:70,f3,95,e,42,faMAC_SRC: 0,f,fe,f6,7c,13 Prot:8]
[452013.507237] src IP:'10.6.124.55', dst IP:'10.6.124.54' 
[452013.944960] [MAC_DES:70,f3,95,e,42,faMAC_SRC: 0,f,fe,f6,7c,13 Prot:8]
[452013.944968] src IP:'10.6.124.55', dst IP:'10.6.124.54' 
[452014.960934] [MAC_DES:70,f3,95,e,42,faMAC_SRC: 0,f,fe,f6,7c,13 Prot:8]
[452014.960941] src IP:'10.6.124.55', dst IP:'10.6.124.54' 
[452015.476335] [MAC_DES:70,f3,95,e,42,faMAC_SRC: 0,f,fe,f6,7c,13 Prot:8]
[452015.476342] src IP:'10.6.124.55', dst IP:'10.6.124.54' 
[452016.023311] [MAC_DES:70,f3,95,e,42,faMAC_SRC: 0,f,fe,f6,7c,13 Prot:8]
[452016.023318] src IP:'10.6.124.55', dst IP:'10.6.124.54' 
#+end_src
* Traffic Control HOWTO
大多利用Netfilter来实现流的控制. 比较详细的文档是 [[http://www.lartc.org/lartc.html#LARTC.QDISC.TERMINOLOGY][Linux Advanced
Routing & Traffic Control HOWTO]] 和缩简版的 [[http://www.tldp.org/HOWTO/html_single/Traffic-Control-HOWTO/][Traffic Control HOWTO]].

这里针对流控制稍作分析和总结.


* IMQ
** imq device
#+begin_src sh
/net/imq.ko
#+end_src

** netfilter support IMQ
#+begin_src sh
net/ipv4/netfilter/ipt_IMQ.ko
net/ipv6/netfilter/ip6t_IMQ.ko
#+end_src

** iptables support IMQ
#+begin_src sh
iptables/libip6t_IMQ.so
iptables/libipt_IMQ.so
#+end_src

#+begin_src sh
# modprobe imq numdevs=2
# modprobe ipt_IMQ
# ifconfig imq0 up
# ifconfig imq1 up
#+end_src

#+begin_src sh
#!/bin/bash
modprobe imq numdevs=2
modprobe ipt_IMQ
ifconfig imq0 up
ifconfig imq1 up

tc qdisc del dev imq0 root 2>/dev/null 1>&2
tc qdisc del dev imq1 root 2>/dev/null 1>&2

#IMQ 0
tc qdisc add dev imq0 root handle 1: htb default 20

tc class add dev imq0 parent 1: classid 1:1 htb rate 2mbit burst 15k

tc class add dev imq0 parent 1:1 classid 1:10 htb rate 1mbit
tc class add dev imq0 parent 1:1 classid 1:20 htb rate 1mbit

tc qdisc add dev imq0 parent 1:10 handle 10: pfifo
tc qdisc add dev imq0 parent 1:20 handle 20: sfq

tc filter add dev imq0 parent 1:0 protocol ip prio 1 u32 match ip dst 192.168.228.30 flowid 1:10

iptables -t mangle -A PREROUTING -i eth0 -j IMQ --todev 0

#IMQ 1
tc qdisc add dev imq1 root handle 2: htb default 20

tc class add dev imq1 parent 2: classid 2:1 htb rate 10mbit burst 15k

tc class add dev imq1 parent 2:1 classid 2:10 htb rate 1mbit ceil 10mbit
tc class add dev imq1 parent 2:1 classid 2:20 htb rate 1mbit ceil 10mbit

tc qdisc add dev imq1 parent 2:10 handle 10: pfifo
tc qdisc add dev imq1 parent 2:20 handle 20: sfq

tc filter add dev imq1 parent 2:0 protocol ip prio 1 u32 match ip dst 192.168.228.30 flowid 2:10

iptables -t mangle -A POSTROUTING -o eth0 -j IMQ --todev 1
#+end_src

* More
[[http://ebtables.netfilter.org/br_fw_ia/br_fw_ia.html][+ ebtalbes]]
+ [[http://www.tldp.org/HOWTO/html_single/Traffic-Control-HOWTO/][Traffic Control HOWTO]] represents the collection, amalgamation and
  synthesis of the [[http://www.lartc.org/lartc.html#LARTC.QDISC.TERMINOLOGY][LARTC HOWTO]].
+ [[http://wiki.openwrt.org/doc/howto/packet.scheduler/packet.scheduler][Openwrt Network Traffic Control]]

* cc
#+begin_src c

#+end_src
