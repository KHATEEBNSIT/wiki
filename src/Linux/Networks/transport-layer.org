#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: Transport layer
#+OPTIONS: num:nil H:2

* UDP
在[[http://wiki.dreamrunner.org/public_html/Linux/Networks/network-layer.html][Network layer中]],  =ip_local_deliver= 把IP包发送往 transport layer.
=net/ipv4/udp.c= 中的  =udp_rcv= 进一步处理 UDP 数据报文包.相应的代码
流程如下.

[[./Files/udp-rcv.jpeg]]

=udp_rcv= 函数仅仅是 =__udp4_lib_rcv= 的一个封装,因为这代码与RFC3828中
定义的UDP-lite协议的实现所共享.

和其他协议层一样,函数的输入参数是socket buffer.一旦到这数据包是完整,需
要使用 =__udp4_lib_lookup= 找到侦听socket.链路参数能从UDP头中获取,它的
结果如下:

[[./Files/udp-structure.jpeg]]

+ ‘‘Source’’ 和 ‘‘Destination Port’’指定端口号,可接受的值从0
  到65.535(因为使用16字节.
+ ‘‘Length’是字节数总的长度(头部和数据).

UDP 包头在kernel中如下数据结构:

#+begin_src c
struct udphdr {
	__be16	source;
	__be16	dest;
	__be16	len;
	__sum16	check;
};
#+end_src

=net/ipv4/udp.c= 中的 =__udp4_lib_lookup= 使用来寻找这个包将要发送的
kernel内部的socket.当有侦听进程接受此包,代码使用hash方法从全局hash表
=udphash= 中找到 =sock= 结构的实例.如果不能找到相应的socket,它将发送一
个 /destination unreachable/ 信息给原系统,然后此包被丢弃.

#+begin_src c
icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);
#+end_src

这里需要 =sock= 结构来把transport层的数据传递到用户层应用程序,实际上,
在kernel中有2个数据结构来表示socket. =sock= 是network access layer的接
口,而 =socket= 是用户空间的链接点.这两个结构在之后[[http://wiki.dreamrunner.org/public_html/Linux/Networks/application-layer.html][Application Layer]]分
析.在此,我们感兴趣的是 =sock= 结构中用来传递数据到上层的方法.这需要允
许收到的数据被放到一个socket指定的等待队列中,并且通知接收进程有新的数
据到达.现在, =sock= 结构能缩略到如下简化版:

#+begin_src c
  // include/net/sock.h
  /* Short version */
  struct sock {
    wait_queue_head_t *sk_sleep;
    struct sk_buff_head sk_receive_queue;
    /* Callback */
    void (*sk_data_ready)(struct sock *sk, int bytes);
  }
#+end_src

=udp_rcv= 找到相应的 =sock= 实例后,进入函数 =udp_queue_rcv_skb=, 调用
=__udp_queue_rcv_skb= ,最后进入 =sock_queue_rcv_skb= 中,把包放入等待队
列.重要的流程如下:
1. 等待数据到达的进程通过socket sleep对其等待队列sleep.
2. 调用 =skb_queue_tail= 把socket buffer包插入到 =receive_queue= list
   的最后,这个list头在 =sock= 结构中.
3. =sk_data_ready= 指向的函数被调用来通知socket有新的数据到达.它唤醒等
   待此队列的所有sleep的进程.

* TCP
相对UDP,TCP提供更多功能.因此,它在kernel中的实现比较困难和复杂.谈及细节
问题可以占用整本书.面向连接的TCP通信模型支持安全数据流传输不仅在kernel
中需要更强的管理复杂,同时也需要进一步的操作,比如明示的连接创建通过设备
间的握手.

这里主要分析TCP协议的3个主要部分:连接建立,传送/发送包和连接终止.

TCP连接处于一个定义好的状态.所有状态和它们之间转换的规则如下:

<<tcp-transition>>
[[./Files/tcp-state-transition.jpeg]]

** TCP Headers
TCP的头部如下图:
[[
./Files/tcp-packet.jpeg]]

+ source和dest指定使用的端口号.
+ seq是序列号.指定TCP包在数据流中所处位置.
+ ack_seq是确认序列号.
+ doff是data offset的缩小,指定TCP头结构的长度.
+ urg(urgent), ack(acknowledgment), psh(push), rst(reset),
  syn(synchronize), 和fin是控制标识来检查,建立和终止连接.
+ window告诉连接同伴在接收缓冲将满前它能发送多少字节.
+ options是长度的其他附加选项.
+ 数据起始点是一个32-bit的位置.

头部以 =tcphadr= 结构实现,如下:

#+begin_src c
// <tcp.h>
struct tcphdr {
	__be16	source;
	__be16	dest;
	__be32	seq;
	__be32	ack_seq;
#if defined(__LITTLE_ENDIAN_BITFIELD)
	__u16	res1:4,
		doff:4,
		fin:1,
		syn:1,
		rst:1,
		psh:1,
		ack:1,
		urg:1,
		ece:1,
		cwr:1;
#elif defined(__BIG_ENDIAN_BITFIELD)
	__u16	doff:4,
		res1:4,
		cwr:1,
		ece:1,
		urg:1,
		ack:1,
		psh:1,
		rst:1,
		syn:1,
		fin:1;
#else
#error	"Adjust your <asm/byteorder.h> defines"
#endif	
	__be16	window;
	__sum16	check;
	__be16	urg_ptr;
}
#+end_src
** Receiving TCP Data
所有TCP行为(连接建立,关闭和数据传输)都通过发送拥有特定属性和不同标识的数据
包.在讨论状态转换前,先分析TCP数据如何传递到transport layer和头部在那裏
被分析.

=tcp_v4_rcv= 是被IP层处理完的包传入到TCP层的入口点.流程如下:

[[./Files/tcp-v4-rcv.jpeg]]

每个TCP socket在以下3个hash表之一中:
+ 完全连接的Sockets.
+ 等待连接(listen状态)的Sockets.
+ 正在建立连接(3次握手)的Sockets.

做做完对数据包的一些检查,并拷贝一些头信息到控制模块后,kernel找寻正在等
待处理此包的socket通过函数 =__inet_lookup= .这个函数进一步调用两个函数
来检查不同的hash表. =__inet_lookup_established= 试图返回一个连接好的
socket. 如果没有找到, =__inet_lookup_listener= 被调用来检查所有侦听中
的sockets.

两个函数都把连接的不同元素和起来计算hash值来找到对应的sock.当搜索侦听
socket时,一个score的方法被使用来找到最合适的候选sockets.

与UDP不同,当合适的sock结构找到工作并不完结.依赖于所处连接状态,有必要做
如上图的状态转换. =tcp_v4_do_rcv= 好比一个分路器,把代码路径基于socket
站柜台分成不同的分支.

** Three-Way Handshake
在TCP链路能被使用前,client和host之间必须建立连接.有两种不同的连接建立
方式: active和passive.

在建立连接前,client的socket处于CLOSED状态,而server的socket处理LISTEN状
态.

TCP 连接的建立过程通过交互3个TCP包完成,所以被熟知为"3次握手".如
[[tcp-transition][TCP状态图]]所示,如下的行为进行:
1. client发送SYN包给server告诉连接请求.client的socket状态从CLOSED转换
   到SYN_SENT.
2. server在侦听中的socket收到连接请求,然后返回SYN和ACK的包. server的
   socket状态从LISTEN转换到SYN_REC.
3. client的socket收到SYN/ACK包并转换到ESTABLISHED状态,表明连接已经建立.一
   个ACK包发给server.
4. server收到ACK包并转换到ESTABLISHED状态.两端的连接创建好,数据交互可
   以开始.

每个发送包都被赋予一个序列号,并且每个包的收到必须由接收方确认.如下一个
连接请求的例子:

#+begin_src sh
1 192.168.0.143 192.168.1.10 TCP 1025 > http [SYN] Seq=2895263889 Ack=0
2 192.168.1.10 192.168.0.143 TCP http > 1025 [SYN, ACK] Seq=2882478813 Ack=289526
3 192.168.0.143 192.168.1.10 TCP 1025 > http [ACK] Seq=2895263890 Ack=2882478814
#+end_src
** Passive Connection Establishment
主动建立连接不是由kernel自己发出,而是通过收到连接请求的SYN包所触发.因
此起始点是接收函数 =tcp_v4_rcv= ,如上节所述,此函数找到侦听socket并调用
=tcp_v4_do_rcv=, 它的代码流程如下:

[[./Files/tcp-v4-rcv-passive.jpeg]]

=tcp_v4_hnd_req= 被调用来进行网络层创建新连接所需要的一些初始化工作.实
际的状态转换在 =tcp_rcv_state_process= ,其中包含一长串case语句区分可能
的socket状态,并触发合适的转换函数.

socket状态定义如下:
#+begin_src c
  // include/net/tcp_states.h
  enum {
    TCP_ESTABLISHED = 1,
    TCP_SYN_SENT,
    TCP_SYN_RECV,
    TCP_FIN_WAIT1,
    TCP_FIN_WAIT2,
    TCP_TIME_WAIT,
    TCP_CLOSE,
    TCP_CLOSE_WAIT,
    TCP_LAST_ACK,
    TCP_LISTEN,
    TCP_CLOSING, /* Now a valid state */
    TCP_MAX_STATES /* Leave at the end! */
  };
#+end_src

如果socket状态处于 =TCP_LISTEN= 时, 调用
=icsk->icsk_af_ops->conn_request(sk, skb)= , IPv4时指向
=tcp_v4_conn_request= 而IPv6时指向 =tcp_v6_conn_request= .不进一步分析
这个函数,重要的是在此函数最后确认包被发送.第一次握手成功.

之后client接收到这个ACK包从通常路径 =tcp_rcv_state_process= , socket此
时状态是 =TCP_SYN_RECV= ,此时kernel主要任务是转换socket状态到
=TCP_ESTABLISHED=.
** Active Connection Establishment
主动建立连接由用户空间应用调用库函数 =connect= ,然后通过 =socketcall=
的系统调用到达kernel函数 =tcp_v4_connec=, 它的代码流程如下:

[[./Files/tcp-active-connection-establish.jpeg]]

函数开始于寻找到目的host的IP路由通过kernel提供的路由功能,当TCP头部被创
建并设置相应的值在socket buffer中后, =tcp_set_state(sk,
TCP_SYN_SENT);= ,socket状态从 =CLOSED= 转换到 =SYN_SENT=. 然后
=tcp_connect= 发送 SYN包到IP层从而到达client( =tcp_transmit_skb(sk,
buff, 1, sk->sk_allocation);= ). 并且 =inet_csk_reset_xmit_timer= 创建
一个计时器确保能重发包如果在一段时间内没有收到确认包.

现在client必须等到server确认SYN包的收到和确认连接请求的SYN包. 与通常的
TCP接收路径一样,之后到达 =tcp_rcv_state_process= 分状态处理,这里到
=tcp_rcv_synsent_state_process= 去处理. socket状态设置为 =ESTABLISHED=
,并且 =tcp_send_ack= 发送另外ACK包给server完成建立连接.

** Transmission of Data Packets
一旦连接建立好,数据就在设备间传递.但这个过程还是有点难处理的,因为TCP有
如下一些要求:
+ 字节流以一定顺序传递.
+ 丢失的包自动重传.
+ 数据流在各方向上独立控制并与主机速度匹配.

包的确认基于序列号.那么序列号是如何被设置的?当一个连接建立,一个随机数
产生, 使用 =drivers/char/random.c= 中的 =secure_tcp_sequence_number=
。

TCP使用累积确认机制.这意味着一个确认涵盖连续的整个范围的字节.这个ACK数
字确认收到所有数据到并包含比这个数字少1的字节.这个数字也表明下一个预期
的序列号.

这个机制是用来追踪丢失的包.TCP使用直接的重发机制,也就是,接收端不能要求
发送端重发丢失的包.责任就由发送短自动重发丢失的数据段,如果它在一段时间
内没有收到确认包.

那么这些过程如何在kernel中实现的了?这里认为连接已经建立,两端都处于
ESTABLISHED状态.
*** Receiving Packets
收包代码流程如下图,还是从 =tcp_v4_rcv= 开始,当包收到.

[[./Files/tcp-v4-rcv-connection.jpeg]]

到达 =tcp_v4_do_rcv= 后, 如果连接已经建立,一条快速路径被选择,而不是进
入核心状态转换函数,这个与其他状态不同,因为传送数据包是TCP中大部分的工
作,必须尽量的快.进入快速路径调用 =tcp_rcv_established=, 这里会分析包的
选项,是否容易解析,容易就进入快速路径稍微处理下就调用
=sk->sk_data_ready= 交给socket. 否则进入慢速路径,进一步处理之后再交给
socket.

包必须满足如下条件之一才能被分类为容易解析:
+ 

*** Sending Packets

[[./Files/tcp-sendmsg.jpeg]]


** Connection Termination

* file
#+begin_src c

#+end_src

* reference
** =__udp4_lib_rcv=
#+begin_src c
int __udp4_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,
		   int proto)
{
	struct sock *sk;
	struct udphdr *uh;
	unsigned short ulen;
	struct rtable *rt = skb_rtable(skb);
	__be32 saddr, daddr;
	struct net *net = dev_net(skb->dev);

	/*
	 *  Validate the packet.
	 */
	if (!pskb_may_pull(skb, sizeof(struct udphdr)))
		goto drop;		/* No space for header. */

	uh   = udp_hdr(skb);
	ulen = ntohs(uh->len);
	saddr = ip_hdr(skb)->saddr;
	daddr = ip_hdr(skb)->daddr;

	if (ulen > skb->len)
		goto short_packet;

	if (proto == IPPROTO_UDP) {
		/* UDP validates ulen. */
		if (ulen < sizeof(*uh) || pskb_trim_rcsum(skb, ulen))
			goto short_packet;
		uh = udp_hdr(skb);
	}

	if (udp4_csum_init(skb, uh, proto))
		goto csum_error;

	if (rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST))
		return __udp4_lib_mcast_deliver(net, skb, uh,
				saddr, daddr, udptable);

	sk = __udp4_lib_lookup_skb(skb, uh->source, uh->dest, udptable);

	if (sk != NULL) {
		int ret = udp_queue_rcv_skb(sk, skb);
		sock_put(sk);

		/* a return value > 0 means to resubmit the input, but
		 * it wants the return to be -protocol, or 0
		 */
		if (ret > 0)
			return -ret;
		return 0;
	}

	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
		goto drop;
	nf_reset(skb);

	/* No socket. Drop packet silently, if checksum is wrong */
	if (udp_lib_checksum_complete(skb))
		goto csum_error;

	UDP_INC_STATS_BH(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE);
	icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);

	/*
	 * Hmm.  We got an UDP packet to a port to which we
	 * don't wanna listen.  Ignore it.
	 */
	kfree_skb(skb);
	return 0;

short_packet:
	LIMIT_NETDEBUG(KERN_DEBUG "UDP%s: short packet: From %pI4:%u %d/%d to %pI4:%u\n",
		       proto == IPPROTO_UDPLITE ? "-Lite" : "",
		       &saddr,
		       ntohs(uh->source),
		       ulen,
		       skb->len,
		       &daddr,
		       ntohs(uh->dest));
	goto drop;

csum_error:
	/*
	 * RFC1122: OK.  Discards the bad packet silently (as far as
	 * the network is concerned, anyway) as per 4.1.3.4 (MUST).
	 */
	LIMIT_NETDEBUG(KERN_DEBUG "UDP%s: bad checksum. From %pI4:%u to %pI4:%u ulen %d\n",
		       proto == IPPROTO_UDPLITE ? "-Lite" : "",
		       &saddr,
		       ntohs(uh->source),
		       &daddr,
		       ntohs(uh->dest),
		       ulen);
drop:
	UDP_INC_STATS_BH(net, UDP_MIB_INERRORS, proto == IPPROTO_UDPLITE);
	kfree_skb(skb);
	return 0;
}
#+end_src

** =sock_queue_rcv_skb=
#+begin_src c
int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
{
	int err = 0;
	int skb_len;

	/* Cast sk->rcvbuf to unsigned... It's pointless, but reduces
	   number of warnings when compiling with -W --ANK
	 */
	if (atomic_read(&sk->sk_rmem_alloc) + skb->truesize >=
	    (unsigned)sk->sk_rcvbuf) {
		err = -ENOMEM;
		goto out;
	}

	err = sk_filter(sk, skb);
	if (err)
		goto out;

	if (!sk_rmem_schedule(sk, skb->truesize)) {
		err = -ENOBUFS;
		goto out;
	}

	skb->dev = NULL;
	skb_set_owner_r(skb, sk);

	/* Cache the SKB length before we tack it onto the receive
	 * queue.  Once it is added it no longer belongs to us and
	 * may be freed by other threads of control pulling packets
	 * from the queue.
	 */
	skb_len = skb->len;

	skb_queue_tail(&sk->sk_receive_queue, skb);

	if (!sock_flag(sk, SOCK_DEAD))
		sk->sk_data_ready(sk, skb_len);
out:
	return err;
}
#+end_src
** =tcp_v4_connect=
#+begin_src c
int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct tcp_sock *tp = tcp_sk(sk);
	struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;
	struct rtable *rt;
	__be32 daddr, nexthop;
	int tmp;
	int err;

	if (addr_len < sizeof(struct sockaddr_in))
		return -EINVAL;

	if (usin->sin_family != AF_INET)
		return -EAFNOSUPPORT;

	nexthop = daddr = usin->sin_addr.s_addr;
	if (inet->opt && inet->opt->srr) {
		if (!daddr)
			return -EINVAL;
		nexthop = inet->opt->faddr;
	}

	tmp = ip_route_connect(&rt, nexthop, inet->saddr,
			       RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,
			       IPPROTO_TCP,
			       inet->sport, usin->sin_port, sk, 1);
	if (tmp < 0) {
		if (tmp == -ENETUNREACH)
			IP_INC_STATS_BH(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);
		return tmp;
	}

	if (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {
		ip_rt_put(rt);
		return -ENETUNREACH;
	}

	if (!inet->opt || !inet->opt->srr)
		daddr = rt->rt_dst;

	if (!inet->saddr)
		inet->saddr = rt->rt_src;
	inet->rcv_saddr = inet->saddr;

	if (tp->rx_opt.ts_recent_stamp && inet->daddr != daddr) {
		/* Reset inherited state */
		tp->rx_opt.ts_recent	   = 0;
		tp->rx_opt.ts_recent_stamp = 0;
		tp->write_seq		   = 0;
	}

	if (tcp_death_row.sysctl_tw_recycle &&
	    !tp->rx_opt.ts_recent_stamp && rt->rt_dst == daddr) {
		struct inet_peer *peer = rt_get_peer(rt);
		/*
		 * VJ's idea. We save last timestamp seen from
		 * the destination in peer table, when entering state
		 * TIME-WAIT * and initialize rx_opt.ts_recent from it,
		 * when trying new connection.
		 */
		if (peer != NULL &&
		    peer->tcp_ts_stamp + TCP_PAWS_MSL >= get_seconds()) {
			tp->rx_opt.ts_recent_stamp = peer->tcp_ts_stamp;
			tp->rx_opt.ts_recent = peer->tcp_ts;
		}
	}

	inet->dport = usin->sin_port;
	inet->daddr = daddr;

	inet_csk(sk)->icsk_ext_hdr_len = 0;
	if (inet->opt)
		inet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;

	tp->rx_opt.mss_clamp = 536;

	/* Socket identity is still unknown (sport may be zero).
	 * However we set state to SYN-SENT and not releasing socket
	 * lock select source port, enter ourselves into the hash tables and
	 * complete initialization after this.
	 */
	tcp_set_state(sk, TCP_SYN_SENT);
	err = inet_hash_connect(&tcp_death_row, sk);
	if (err)
		goto failure;

	err = ip_route_newports(&rt, IPPROTO_TCP,
				inet->sport, inet->dport, sk);
	if (err)
		goto failure;

	/* OK, now commit destination to socket.  */
	sk->sk_gso_type = SKB_GSO_TCPV4;
	sk_setup_caps(sk, &rt->u.dst);

	if (!tp->write_seq)
		tp->write_seq = secure_tcp_sequence_number(inet->saddr,
							   inet->daddr,
							   inet->sport,
							   usin->sin_port);

	inet->id = tp->write_seq ^ jiffies;

	err = tcp_connect(sk);
	rt = NULL;
	if (err)
		goto failure;

	return 0;

failure:
	/*
	 * This unhashes the socket and releases the local port,
	 * if necessary.
	 */
	tcp_set_state(sk, TCP_CLOSE);
	ip_rt_put(rt);
	sk->sk_route_caps = 0;
	inet->dport = 0;
	return err;
}
#+end_src
** =tcp_connect=
#+begin_src c
int tcp_connect(struct sock *sk)
{
	struct tcp_sock *tp = tcp_sk(sk);
	struct sk_buff *buff;

	tcp_connect_init(sk);

	buff = alloc_skb_fclone(MAX_TCP_HEADER + 15, sk->sk_allocation);
	if (unlikely(buff == NULL))
		return -ENOBUFS;

	/* Reserve space for headers. */
	skb_reserve(buff, MAX_TCP_HEADER);

	tp->snd_nxt = tp->write_seq;
	tcp_init_nondata_skb(buff, tp->write_seq++, TCPCB_FLAG_SYN);
	TCP_ECN_send_syn(sk, buff);

	/* Send it off. */
	TCP_SKB_CB(buff)->when = tcp_time_stamp;
	tp->retrans_stamp = TCP_SKB_CB(buff)->when;
	skb_header_release(buff);
	__tcp_add_write_queue_tail(sk, buff);
	sk->sk_wmem_queued += buff->truesize;
	sk_mem_charge(sk, buff->truesize);
	tp->packets_out += tcp_skb_pcount(buff);
	tcp_transmit_skb(sk, buff, 1, sk->sk_allocation);

	/* We change tp->snd_nxt after the tcp_transmit_skb() call
	 * in order to make this packet get counted in tcpOutSegs.
	 */
	tp->snd_nxt = tp->write_seq;
	tp->pushed_seq = tp->write_seq;
	TCP_INC_STATS(sock_net(sk), TCP_MIB_ACTIVEOPENS);

	/* Timer for repeating the SYN until an answer. */
	inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,
				  inet_csk(sk)->icsk_rto, TCP_RTO_MAX);
	return 0;
}
#+end_src
