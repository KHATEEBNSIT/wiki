#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: Transport layer
#+OPTIONS: num:nil H:2

* UDP
在[[http://wiki.dreamrunner.org/public_html/Linux/Networks/network-layer.html][Network layer中]],  =ip_local_deliver= 把IP包发送往 transport layer.
=net/ipv4/udp.c= 中的  =udp_rcv= 进一步处理 UDP 数据报文包.相应的代码
流程如下.

[[./Files/udp-rcv.jpeg]]

=udp_rcv= 函数仅仅是 =__udp4_lib_rcv= 的一个封装,因为这代码与RFC3828中
定义的UDP-lite协议的实现所共享.

和其他协议层一样,函数的输入参数是socket buffer.一旦到这数据包是完整,需
要使用 =__udp4_lib_lookup= 找到侦听socket.链路参数能从UDP头中获取,它的
结果如下:

[[./Files/udp-structure.jpeg]]

+ ‘‘Source’’ 和 ‘‘Destination Port’’指定端口号,可接受的值从0
  到65.535(因为使用16字节.
+ ‘‘Length’是字节数总的长度(头部和数据).

UDP 包头在kernel中如下数据结构:

#+begin_src c
struct udphdr {
	__be16	source;
	__be16	dest;
	__be16	len;
	__sum16	check;
};
#+end_src

=net/ipv4/udp.c= 中的 =__udp4_lib_lookup= 使用来寻找这个包将要发送的
kernel内部的socket.当有侦听进程接受此包,代码使用hash方法从全局hash表
=udphash= 中找到 =sock= 结构的实例.如果不能找到相应的socket,它将发送一
个 /destination unreachable/ 信息给原系统,然后此包被丢弃.

#+begin_src c
icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);
#+end_src

这里需要 =sock= 结构来把transport层的数据传递到用户层应用程序,实际上,
在kernel中有2个数据结构来表示socket. =sock= 是network access layer的接
口,而 =socket= 是用户空间的链接点.这两个结构在之后[[http://wiki.dreamrunner.org/public_html/Linux/Networks/application-layer.html][Application Layer]]分
析.在此,我们感兴趣的是 =sock= 结构中用来传递数据到上层的方法.这需要允
许收到的数据被放到一个socket指定的等待队列中,并且通知接收进程有新的数
据到达.现在, =sock= 结构能缩略到如下简化版:

#+begin_src c
  // include/net/sock.h
  /* Short version */
  struct sock {
    wait_queue_head_t *sk_sleep;
    struct sk_buff_head sk_receive_queue;
    /* Callback */
    void (*sk_data_ready)(struct sock *sk, int bytes);
  }
#+end_src

=udp_rcv= 找到相应的 =sock= 实例后,进入函数 =udp_queue_rcv_skb=, 调用
=__udp_queue_rcv_skb= ,最后进入 =sock_queue_rcv_skb= 中,把包放入等待队
列.重要的流程如下:
1. 等待数据到达的进程通过socket sleep对其等待队列sleep.
2. 调用 =skb_queue_tail= 把socket buffer包插入到 =receive_queue= list
   的最后,这个list头在 =sock= 结构中.
3. =sk_data_ready= 指向的函数被调用来通知socket有新的数据到达.它唤醒等
   待此队列的所有sleep的进程.

* TCP
相对UDP,TCP提供更多功能.因此,它在kernel中的实现比较困难和复杂.谈及细节
问题可以占用整本书.面向连接的TCP通信模型支持安全数据流传输不仅在kernel
中需要更强的管理复杂,同时也需要进一步的操作,比如明示的连接创建通过设备
间的握手.

这里主要分析TCP协议的3个主要部分:连接建立,传送/发送包和连接终止.

[[./Files/tcp-state-transition.jpeg]]

** TCP Headers

** Receiving TCP Data

** Three-Way Handshake

** Passive Connection Establishment

** Active Connection Establishment

** Transmission of Data Packets

** Receiving Packets

** Sending Packets

** Connection Termination

* file
[[./Files/tcp-active-connection-establish.jpeg
[[./Files/tcp-sendmsg.jpeg
[[./Files/tcp-v4-rcv-connection.jpeg
[[./Files/tcp-v4-rcv-passive.jpeg

[[./Files/

#+begin_src c

#+end_src

* reference
** =__udp4_lib_rcv=
#+begin_src c
int __udp4_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,
		   int proto)
{
	struct sock *sk;
	struct udphdr *uh;
	unsigned short ulen;
	struct rtable *rt = skb_rtable(skb);
	__be32 saddr, daddr;
	struct net *net = dev_net(skb->dev);

	/*
	 *  Validate the packet.
	 */
	if (!pskb_may_pull(skb, sizeof(struct udphdr)))
		goto drop;		/* No space for header. */

	uh   = udp_hdr(skb);
	ulen = ntohs(uh->len);
	saddr = ip_hdr(skb)->saddr;
	daddr = ip_hdr(skb)->daddr;

	if (ulen > skb->len)
		goto short_packet;

	if (proto == IPPROTO_UDP) {
		/* UDP validates ulen. */
		if (ulen < sizeof(*uh) || pskb_trim_rcsum(skb, ulen))
			goto short_packet;
		uh = udp_hdr(skb);
	}

	if (udp4_csum_init(skb, uh, proto))
		goto csum_error;

	if (rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST))
		return __udp4_lib_mcast_deliver(net, skb, uh,
				saddr, daddr, udptable);

	sk = __udp4_lib_lookup_skb(skb, uh->source, uh->dest, udptable);

	if (sk != NULL) {
		int ret = udp_queue_rcv_skb(sk, skb);
		sock_put(sk);

		/* a return value > 0 means to resubmit the input, but
		 * it wants the return to be -protocol, or 0
		 */
		if (ret > 0)
			return -ret;
		return 0;
	}

	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
		goto drop;
	nf_reset(skb);

	/* No socket. Drop packet silently, if checksum is wrong */
	if (udp_lib_checksum_complete(skb))
		goto csum_error;

	UDP_INC_STATS_BH(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE);
	icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);

	/*
	 * Hmm.  We got an UDP packet to a port to which we
	 * don't wanna listen.  Ignore it.
	 */
	kfree_skb(skb);
	return 0;

short_packet:
	LIMIT_NETDEBUG(KERN_DEBUG "UDP%s: short packet: From %pI4:%u %d/%d to %pI4:%u\n",
		       proto == IPPROTO_UDPLITE ? "-Lite" : "",
		       &saddr,
		       ntohs(uh->source),
		       ulen,
		       skb->len,
		       &daddr,
		       ntohs(uh->dest));
	goto drop;

csum_error:
	/*
	 * RFC1122: OK.  Discards the bad packet silently (as far as
	 * the network is concerned, anyway) as per 4.1.3.4 (MUST).
	 */
	LIMIT_NETDEBUG(KERN_DEBUG "UDP%s: bad checksum. From %pI4:%u to %pI4:%u ulen %d\n",
		       proto == IPPROTO_UDPLITE ? "-Lite" : "",
		       &saddr,
		       ntohs(uh->source),
		       &daddr,
		       ntohs(uh->dest),
		       ulen);
drop:
	UDP_INC_STATS_BH(net, UDP_MIB_INERRORS, proto == IPPROTO_UDPLITE);
	kfree_skb(skb);
	return 0;
}
#+end_src

** =sock_queue_rcv_skb=
#+begin_src c
int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
{
	int err = 0;
	int skb_len;

	/* Cast sk->rcvbuf to unsigned... It's pointless, but reduces
	   number of warnings when compiling with -W --ANK
	 */
	if (atomic_read(&sk->sk_rmem_alloc) + skb->truesize >=
	    (unsigned)sk->sk_rcvbuf) {
		err = -ENOMEM;
		goto out;
	}

	err = sk_filter(sk, skb);
	if (err)
		goto out;

	if (!sk_rmem_schedule(sk, skb->truesize)) {
		err = -ENOBUFS;
		goto out;
	}

	skb->dev = NULL;
	skb_set_owner_r(skb, sk);

	/* Cache the SKB length before we tack it onto the receive
	 * queue.  Once it is added it no longer belongs to us and
	 * may be freed by other threads of control pulling packets
	 * from the queue.
	 */
	skb_len = skb->len;

	skb_queue_tail(&sk->sk_receive_queue, skb);

	if (!sock_flag(sk, SOCK_DEAD))
		sk->sk_data_ready(sk, skb_len);
out:
	return err;
}
#+end_src
** =
