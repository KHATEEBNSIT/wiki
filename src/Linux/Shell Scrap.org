#+SETUPFILE: ~/.emacs.d/src/org-templates/level-1.org
#+TITLE: Shell Scrap
#+OPTIONS: num:nil H:2


* Flow Control
** if
*** syntax
#+begin_src sh
# First form

if condition ; then
    commands
fi

# Second form

if condition ; then
    commands
else
    commands
fi

# Third form

if condition ; then
    commands
elif condition ; then
    commands
fi
#+end_src

*** Example
#+begin_src sh
if [ -f .bash_profile ]; then
    echo "You have a .bash_profile. Things are fine."
else
    echo "Yikes! You have no .bash_profile!"
fi
#+end_src

*** Condition
Expression    Description

+ -d file True if file is a directory.
+ -e file True if file exists.
+ -f file True if file exists and is a regular file.
+ -L file True if file is a symbolic link.
+ -r file True if file is a file readable by you.
+ -w file True if file is a file writable by you.
+ -x file True if file is a file executable by you.
+ file1 -nt file2  True if file1 is newer than (according to modification time) file2
+ file1 -ot file2  True if file1 is older than file2
+ -z string True if string is empty.
+ -n string  True if string is not empty.
+ string1 = string2  True if string1 equals string2.
+ string1 != string2  True if string1 does not equal string2.

** case
*** syntax
#+begin_src sh
case word in
    patterns ) statements ;;
esac
#+end_src

*** example
#+begin_src sh
#!/bin/bash

echo -n "Enter a number between 1 and 3 inclusive > "
read character
case $character in
    1 ) echo "You entered one."
        ;;
    2 ) echo "You entered two."
        ;;
    3 ) echo "You entered three."
        ;;
    * ) echo "You did not enter a number"
        echo "between 1 and 3."
esac
#+end_src


** Loops
*** while
**** example
#+begin_src sh
#!/bin/bash

number=0
while [ $number -lt 10 ]; do
    echo "Number = $number"
    number=$((number + 1))
done
#+end_src
*** until
The until command works exactly the same way, except the block of code
is repeated as long as the condition is false.

**** Example
#+begin_src sh
#!/bin/bash

number=0
until [ $number -ge 10 ]; do
    echo "Number = $number"
    number=$((number + 1))
done
#+end_src

*** =for=
**** syntax
#+begin_src sh
for variable in words; do
    statements
done
#+end_src
* Keyboard Input
** read
*** example
#+begin_src 
#!/bin/bash

echo -n "Enter some text > "
read text
echo "You entered: $text"
#+end_src
*** option =-t= (time)
The -t option followed by a number of seconds provides an automatic
timeout for the read command. 
#+begin_src sh
#!/bin/bash
echo -n "Hurry up and type something! > "
if read -t 3 response; then
    echo "Great, you made it in time!"
else
    echo "Sorry, you are too slow!"
fi
#+end_src

*** option =-s=
The -s option causes the user's typing not to be displayed. 

* Parameters
** =$#=
the shell maintains a variable called $# that contains the number of
items on the command line
** =shift=
=shift= is a shell builtin that operates on the positional parameters.
Each time you invoke shift, it "shifts" all the positional parameters
down by one. $2 becomes $1, $3 becomes $2, $4 becomes $3, and so on.

* Errors and Signals and Traps
** Exit status
*** Checking the exit status
First, you can examine the contents of the $? environment variable. $?
will contain the exit status of the last command executed.

#+begin_src sh
[me] $ true; echo $?
0
[me] $ false; echo $?
1
#+end_src
* Creating safe temporary files
The preferred technique is to write them in a local directory such as
=~/tmp= (a tmp subdirectory in the user's home directory.) If you must
write files in =/tmp=, you must take steps to make sure the file names
are not predictable. Predictable file names allow an attacker to
create symbolic links to other files that the attacker wants you to
overwrite.
** example
#+begin_src sh
TEMP_FILE=$TEMP_DIR/printfile.$$.$RANDOM
#+end_src
+ =$$= shell variable to embed the process id (pid) of the program
+ =$RANDOM= shell variable to append a random number to the file name

* Debug
** Watching your script run
*** Method1
#+begin_src sh
#!/bin/bash -x
#+end_src
*** Method2
you can use the set command within your script to turn tracing on and
off. Use =set -x= to turn tracing on and =set +x= to turn tracing off. For
example.:

#+begin_src sh
#!/bin/bash

number=1

set -x
if [ $number = "1" ]; then
    echo "Number equals 1"
else
    echo "Number does not equal 1"
fi
set +x
#+end_src
