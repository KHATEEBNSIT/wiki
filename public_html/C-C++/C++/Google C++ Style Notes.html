<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Google C++ Style Guide Notes (Revision 3.274)</title>
<!-- 2014-01-03 Fri 21:50 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Google C++ Style Guide Notes (Revision 3.274)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Homepage</a></li>
<li><a href="#sec-2">Header Files</a>
<ul>
<li><a href="#sec-2-1">The #define Guard</a></li>
<li><a href="#sec-2-2">Forward Declarations</a></li>
<li><a href="#sec-2-3">Inline Functions</a></li>
<li><a href="#sec-2-4">The -inl.h Files</a></li>
<li><a href="#sec-2-5">Function Parameter Ordering</a></li>
<li><a href="#sec-2-6">Names and Order of Includes</a></li>
</ul>
</li>
<li><a href="#sec-3">Scoping</a>
<ul>
<li><a href="#sec-3-1">Namespaces</a></li>
<li><a href="#sec-3-2">Nested Classes</a></li>
<li><a href="#sec-3-3">Nonmember, Static Member, and Global Functions</a></li>
<li><a href="#sec-3-4">Local Variables</a></li>
<li><a href="#sec-3-5">Static and Global Variables</a></li>
</ul>
</li>
<li><a href="#sec-4">Classes</a>
<ul>
<li><a href="#sec-4-1">Doing Work in Constructors</a></li>
<li><a href="#sec-4-2">Initialization</a></li>
<li><a href="#sec-4-3">Explicit Constructors</a></li>
<li><a href="#sec-4-4">Copy Constructors</a></li>
</ul>
</li>
<li><a href="#sec-5">cc</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Homepage</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>en:<a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml</a>
</li>
<li>zh:<a href="http://zh-google-styleguide.readthedocs.org/en/latest/">http://zh-google-styleguide.readthedocs.org/en/latest/</a> 
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Header Files</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">The #define Guard</h3>
<div class="outline-text-3" id="text-2-1">
<p class="info">
所有头文件都应该使用 #define 防止头文件被多重包含, 
命名格式当是: &ltPROJECT&gt_&ltPATH&gt_&ltFILE&gt_H_
</p>

<p>
For example, the file <code>foo/src/bar/baz.h</code> in project <code>foo</code> should have the
following guard:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#if</span><span style="color: #b0c4de;">n</span><span style="color: #b0c4de;">def</span> FOO_BAR_BAZ_H_
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">FOO_BAR_BAZ_H_</span>

...

<span style="color: #b0c4de;">#endif</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">FOO_BAR_BAZ_H_</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Forward Declarations</h3>
<div class="outline-text-3" id="text-2-2">
<p class="info">
能用前置声明来避免不必要的#include.
</p>

<p>
A "forward declaration" is a declaration of a class, function, or
template without an associated definition.
</p>

<p>
用前置声明可以显著减少需要包含的头文件数量. 举例说明: 如果头文件中用到类 File, 但不需要访问 File 类的声明, 头文件中只需前置声明 class File; 而无须 #include "file/base/file.h".
</p>

<p>
不允许访问类的定义的前提下, 我们在一个头文件中能对类 Foo 做哪些操作?
</p>

<ul class="org-ul">
<li>我们可以将数据成员类型声明为 Foo * 或 Foo &amp;.
</li>
<li>我们可以将函数参数 / 返回值的类型声明为 Foo (但不能定义实现).
</li>
<li>我们可以将静态数据成员的类型声明为 Foo, 因为静态数据成员的定义在类定义之外.
</li>
</ul>
<p>
反之, 如果你的类是 Foo 的子类, 或者含有类型为 Foo 的非静态数据成员, 则
必须包含 Foo 所在的头文件.
</p>

<p>
<b>Decision:</b>
</p>
<ul class="org-ul">
<li>When using a <b>function</b> declared in a header file, always #include
that header.
</li>
<li>When using a class template, prefer to #include its header file.
</li>
<li>When using an ordinary class, relying on a forward declaration is
OK, but be wary of situations where a forward declaration may be
insufficient or incorrect; when in doubt, just #include the
appropriate header.
</li>
<li>Do not replace data members with pointers just to avoid
an #include.
</li>
</ul>

<p>
当然 .cc 文件无论如何都需要所使用类的定义部分, 自然也就会包含若干头文件.
</p>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Inline Functions</h3>
<div class="outline-text-3" id="text-2-3">
<p class="info">
只有当函数只有 10 行甚至更少时才将其定义为内联函数.
</p>
<p>
 <b>Decision:</b>
一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数,
析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!
</p>

<p>
另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿
失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).
</p>

<p>
有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数
和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函
数.（递归调用堆栈的展开并不像循环那么简单, 比如递归层数在
编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主
要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述
其行为, 比如精短的存取函数.
</p>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">The -inl.h Files</h3>
<div class="outline-text-3" id="text-2-4">
<p class="info">
复杂的内联函数的定义, 可放在后缀名为 -inl.h 的头文件中.
</p>

<p>
Another use of -inl.h files is for definitions of function templates.
This can be used to keep your template definitions easy to read.
</p>

<p>
Do not forget that a -inl.h file requires a #define guard just like
any other header file.
</p>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Function Parameter Ordering</h3>
<div class="outline-text-3" id="text-2-5">
<p class="info">
When defining a function, parameter order is: inputs, then outputs.
</p>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Names and Order of Includes</h3>
<div class="outline-text-3" id="text-2-6">
<p class="info">
使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: C 库, C++ 库, 其他库的 .h, 本项目内的 .h.
</p>

<p>
For example, <code>google-awesome-project/src/base/logging.h</code> should be
included as
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"base/logging.h"</span>
</pre>
</div>

<p>
In <code>dir/foo.cc</code> or <code>dir/foo_test.cc</code>, whose main purpose is to implement
or test the stuff in dir2/foo2.h, order your includes as follows:
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #87cefa;">dir2/foo2.h</span> (preferred location &#8212; see details below).
C system files.
C++ system files.
Other libraries<span style="color: #ffa07a;">' .h files.</span>
<span style="color: #ffa07a;">Your project'</span>s .h files.
</pre>
</div>

<p>
With the preferred ordering, if dir2/foo2.h omits any necessary
includes, the build of dir/foo.cc or <code>dir/foo_test.cc</code> will break. Thus,
this rule ensures that build breaks show up first for the people
working on these files, not for innocent people in other packages.
</p>

<p>
Within each section the includes should be ordered alphabetically.
Note that older code might not conform to this rule and should be
fixed when convenient.
</p>

<p>
Exception: sometimes, system-specific code needs conditional includes.
Such code can put conditional includes after other includes. Example:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"foo/public/fooserver.h"</span>

<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"base/port.h"</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">For LANG_CXX11.</span>

<span style="color: #b0c4de;">#ifdef</span> LANG_CXX11
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;initializer_list&gt;</span>
<span style="color: #b0c4de;">#endif</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">LANG_CXX11</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Scoping</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Namespaces</h3>
<div class="outline-text-3" id="text-3-1">
<p class="info">
鼓励在 .cc 文件内使用匿名名字空间. 使用具名的名字空间时, 
其名称可基于项目名或相对路径. 不要使用 using 关键字.
不要使用内嵌名字空间
</p>

<p>
 <b>Decision:</b>
Use namespaces according to the policy described below. Terminate
namespaces with comments as shown in the given examples.
</p>
</div>
<ul class="org-ul"><li>Unnamed Namespaces<br  /><div class="outline-text-4" id="text-3-1-1">
<ul class="org-ul">
<li>Unnamed namespaces are allowed and even encouraged in .cc files, to
avoid runtime naming conflicts:

<div class="org-src-container">

<pre class="src src-c">namespace {                           <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">This is in a .cc file.</span>

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The content of a namespace is not indented</span>
<span style="color: #00ffff;">enum</span> { <span style="color: #eedd82;">kUnused</span>, <span style="color: #98fb98;">kEOF</span>, <span style="color: #eedd82;">kError</span> };       <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Commonly used tokens.</span>
<span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">AtEof</span>() { <span style="color: #00ffff;">return</span> pos_ == kEOF; }  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Uses our namespace's EOF.</span>

}  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">namespace</span>
</pre>
</div>
<p>
However, file-scope declarations that are associated with a
particular class may be declared in that class as types, static data
members or static member functions rather than as members of an
unnamed namespace.
</p>
</li>

<li>Do not use unnamed namespaces in .h files.
</li>
</ul>
</div>
</li>

<li>Named Namespaces<br  /><div class="outline-text-4" id="text-3-1-2">
<p>
Named namespaces should be used as follows:
</p>
<ul class="org-ul">
<li>Namespaces wrap the entire source file after includes, gflags
definitions/declarations, and forward declarations of classes from
other namespaces:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">In the .h file</span>
<span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">mynamespace</span> {

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">All declarations are within the namespace scope.</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Notice the lack of indentation.</span>
<span style="color: #98fb98;">class</span> <span style="color: #eedd82;">MyClass</span> {
 <span style="color: #7fffd4;">public</span>:
  ...
  <span style="color: #98fb98;">void</span> Foo();
};

}  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">namespace mynamespace</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">In the .cc file</span>
<span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">mynamespace</span> {

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Definition of functions is within scope of the namespace.</span>
<span style="color: #98fb98;">void</span> <span style="color: #eedd82;">MyClass</span>::Foo() {
  ...
}

}  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">namespace mynamespace</span>
</pre>
</div>
<p>
The typical .cc file might have more complex detail, including the
need to reference classes in other namespaces.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"a.h"</span>

DEFINE_bool(someflag, <span style="color: #7fffd4;">false</span>, <span style="color: #ffa07a;">"dummy flag"</span>);

<span style="color: #98fb98;">class</span> <span style="color: #eedd82;">C</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Forward declaration of class C in the global namespace.</span>
<span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">a</span> { <span style="color: #98fb98;">class</span> <span style="color: #eedd82;">A</span>; }  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Forward declaration of a::A.</span>

<span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">b</span> {

...code <span style="color: #00ffff;">for</span> b...         <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Code goes against the left margin.</span>

}  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">namespace b</span>
</pre>
</div>
</li>
<li>Do not declare anything in namespace std, not even forward
declarations of standard library classes.
</li>
<li>You may not use a using-directive to make all names from a namespace
available.
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Forbidden -- This pollutes the namespace.</span>
using <span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">foo</span>;
</pre>
</div>
</li>
<li>You may use a using-declaration anywhere in a .cc file, and in
functions, methods or classes in .h files.
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">OK in .cc files.</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Must be in a function, method or class in .h files.</span>
using ::foo::bar;
</pre>
</div>
</li>
<li>Namespace aliases are allowed anywhere in a .cc file, anywhere
inside the named namespace that wraps an entire .h file, and in
functions and methods.
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Shorten access to some commonly used names in .cc files.</span>
<span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">fbz</span> = ::foo::bar::baz;

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Shorten access to some commonly used names (in a .h file).</span>
<span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">librarian</span> {
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The following alias is available to all files including</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">this header (in namespace librarian):</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">alias names should therefore be chosen consistently</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">within a project.</span>
<span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">pd_s</span> = ::pipeline_diagnostics::sidetable;

<span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">my_inline_function</span>() {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">namespace alias local to a function (or method).</span>
  <span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">fbz</span> = ::foo::bar::baz;
  ...
}
}  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">namespace librarian</span>
</pre>
</div>
</li>
<li>Do not use inline namespaces.
</li>
</ul>
</div>
</li></ul>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Nested Classes</h3>
<div class="outline-text-3" id="text-3-2">
<p class="info">
当公有嵌套类作为接口的一部分时, 
虽然可以直接将他们保持在全局作用域中, 但将嵌套类的声明置于名字空间内是更好的选择.
</p>
<p>
Do not make nested classes public unless they are actually part of the
interface, e.g., a class that holds a set of options for some method.
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Nonmember, Static Member, and Global Functions</h3>
<div class="outline-text-3" id="text-3-3">
<p class="info">
使用静态成员函数或名字空间内的非成员函数, 尽量不要用裸的全局函数.
</p>

<p>
Sometimes it is useful, or even necessary, to define a function not
bound to a class instance. Such a function can be either a static
member or a nonmember function. Nonmember functions should not depend
on external variables, and should nearly always exist in a namespace.
Rather than creating classes only to group static member functions
which do not share static data, use namespaces instead.
</p>

<p>
Functions defined in the same compilation unit as production classes
may introduce unnecessary coupling and link-time dependencies when
directly called from other compilation units; static member functions
are particularly susceptible to this. Consider extracting a new class,
or placing the functions in a namespace possibly in a separate
library.
</p>

<p>
If you must define a nonmember function and it is only needed in its
.cc file, use an unnamed namespace or static linkage (eg static int
Foo() {&#x2026;}) to limit its scope.
</p>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Local Variables</h3>
<div class="outline-text-3" id="text-3-4">
<p class="info">
将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.
</p>

<p>
There is one caveat: if the variable is an object, its constructor is
invoked every time it enters scope and is created, and its destructor
is invoked every time it goes out of scope.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Inefficient implementation:</span>
<span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 1000000; ++i) {
  <span style="color: #98fb98;">Foo</span> <span style="color: #eedd82;">f</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">My ctor and dtor get called 1000000 times each.</span>
  f.DoSomething(i);
}
</pre>
</div>
<p>
It may be more efficient to declare such a variable used in a loop
outside that loop:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">Foo</span> <span style="color: #eedd82;">f</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">My ctor and dtor get called once each.</span>
<span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 1000000; ++i) {
  f.DoSomething(i);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">Static and Global Variables</h3>
<div class="outline-text-3" id="text-3-5">
<p class="info">
禁止使用 class 类型的静态或全局变量: 它们会导致很难发现的 
bug 和不确定的构造和析构函数调用顺序.但是，允许这些变量，
当他们是没有动态初始和析构的constexpr:时。
</p>

<p>
Objects with static storage duration, including global variables,
static variables, static class member variables, and function static
variables, must be Plain Old Data (POD): only ints, chars, floats, or
pointers, or arrays/structs of POD.
</p>

<p>
The order in which class constructors and initializers for static
variables are called is only partially specified in C++ and can even
change from build to build, which can cause bugs that are difficult to
find. Therefore in addition to banning globals of class type, we do
not allow static POD variables to be initialized with the result of a
function, unless that function (such as getenv(), or getpid()) does
not itself depend on any other globals.
</p>

<p>
One way to alleviate the destructor problem is to terminate the
program by calling <code>quick_exit()</code> instead of <code>exit()</code>. The difference is
that <code>quick_exit()</code> does not invoke destructors and does not invoke any
handlers that were registered by calling <code>atexit()</code>. If you have a
handler that needs to run when a program terminates via <code>quick_exit()</code>
(flushing logs, for example), you can register it using
<code>at_quick_exit()</code>. (If you have a handler that needs to run at both
<code>exit()</code> and <code>quick_exit()</code>, you need to register it in both places.)、
</p>

<p>
If you need a static or global variable of a class type, consider
initializing a pointer (which will never be freed), from either your
main() function or from pthread<sub>once</sub>(). Note that this must be a raw
pointer, not a "smart" pointer, since the smart pointer's destructor
will have the order-of-destructor issue that we are trying to avoid.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Classes</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Doing Work in Constructors</h3>
<div class="outline-text-3" id="text-4-1">
<p class="info">
在构造函数中避免做复杂的初始化（特别，能失败或需要调用虚函数）
</p>

<p>
 <b>Decision:</b>
Constructors should never call virtual functions or attempt to raise
non-fatal failures. If your object requires non-trivial
initialization, consider using a factory function or Init() method.
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Initialization</h3>
<div class="outline-text-3" id="text-4-2">
<p class="info">
如果类定义了成员变量，必须在类中定义一个初始化所有成员变量的初始化函数
或构造函数（可以是默认构造函数）。如果没有定义任何默认构造函数. 编译器
将自动生产一个默认的构造函数，使得一些没被初始化或初始化位不合理的值。
</p>
<p>
 <b>Decision:</b>
Use in-class member initialization for simple initializations,
especially when a member variable must be initialized the same way in
more than one constructor.
</p>

<p>
If your class defines member variables that aren't initialized
in-class, and if it has no other constructors, you must define a
default constructor (one that takes no arguments).
</p>

<p>
If your class inherits from an existing class but you add no new
member variables, you are not required to have a default constructor.
</p>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Explicit Constructors</h3>
<div class="outline-text-3" id="text-4-3">
<p class="info">
对单个参数的构造函数使用 C++ 关键字 explicit.
</p>
<p>
 <b>Decision:</b>
We require all single argument constructors to be explicit. Always put
explicit in front of one-argument constructors in the class
definition: explicit Foo(string name); 
</p>

<p>
The exception is copy constructors, which, in the rare cases when we
allow them, should probably not be explicit. Classes that are intended
to be transparent wrappers around other classes are also exceptions.
Such exceptions should be clearly marked with comments. 
</p>

<p>
Finally, constructors that take only an initializer<sub>list</sub> may be
non-explicit. This is to permit construction of your type using the
assigment form for brace init lists (i.e. MyType m = {1, 2} ).
</p>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Copy Constructors</h3>
<div class="outline-text-3" id="text-4-4">
<p class="info">

</p>
</div>
</div>
</div>





<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">cc</h2>
<div class="outline-text-2" id="text-5">
<p class="info">

</p>


<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2014-01-03 Fri 21:50</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.50.1 (<a href="http://orgmode.org">Org</a> mode 8.2.3a)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
