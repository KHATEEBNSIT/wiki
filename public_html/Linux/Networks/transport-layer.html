<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Transport layer</title>
<!-- 2014-11-19 Wed 20:20 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Transport layer</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">UDP</a></li>
<li><a href="#sec-2">TCP</a>
<ul>
<li><a href="#sec-2-1">TCP Headers</a></li>
<li><a href="#sec-2-2">Receiving TCP Data</a></li>
<li><a href="#sec-2-3">Three-Way Handshake</a></li>
<li><a href="#sec-2-4">Passive Connection Establishment</a></li>
<li><a href="#sec-2-5">Active Connection Establishment</a></li>
<li><a href="#sec-2-6">Transmission of Data Packets</a></li>
<li><a href="#sec-2-7">Receiving Packets</a></li>
<li><a href="#sec-2-8">Sending Packets</a></li>
<li><a href="#sec-2-9">Connection Termination</a></li>
</ul>
</li>
<li><a href="#sec-3">file</a></li>
<li><a href="#sec-4">reference</a>
<ul>
<li><a href="#sec-4-1"><code>__udp4_lib_rcv</code></a></li>
<li><a href="#sec-4-2"><code>sock_queue_rcv_skb</code></a></li>
<li><a href="#sec-4-3">=</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">UDP</h2>
<div class="outline-text-2" id="text-1">
<p>
在<a href="http://wiki.dreamrunner.org/public_html/Linux/Networks/network-layer.html">Network layer中</a>,  <code>ip_local_deliver</code> 把IP包发送往 transport layer.
<code>net/ipv4/udp.c</code> 中的  <code>udp_rcv</code> 进一步处理 UDP 数据报文包.相应的代码流程如下.
</p>


<div class="figure">
<p><img src="./Files/udp-rcv.jpeg" alt="udp-rcv.jpeg" />
</p>
</div>

<p>
<code>udp_rcv</code> 函数仅仅是 <code>__udp4_lib_rcv</code> 的一个封装,因为这代码与RFC3828中定义的UDP-lite协议的实现所共享.
</p>

<p>
和其他协议层一样,函数的输入参数是socket buffer.一旦到这数据包是完整,需要使用 <code>__udp4_lib_lookup</code> 找到侦听socket.链路参数能从UDP头中获取,它的结果如下:
</p>


<div class="figure">
<p><img src="./Files/udp-structure.jpeg" alt="udp-structure.jpeg" />
</p>
</div>

<ul class="org-ul">
<li>‘‘Source’’ 和 ‘‘Destination Port’’指定端口号,可接受的值从0
到65.535(因为使用16字节.
</li>
<li>‘‘Length’是字节数总的长度(头部和数据).
</li>
</ul>

<p>
UDP 包头在kernel中如下数据结构:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">udphdr</span> {
        <span style="color: #98fb98;">__be16</span>  <span style="color: #eedd82;">source</span>;
        <span style="color: #98fb98;">__be16</span>  <span style="color: #eedd82;">dest</span>;
        <span style="color: #98fb98;">__be16</span>  <span style="color: #eedd82;">len</span>;
        <span style="color: #98fb98;">__sum16</span> <span style="color: #eedd82;">check</span>;
};
</pre>
</div>

<p>
<code>net/ipv4/udp.c</code> 中的 <code>__udp4_lib_lookup</code> 使用来寻找这个包将要发送的
kernel内部的socket.当有侦听进程接受此包,代码使用hash方法从全局hash表
<code>udphash</code> 中找到 <code>sock</code> 结构的实例.如果不能找到相应的socket,它将发送一个 <i>destination unreachable</i> 信息给原系统,然后此包被丢弃.
</p>

<div class="org-src-container">

<pre class="src src-c">icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);
</pre>
</div>

<p>
这里需要 <code>sock</code> 结构来把transport层的数据传递到用户层应用程序,实际上,
在kernel中有2个数据结构来表示socket. <code>sock</code> 是network access layer的接口,而 <code>socket</code> 是用户空间的链接点.这两个结构在之后<a href="http://wiki.dreamrunner.org/public_html/Linux/Networks/application-layer.html">Application Layer</a>分析.在此,我们感兴趣的是 <code>sock</code> 结构中用来传递数据到上层的方法.这需要允许收到的数据被放到一个socket指定的等待队列中,并且通知接收进程有新的数据到达.现在, <code>sock</code> 结构能缩略到如下简化版:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">include/net/sock.h</span>
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Short version </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sock</span> {
  <span style="color: #98fb98;">wait_queue_head_t</span> *<span style="color: #eedd82;">sk_sleep</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff_head</span> <span style="color: #eedd82;">sk_receive_queue</span>;
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Callback </span><span style="color: #ff7f24;">*/</span>
  <span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">sk_data_ready</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sock</span> *<span style="color: #eedd82;">sk</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">bytes</span>);
}
</pre>
</div>

<p>
<code>udp_rcv</code> 找到相应的 <code>sock</code> 实例后,进入函数 <code>udp_queue_rcv_skb</code>, 调用
<code>__udp_queue_rcv_skb</code> ,最后进入 <code>sock_queue_rcv_skb</code> 中,把包放入等待队列.重要的流程如下:
</p>
<ol class="org-ol">
<li>等待数据到达的进程通过socket sleep对其等待队列sleep.
</li>
<li>调用 <code>skb_queue_tail</code> 把socket buffer包插入到 <code>receive_queue</code> list
的最后,这个list头在 <code>sock</code> 结构中.
</li>
<li><code>sk_data_ready</code> 指向的函数被调用来通知socket有新的数据到达.它唤醒等待此队列的所有sleep的进程.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">TCP</h2>
<div class="outline-text-2" id="text-2">
<p>
相对UDP,TCP提供更多功能.因此,它在kernel中的实现比较困难和复杂.谈及细节问题可以占用整本书.面向连接的TCP通信模型支持安全数据流传输不仅在kernel
中需要更强的管理复杂,同时也需要进一步的操作,比如明示的连接创建通过设备间的握手.
</p>

<p>
这里主要分析TCP协议的3个主要部分:连接建立,传送/发送包和连接终止.
</p>


<div class="figure">
<p><img src="./Files/tcp-state-transition.jpeg" alt="tcp-state-transition.jpeg" />
</p>
</div>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">TCP Headers</h3>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Receiving TCP Data</h3>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Three-Way Handshake</h3>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Passive Connection Establishment</h3>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Active Connection Establishment</h3>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Transmission of Data Packets</h3>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">Receiving Packets</h3>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">Sending Packets</h3>
</div>

<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">Connection Termination</h3>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">file</h2>
<div class="outline-text-2" id="text-3">
<p>
[[./Files/tcp-active-connection-establish.jpeg
[[./Files/tcp-sendmsg.jpeg
[[./Files/tcp-v4-rcv-connection.jpeg
[[./Files/tcp-v4-rcv-passive.jpeg
</p>

<p>
[[./Files/
</p>

<div class="org-src-container">

<pre class="src src-c"></pre>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">reference</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><code>__udp4_lib_rcv</code></h3>
<div class="outline-text-3" id="text-4-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">__udp4_lib_rcv</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">udp_table</span> *<span style="color: #eedd82;">udptable</span>,
                   <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">proto</span>)
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sock</span> *<span style="color: #eedd82;">sk</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">udphdr</span> *<span style="color: #eedd82;">uh</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">short</span> <span style="color: #eedd82;">ulen</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rtable</span> *<span style="color: #eedd82;">rt</span> = skb_rtable(skb);
        <span style="color: #98fb98;">__be32</span> <span style="color: #eedd82;">saddr</span>, <span style="color: #eedd82;">daddr</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">net</span> *<span style="color: #eedd82;">net</span> = dev_net(skb-&gt;dev);

        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         *  Validate the packet.</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">if</span> (!pskb_may_pull(skb, <span style="color: #00ffff;">sizeof</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">udphdr</span>)))
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">drop</span>;              <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">No space for header. </span><span style="color: #ff7f24;">*/</span>

        uh   = udp_hdr(skb);
        ulen = ntohs(uh-&gt;len);
        saddr = ip_hdr(skb)-&gt;saddr;
        daddr = ip_hdr(skb)-&gt;daddr;

        <span style="color: #00ffff;">if</span> (ulen &gt; skb-&gt;len)
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">short_packet</span>;

        <span style="color: #00ffff;">if</span> (proto == IPPROTO_UDP) {
                <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">UDP validates ulen. </span><span style="color: #ff7f24;">*/</span>
                <span style="color: #00ffff;">if</span> (ulen &lt; <span style="color: #00ffff;">sizeof</span>(*uh) || pskb_trim_rcsum(skb, ulen))
                        <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">short_packet</span>;
                uh = udp_hdr(skb);
        }

        <span style="color: #00ffff;">if</span> (udp4_csum_init(skb, uh, proto))
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">csum_error</span>;

        <span style="color: #00ffff;">if</span> (rt-&gt;rt_flags &amp; (RTCF_BROADCAST|RTCF_MULTICAST))
                <span style="color: #00ffff;">return</span> __udp4_lib_mcast_deliver(net, skb, uh,
                                saddr, daddr, udptable);

        sk = __udp4_lib_lookup_skb(skb, uh-&gt;source, uh-&gt;dest, udptable);

        <span style="color: #00ffff;">if</span> (sk != <span style="color: #7fffd4;">NULL</span>) {
                <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ret</span> = udp_queue_rcv_skb(sk, skb);
                sock_put(sk);

                <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">a return value &gt; 0 means to resubmit the input, but</span>
<span style="color: #ff7f24;">                 * it wants the return to be -protocol, or 0</span>
<span style="color: #ff7f24;">                 </span><span style="color: #ff7f24;">*/</span>
                <span style="color: #00ffff;">if</span> (ret &gt; 0)
                        <span style="color: #00ffff;">return</span> -ret;
                <span style="color: #00ffff;">return</span> 0;
        }

        <span style="color: #00ffff;">if</span> (!xfrm4_policy_check(<span style="color: #7fffd4;">NULL</span>, XFRM_POLICY_IN, skb))
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">drop</span>;
        nf_reset(skb);

        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">No socket. Drop packet silently, if checksum is wrong </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">if</span> (udp_lib_checksum_complete(skb))
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">csum_error</span>;

        UDP_INC_STATS_BH(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE);
        icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);

        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         * Hmm.  We got an UDP packet to a port to which we</span>
<span style="color: #ff7f24;">         * don't wanna listen.  Ignore it.</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        kfree_skb(skb);
        <span style="color: #00ffff;">return</span> 0;

<span style="color: #7fffd4;">short_packet</span>:
        LIMIT_NETDEBUG(KERN_DEBUG <span style="color: #ffa07a;">"UDP%s: short packet: From %pI4:%u %d/%d to %pI4:%u\n"</span>,
                       proto == IPPROTO_UDPLITE ? <span style="color: #ffa07a;">"-Lite"</span> : <span style="color: #ffa07a;">""</span>,
                       &amp;saddr,
                       ntohs(uh-&gt;source),
                       ulen,
                       skb-&gt;len,
                       &amp;daddr,
                       ntohs(uh-&gt;dest));
        <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">drop</span>;

<span style="color: #7fffd4;">csum_error</span>:
        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         * RFC1122: OK.  Discards the bad packet silently (as far as</span>
<span style="color: #ff7f24;">         * the network is concerned, anyway) as per 4.1.3.4 (MUST).</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        LIMIT_NETDEBUG(KERN_DEBUG <span style="color: #ffa07a;">"UDP%s: bad checksum. From %pI4:%u to %pI4:%u ulen %d\n"</span>,
                       proto == IPPROTO_UDPLITE ? <span style="color: #ffa07a;">"-Lite"</span> : <span style="color: #ffa07a;">""</span>,
                       &amp;saddr,
                       ntohs(uh-&gt;source),
                       &amp;daddr,
                       ntohs(uh-&gt;dest),
                       ulen);
<span style="color: #7fffd4;">drop</span>:
        UDP_INC_STATS_BH(net, UDP_MIB_INERRORS, proto == IPPROTO_UDPLITE);
        kfree_skb(skb);
        <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><code>sock_queue_rcv_skb</code></h3>
<div class="outline-text-3" id="text-4-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">sock_queue_rcv_skb</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sock</span> *<span style="color: #eedd82;">sk</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>)
{
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">err</span> = 0;
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">skb_len</span>;

        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Cast sk-&gt;rcvbuf to unsigned... It's pointless, but reduces</span>
<span style="color: #ff7f24;">           number of warnings when compiling with -W --ANK</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">if</span> (atomic_read(&amp;sk-&gt;sk_rmem_alloc) + skb-&gt;truesize &gt;=
            (<span style="color: #98fb98;">unsigned</span>)sk-&gt;sk_rcvbuf) {
                err = -ENOMEM;
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">out</span>;
        }

        err = sk_filter(sk, skb);
        <span style="color: #00ffff;">if</span> (err)
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">out</span>;

        <span style="color: #00ffff;">if</span> (!sk_rmem_schedule(sk, skb-&gt;truesize)) {
                err = -ENOBUFS;
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">out</span>;
        }

        skb-&gt;dev = <span style="color: #7fffd4;">NULL</span>;
        skb_set_owner_r(skb, sk);

        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Cache the SKB length before we tack it onto the receive</span>
<span style="color: #ff7f24;">         * queue.  Once it is added it no longer belongs to us and</span>
<span style="color: #ff7f24;">         * may be freed by other threads of control pulling packets</span>
<span style="color: #ff7f24;">         * from the queue.</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        skb_len = skb-&gt;len;

        skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);

        <span style="color: #00ffff;">if</span> (!sock_flag(sk, SOCK_DEAD))
                sk-&gt;sk_data_ready(sk, skb_len);
<span style="color: #7fffd4;">out</span>:
        <span style="color: #00ffff;">return</span> err;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">=</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2014-11-19 Wed 20:20</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
