<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Algorithm Design Manual Chapter 5</title>
<!-- 2014-06-11 Wed 19:53 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../../assets/stylesheet.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Algorithm Design Manual Chapter 5</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Book Notes</a>
<ul>
<li><a href="#sec-1-1">5.1 Flavors of Graphs</a></li>
<li><a href="#sec-1-2">5.2 Data Structures for Graphs</a></li>
<li><a href="#sec-1-3">5.5 Traversing a Graph</a></li>
<li><a href="#sec-1-4">5.6 Breadth-First Search</a></li>
<li><a href="#sec-1-5">5.7 Applications of Breadth-First Search</a></li>
<li><a href="#sec-1-6">5.8 Depth-First Search</a></li>
<li><a href="#sec-1-7">5.9 Applications of Depth-First Search</a></li>
<li><a href="#sec-1-8">5.10 Depth-First Search on Directed Graphs</a></li>
</ul>
</li>
<li><a href="#sec-2">Exercises</a>
<ul>
<li><a href="#sec-2-1">5</a></li>
<li><a href="#sec-2-2">7</a></li>
<li><a href="#sec-2-3">10</a></li>
<li><a href="#sec-2-4">12</a></li>
</ul>
</li>
<li><a href="#sec-3">cc</a></li>
</ul>
</div>
</div>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Book Notes</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">5.1 Flavors of Graphs</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Undirected vs. Directed
</li>
<li>Weighted vs. Unweighted
</li>
<li>Simple vs. Non-simple
</li>
<li>Sparse vs. Dense
</li>
<li>Cyclic vs. Acyclic
</li>
<li>Embedded vs. Topological
</li>
<li>Implicit vs. Explicit
</li>
<li>Labeled vs. Unlabeled
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">5.2 Data Structures for Graphs</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>Adjacency Matrix: We can represent G using an n×n matrix M, where
element M[i, j] = 1 if(i, j) is an edge of G, and 0 if it isn’t.
</li>
<li>Adjacency Lists: We can more efficiently represent sparse graphs by
using linked lists to store the neighbors adjacent to each vertex.
</li>
</ul>

<p>
Adjacency lists are the right data structure for most applications of
graphs.
</p>

<p>
<b>Adjacency Lists</b>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXV</span> 1000  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">maximum number of vertices</span>

<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">adjacency info</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">weight</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">edge weight, if any</span>
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">next</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">next edge in list</span>
} <span style="color: #98fb98;">edgenode</span>;

<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> {
  <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">edges</span>[MAXV + 1];   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">adjacency info</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">degree</span>[MAXV + 1];  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">outdegree of each vertex</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nvertices</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">number of vertices in graph</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nedges</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">number of edges in graph</span>
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">directed</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">is the graph directed</span>
} <span style="color: #98fb98;">graph</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">initialize_graph</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>, <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">directed</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  g-&gt;nvertices = 0;
  g-&gt;nedges = 0;
  g-&gt;directed = directed;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt;= NMAX; ++i) {
    g-&gt;degree[i] = 0;
    g-&gt;edges[i] = <span style="color: #7fffd4;">NULL</span>;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">insert_edge</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>, <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">directed</span>) {
  <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">p</span>;
  p = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">edgenode</span>;
  p-&gt; weight = 0;
  p-&gt;y = y;
  p-&gt;next = g-&gt;edges[x];
  g-&gt;edges[x] = p;
  g-&gt;degree[x]++;
  <span style="color: #00ffff;">if</span> (directed == <span style="color: #7fffd4;">false</span>) {
    insert_edge(g, y, x, <span style="color: #7fffd4;">true</span>);
  } <span style="color: #00ffff;">else</span> {
    g-&gt;nedges++;
  }
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">read_graph</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>, <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">directed</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">m</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #eedd82;">y</span>;
  initialize_graph(g, directed);
  scanf(<span style="color: #ffa07a;">"%d %d"</span>, &amp;(g-&gt;nvertices), &amp;m);
  <span style="color: #00ffff;">for</span> (i = 1; i &lt;= m; ++i) {
    scanf(<span style="color: #ffa07a;">"$d %d"</span>, &amp;x, &amp;y);
    insert_edge(g, x, y, directed);
  }
}

<span style="color: #87cefa;">print_graph</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>) {
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">p</span>;
  <span style="color: #00ffff;">for</span> (i = 1; i &lt;= g-&gt;nvertices; ++i) {
    printf(<span style="color: #ffa07a;">"%d: "</span>, i);
    p = g-&gt;edges[i];
    <span style="color: #00ffff;">while</span> (p != <span style="color: #7fffd4;">NULL</span>) {
      printf(<span style="color: #ffa07a;">"%d "</span>, p-&gt;y);
      p = p-&gt;next;
    }
    printf(<span style="color: #ffa07a;">"\n"</span>);
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">5.5 Traversing a Graph</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The key idea behind graph traversal is to mark each vertex when we
first visit it and keep track of what we have not yet completely
explored. Although bread crumbs or unraveled threads have been used to
mark visited places in fairy-tale mazes, we will rely on Boolean flags
or enumerated types.
</p>

<p>
Each vertex will exist in one of three states:
</p>
<ul class="org-ul">
<li>undiscovered– the vertex is in its initial, virgin state.
</li>
<li>discovered– the vertex has been found, but we have not yet checked
out all its incident edges.
</li>
<li>processed– the vertex after we have visited all its incident edges.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">5.6 Breadth-First Search</h3>
<div class="outline-text-3" id="text-1-4">
<p>
先遍历完一个点的所有相邻点。
</p>

<div class="org-src-container">

<pre class="src src-c++">    <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">processed</span>[MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">which vertices have been processed */</span>
    <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">discovered</span>[MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">which vertices have been found */</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">parent</span>[MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">discovery relation */</span>

    <span style="color: #87cefa;">initialize_search</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>)
    {
      <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">counter */</span>
      <span style="color: #00ffff;">for</span> (i=1; i&lt;=g-&gt;nvertices; i++) {
        processed[i] = discovered[i] = FALSE;
        parent[i] = -1;
      }
    }

  <span style="color: #87cefa;">bfs</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">start</span>)
  {
    <span style="color: #98fb98;">queue</span> <span style="color: #eedd82;">q</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">queue of vertices to visit */</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">current vertex */</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">successor vertex */</span>
    <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">p</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">temporary pointer */</span>
    init_queue(&amp;q);
    enqueue(&amp;q,start);
    discovered[start] = TRUE;
    <span style="color: #00ffff;">while</span> (empty_queue(&amp;q) == FALSE) {
      v = dequeue(&amp;q);
      process_vertex_early(v);
      processed[v] = TRUE;
      p = g-&gt;edges[v];
      <span style="color: #00ffff;">while</span> (p != <span style="color: #7fffd4;">NULL</span>) {
        y = p-&gt;y;
        <span style="color: #00ffff;">if</span> ((processed[y] == FALSE) || g-&gt;directed)
          process_edge(v,y);
        <span style="color: #00ffff;">if</span> (discovered[y] == FALSE) {
          enqueue(&amp;q,y);
          discovered[y] = TRUE;
          parent[y] = v;
        }
        p = p-&gt;next;
      }
      process_vertex_late(v);
    }
  }

<span style="color: #87cefa;">find_path</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">start</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">end</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">parents</span>[])
{
  <span style="color: #00ffff;">if</span> ((start == end) || (end == -1))
    printf(<span style="color: #ffa07a;">"\n%d"</span>,start);
  <span style="color: #00ffff;">else</span> {
    find_path(start,parents[end],parents);
    printf(<span style="color: #ffa07a;">" %d"</span>,end);
  }
}
</pre>
</div>

<p>
Because vertices are discovered in order of increasing distance from the root,
this tree has a very important property. The unique tree path from the root to
each node x∈V uses the smallest number of edges (or equivalently, intermediate
nodes) possible on any root-to-xpath in the graph.
</p>

<p>
There are <b>two points</b> to remember when using breadth-first search to find a
shortest path fromxtoy: First, the shortest path tree is only useful if BFS was
performed with x as the root of the search. Second, BFS gives the shortest path
only if the graph is unweighted.
</p>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">5.7 Applications of Breadth-First Search</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Properly implemented using adjacency lists, any such algorithm is
destined to be linear, since BFS runs in O(n+m) time on both directed
and undirected graphs. This is optimal, since it is as fast as one can
hope to read any n-vertex, m-edge graph.
</p>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">5.8 Depth-First Search</h3>
<div class="outline-text-3" id="text-1-6">
<p>
The difference between BFS and DFS results is in the order in which they
explore vertices. This order depends completely upon the container
data structure used to store the discovered but not processed
vertices.
</p>

<ul class="org-ul">
<li>Queue– By storing the vertices in a first-in, first-out (FIFO)
queue, we explore the oldest unexplored vertices first. Thus our
explorations radiate out slowly from the starting vertex, defining a
breadth-first search.
</li>

<li>Stack– By storing the vertices in a last-in, first-out (LIFO) stack,
we explore the vertices by lurching along a path, visiting a new
neighbor if one is available, and backing up only when we are
surrounded by previously discovered vertices. Thus, our explorations
quickly wanderaway from our starting point, defining a depth-first
search.
</li>
</ul>

<p>
DFS organizes vertices by entry/exit times, and edges into tree and
back edges. This organization is what gives DFS its real power.
</p>

<p>
<b>Implementation</b>
</p>

<p>
The beauty of implementingdfsrecursively is that recursion eliminates
the need to keep an explicit stack:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #87cefa;">dfs</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>)
{
  <span style="color: #98fb98;">edgenode</span> *<span style="color: #eedd82;">p</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">temporary pointer */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">successor vertex */</span>
  <span style="color: #00ffff;">if</span> (finished) <span style="color: #00ffff;">return</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">allow for search termination */</span>
  discovered[v] = TRUE;
  time = time + 1;
  entry_time[v] = time;
  process_vertex_early(v);
  p = g-&gt;edges[v];
  <span style="color: #00ffff;">while</span> (p != <span style="color: #7fffd4;">NULL</span>) {
    y = p-&gt;y;
    <span style="color: #00ffff;">if</span> (discovered[y] == FALSE) {
      parent[y] = v;
      process_edge(v,y);
      dfs(g,y);
    }
    <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> ((!processed[y]) || (g-&gt;directed))
      process_edge(v,y);
    <span style="color: #00ffff;">if</span> (finished) <span style="color: #00ffff;">return</span>;
    p = p-&gt;next;
  }
  process_vertex_late(v);
  time = time + 1;
  exit_time[v] = time;
  processed[v] = TRUE;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">5.9 Applications of Depth-First Search</h3>
<div class="outline-text-3" id="text-1-7">
</div><ul class="org-ul"><li>Finding Cycles<br  /><div class="outline-text-4" id="text-1-7-1">
<p>
But any back edge going from x to an ancestorycreates a cycle with the
tree path fromytox. Such a cycle is easy to find using dfs:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #87cefa;">process_edge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>)
{
  <span style="color: #00ffff;">if</span> (parent[x] != y) { <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">found back edge! */</span>
    printf(<span style="color: #ffa07a;">"Cycle from %d to %d:"</span>,y,x);
    find_path(y,x,parent);
    printf(<span style="color: #ffa07a;">"\n\n"</span>);
    finished = TRUE;
  }
}
</pre>
</div>
</div>
</li>

<li>Articulation Vertices<br  /><div class="outline-text-4" id="text-1-7-2">
<p>
Observe that there is a single point of failure—a single vertex whose
deletion disconnects a connected component of the graph. Such a vertex
is called an articulation vertex or cut-node.
</p>

<p>
More robust graphs without such a vertex are said to be biconnected.
</p>

<p>
Temporarily delete each vertex v, and then do a BFS or DFS traversal
of the remaining graph to establish whether it is still connected. The
total time fornsuch traversals is O(n(m+n)). There is a clever
linear-time algorithm, however, that tests all the vertices of a
connected graph using a single depth-first search.
</p>

<p>
Let <code>reachable_ancestor[v]</code> denote the earliest reachable ancestor of
vertex v, meaning the oldest ancestor ofvthat we can reach by a
combination of tree edges and back edges. Initially,
<code>reachable_ancestor[v] = v</code>:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">reachable_ancestor</span>[MAXV+1]; <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">earliestreachableancestorofv*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">tree_out_degree</span>[MAXV+1];  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">DFStree outdegree ofv*/</span>
<span style="color: #87cefa;">process_vertex_early</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>)
{
  reachable_ancestor[v] = v;
}
</pre>
</div>

<p>
We update <code>reachable_ancestor[v]</code> whenever we encounter a back edge
that takes us to an earlier ancestor than we have previously seen. The
relative age/rank of our ancestors can be determined from
their <code>entry_time’s</code>:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #87cefa;">process_edge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #00ffff;">class</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">edge class */</span>
  <span style="color: #00ffff;">class</span> = edge_classification(x,y);
  <span style="color: #00ffff;">if</span> (<span style="color: #00ffff;">class</span> == TREE)
    tree_out_degree[x] = tree_out_degree[x] + 1;
  <span style="color: #00ffff;">if</span> ((<span style="color: #00ffff;">class</span> == BACK) &amp;&amp; (parent[x] != y)) {
    <span style="color: #00ffff;">if</span> (entry_time[y] &lt; entry_time[ reachable_ancestor[x] ] )
      reachable_ancestor[x] = y;
  }
}
</pre>
</div>

<p>
The key issue is determining how the reachability relation impacts
whether vertexv is an articulation vertex. There are three cases:
</p>
<ul class="org-ul">
<li>Root cut-nodes– If the root of the DFS tree has two or more
children, it must be an articulation vertex. No edges from the
subtree of the second child can possibly connect to the subtree of
the first child.
</li>

<li>Bridge cut-nodes– If the earliest reachable vertex fromvis v, then
deleting the single edge (parent[v],v) disconnects the graph.
Clearlyparent[v] must be an articulation vertex, since it cuts v from
the graph. Vertex vis also an articulation vertex unless it is a
leaf of the DFS tree. For any leaf, nothing falls off when you cut it.
</li>
<li>Parent cut-nodes– If the earliest reachable vertex fromvis the
parent of v, then deleting the parent must severvfrom the tree
unless the parent is the root.
</li>
</ul>


<div class="figure">
<p><img src="./images/articulation_vertices.jpg" alt="articulation_vertices.jpg" />
</p>
</div>

<p>
The routine below systematically evaluates each of the three
conditions as we back up from the vertex after traversing all outgoing
edges. We use <code>entry_time[v]</code> to represent the age of vertex v. The
reachability time <code>time_v</code> calculated below denotes the oldest vertex that
can be reached using back edges.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #87cefa;">process_vertex_late</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>)
{
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">root</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">is the vertex the root of the DFS tree? */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">time_v</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">earliest reachable time for v */</span>
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">time_parent</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">earliest reachable time for parent[v] */</span>
  <span style="color: #00ffff;">if</span> (parent[v] &lt; 1) { <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">test if v is the root */</span>
    <span style="color: #00ffff;">if</span> (tree_out_degree[v] &gt; 1)
      printf(<span style="color: #ffa07a;">"root articulation vertex: %d \n"</span>,v);
    <span style="color: #00ffff;">return</span>;
  }
  root = (parent[parent[v]] &lt; 1); <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">is parent[v] the root? */</span>
  <span style="color: #00ffff;">if</span> ((reachable_ancestor[v] == parent[v]) &amp;&amp; (!root))
    printf(<span style="color: #ffa07a;">"parent articulation vertex: %d \n"</span>,parent[v]);
  <span style="color: #00ffff;">if</span> (reachable_ancestor[v] == v) {
    printf(<span style="color: #ffa07a;">"bridge articulation vertex: %d \n"</span>,parent[v]);
    <span style="color: #00ffff;">if</span> (tree_out_degree[v] &gt; 0) <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">test if v is not a leaf */</span>
      printf(<span style="color: #ffa07a;">"bridge articulation vertex: %d \n"</span>,v);
  }
  time_v = entry_time[reachable_ancestor[v]];
  time_parent = entry_time[ reachable_ancestor[parent[v]] ];
  <span style="color: #00ffff;">if</span> (time_v &lt; time_parent)
    reachable_ancestor[parent[v]] = reachable_ancestor[v];
}
</pre>
</div>

<p>
We can alternately talk about reliability in terms of edge failures
instead of vertex failures. 
</p>

<p>
In fact
all bridges can be identified in the same O(n+m) time. Edge (x, y) is a
bridge if (1) it is a tree edge, and (2) no back edge connects from
yor below toxor above. This can be computed with a minor modification
of the <code>reachable_ancestor</code> function.
</p>
</div>
</li></ul>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">5.10 Depth-First Search on Directed Graphs</h3>
<div class="outline-text-3" id="text-1-8">
<p>
For directed graphs, depth-first search labelings can take on a wider
range of possibilities. Indeed, all four of the edge cases in Figure
below can occur in traversing directed graphs.
</p>


<div class="figure">
<p><img src="./images/edge_cases_for_traversl.jpg" alt="edge_cases_for_traversl.jpg" />
</p>
</div>

<p>
The correct labeling of each edge can be readily determined from the
state, discovery time, and parent of each vertex, as encoded in the
following function:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">edge_classification</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>)
{
  <span style="color: #00ffff;">if</span> (parent[y] == x) <span style="color: #00ffff;">return</span>(TREE);
  <span style="color: #00ffff;">if</span> (discovered[y] &amp;&amp; !processed[y]) <span style="color: #00ffff;">return</span>(BACK);
  <span style="color: #00ffff;">if</span> (processed[y] &amp;&amp; (entry_time[y]&gt;entry_time[x])) <span style="color: #00ffff;">return</span>(FORWARD);
  <span style="color: #00ffff;">if</span> (processed[y] &amp;&amp; (entry_time[y]&lt;entry_time[x])) <span style="color: #00ffff;">return</span>(CROSS);
  printf(<span style="color: #ffa07a;">"Warning: unclassified edge (%d,%d)\n"</span>,x,y);
}
</pre>
</div>
</div>

<ul class="org-ul"><li>Strongly Connected Components<br  /><div class="outline-text-4" id="text-1-8-1">
<p>
A directed graph isstrongly connectedif there is a directed path
between any two vertices.
</p>


<div class="figure">
<p><img src="./images/strongly_connected_components.jpg" alt="strongly_connected_components.jpg" />
</p>
</div>

<p>
The algorithm is based on the observation that it is easy to find a
directed cycle using a depth-first search, since any back edge plus
the down path in the DFS tree gives such a cycle. All vertices in this
cycle must be in the same strongly connected component. Thus, we can
shrink (contract) the vertices on this cycle down to a single vertex
representing the component, and then repeat. This process terminates
when no directed cycle remains, and each vertex represents a different
strongly connected component.
</p>

<p>
We update our notion of the oldest reachable vertex in response to (1)
nontree edges and (2) backing up from a vertex.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #87cefa;">strong_components</span>(<span style="color: #98fb98;">graph</span> *<span style="color: #eedd82;">g</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">counter */</span>
  <span style="color: #00ffff;">for</span> (i=1; i&lt;=(g-&gt;nvertices); i++) {
    low[i] = i;
    scc[i] = -1;
  }
  components_found = 0;
  init_stack(&amp;active);
  initialize_search(&amp;g);
  <span style="color: #00ffff;">for</span> (i=1; i&lt;=(g-&gt;nvertices); i++)
    <span style="color: #00ffff;">if</span> (discovered[i] == FALSE) {
      dfs(g,i);
    }
}
</pre>
</div>

<p>
Define low[v]to be the oldest vertex known to be in the same strongly
connected component asv. This vertex is not necessarily an ancestor,
but may also be a distant cousin of v because of cross edges. Cross
edges that point vertices from previous strongly connected components
of the graph cannot help us, because there can be no way back from
them tov, but otherwise cross edges are fair game. Forward edges have
no impact on reachability over the depth-first tree edges, and hence
can be disregarded:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">low</span>[MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">oldest vertex surely in component of v */</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">scc</span>[MAXV+1]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">strong component number for each vertex */</span>
<span style="color: #87cefa;">process_edge</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">y</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #00ffff;">class</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">edge class */</span>
  <span style="color: #00ffff;">class</span> = edge_classification(x,y);
  <span style="color: #00ffff;">if</span> (<span style="color: #00ffff;">class</span> == BACK) {
    <span style="color: #00ffff;">if</span> (entry_time[y] &lt; entry_time[ low[x] ] )
      low[x] = y;
  }
  <span style="color: #00ffff;">if</span> (<span style="color: #00ffff;">class</span> == CROSS) {
    <span style="color: #00ffff;">if</span> (scc[y] == -1) <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">component not yet assigned */</span>
      <span style="color: #00ffff;">if</span> (entry_time[y] &lt; entry_time[ low[x] ] )
        low[x] = y;
  }
}
</pre>
</div>

<p>
A new strongly connected component is found whenever the lowest reachable
vertex fromvis v. If so, we can clear the stack of this component.
Otherwise, we give our parent the benefit of the oldest ancestor we
can reach and backtrack:
</p>

<div class="org-src-container">

<pre class="src src-c++">  <span style="color: #87cefa;">process_vertex_early</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>)
  {
    push(&amp;active,v);
  }

<span style="color: #87cefa;">process_vertex_late</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>)
{
  <span style="color: #00ffff;">if</span> (low[v] == v) { <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">edge (parent[v],v) cuts off scc */</span>
    pop_component(v);
  }
  <span style="color: #00ffff;">if</span> (entry_time[low[v]] &lt; entry_time[low[parent[v]]])
    low[parent[v]] = low[v];
}

<span style="color: #87cefa;">pop_component</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">v</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">t</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">vertex placeholder */</span>
  components_found = components_found + 1;
  scc[ v ] = components_found;
  <span style="color: #00ffff;">while</span> ((t = pop(&amp;active)) != v) {
    scc[ t ] = components_found;
  }
}
</pre>
</div>
</div>
</li></ul>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Exercises</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">5</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Give a linear algorithm to compute the chromatic number of graphs
where each vertex has degree at most 2. Must such graphs be bipartite?
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">7</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Given pre-order and in-order traversals of a binary tree, is it
possible to reconstruct the tree? If so, sketch an algorithm to do it.
If not, give a counterexample. Repeat the problem if you are given the
pre-order and post-order traversals.
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">10</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Suppose an arithmetic expression is given as a DAG (directed acyclic
graph) with common subexpressions removed. Each leaf is an integer
and each internal node is one of the standard arithmetical operations
( + , − , * , / ). For example, the expression 2 + 3 * 4 + (3 * 4) /
5 is represented by the DAG in Figure (see book)(b). Give an O(n + m)
algorithm for evaluating such a DAG, where there are n nodes and m
edges in the DAG. Hint: modify an algorithm for the tree case to
achieve the desired efficiency.
</p>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">12</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The square of a directed graph G = (V,E) is the graph G2 = (V,E2) such
that  iff there exists  such that  and ; i.e., there is a path of
exactly two edges from u to w. square of a graph Give efficient
algorithms for both adjacency lists and matrices.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">cc</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">

<pre class="src src-c++"></pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2014-06-11 Wed 19:53</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.50.1 (<a href="http://orgmode.org">Org</a> mode 8.2.3a)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
