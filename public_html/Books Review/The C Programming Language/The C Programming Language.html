<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>The C Programming Language Notes</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="title" content="The C Programming Language Notes"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-08-07 00:01:47 HKT"/>
<meta name="author" content="Shi Shougang"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="stylesheet" href="./assets/stylesheet.css" type="text/css"/>
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="org-div-home-and-up" style="text-align:right;font-size:70%;white-space:nowrap;">
 <a accesskey="h" href="../../index.html"> UP </a>
 |
 <a accesskey="H" href="../../index.html"> HOME </a>
</div>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">The C Programming Language Notes</h1>

<p><a href="http://cm.bell-labs.com/cm/cs/cbook/">The C Programming Language</a>, second edition by <a href="http://www.cs.bell-labs.com/who/bwk/">Kernighan</a> and <a href="http://www.cs.bell-labs.com/who/dmr/">Ritchie</a>.
</p>
<p>
Other people working through the book may be interested in the <a href="http://www.eskimo.com/~scs/cclass/krnotes/top.html">Notes to Accompany The C Programming Language</a> by <a href="http://www.eskimo.com/~scs/">Steve Summit</a>, maintainer of
the <a href="http://c-faq.com/versions.html">comp.lang.c FAQ</a>. Also be aware of the <a href="http://cm.bell-labs.com/cm/cs/cbook/2ediffs.html">errata</a>.
</p>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Answers</a></li>
<li><a href="#sec-2">Chapter 1</a></li>
<li><a href="#sec-3">Chapter 2</a></li>
<li><a href="#sec-4">Chapter 4</a></li>
<li><a href="#sec-5">Chapter 5</a></li>
<li><a href="#sec-6">Chapter 6</a></li>
<li><a href="#sec-7">Chapter 7</a></li>
<li><a href="#sec-8">Chapter 8</a></li>
<li><a href="#sec-9">Appendix A: Reference Manual</a></li>
<li><a href="#sec-10">Appendix B - Standard Library</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Answers</h2>
<div class="outline-text-2" id="text-1">

<ul>
<li>There is a book, <a href="./The C Answer Book.pdf">The C Answer Book by Tondo and Gimpel</a>, that has
  answers to these exercises. 

</li>
<li><a href="http://www.bamsoftware.com/computers/tcpl-answers.tar.gz">The answer</a> by <a href="http://www.bamsoftware.com/computers/tcpl-answers.html">bamsoftware</a>.

</li>
<li><a href="http://clc-wiki.net/wiki/K&amp;R2_solutions">Another site</a> (based on an <a href="http://users.powernet.co.uk/eton/kandr2/">older one</a>) that has answers to most of the exercises.
</li>
</ul>


</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Chapter 1</h2>
<div class="outline-text-2" id="text-2">

<ul>
<li id="sec-2-1">page 5<br/>
The only way to learn a new programming language is by writing
programs in it.
</li>
</ul>
<ul>
<li id="sec-2-2">page 11<br/>
you must match up the arguments to printf with the conversion specification; the compiler can't (or won't) generally check them for you or fix things up if you get them wrong. If fahr is a float, the code

<p>
        <code>printf("%d\n", fahr);</code>
</p>
<p>
will not work. You might ask, ``Can't the compiler see that %d needs
an integer and fahr is floating-point and do the conversion
automatically, just like in the assignments and comparisons on page
12?'' And the answer is, no. As far as the compiler knows, you've just
passed a character string and some other arguments to printf; it
doesn't know that there's a connection between the arguments and some
special characters inside the string. This is one of the implications
of the fact, stated earlier, that functions like printf are not
special.
</p></li>
</ul>
<ul>
<li id="sec-2-3">page 15<br/>
Notice that there is no semicolon at the end of a #define line.

<p>
Actually, all lines that begin with # are special; we'll learn more
about them later.
</p></li>
</ul>
<ul>
<li id="sec-2-4">page 16<br/>



<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>;
c = getchar();
</pre>

<p>
We must declare <code>c</code> to be a type big enough to hold any value that
<code>getchar</code> returns. We can't use <code>char</code> since <code>c</code> must be big enough to
hold <code>EOF</code> in addition to any possible <code>char</code>. Therefore we use <code>int</code>.
</p></li>
</ul>
<ul>
<li id="sec-2-5">page 17<br/>
The line <code>while ((c = getchar()) !</code> EOF)= epitomizes the cryptic
brevity which C is notorious for. 

<p>
We have four things to do:
</p>
<ol>
<li>call <code>getchar</code>,
</li>
<li>assign its return value to a variable,
</li>
<li>test the return value against <code>EOF</code>, and
</li>
<li>process the character (in this case, print it again).
</li>
</ol>


<p>
how do you send EOF? The answer depends on what kind of computer
you're using. On Unix and Unix-related systems, it's almost always
control-D. On MS-DOS machines, it's control-Z followed by the RETURN
key. Under Think C on the Macintosh, it's control-D, just like Unix.
On other systems, you may have to do some research to learn how to
send EOF.
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Chapter 2</h2>
<div class="outline-text-2" id="text-3">


<ul>
<li id="sec-3-1">page 39<br/>
Be careful to distinguish between a character constant and a string
that contains a single character: 'x' is not the same as "x". The
former is an integer used to produce the numeric value of the letter x
in the machine;s character set. The latter is an array of characters
that contains one character( the letter x) and a '\0'.

<p>
Name in different enumerations must be distinct. Values need not be
distinct in the same enumeration.
</p></li>
</ul>
<ul>
<li id="sec-3-2">page 40<br/>
External and static variables are initialized to zero by default.

</li>
</ul>
<ul>
<li id="sec-3-3">page 41<br/>
The % operator cannot be applied to <code>float</code> or <code>double</code>. The direction
of truncation for / and the sign of the result for % are
machine-dependent for negative operands, as is the action taken on
overflow or underflow. This means that -7 / 4 might be -1 or -2, and
-7 % 4 might be -3 or +1. 

</li>
</ul>
<ul>
<li id="sec-3-4">page 44<br/>
the lower type is promoted to the higher type, where the order of the
types is 
 <code>char &lt; short int &lt; int &lt; long int &lt; float &lt; double &lt; long double</code>
</li>
</ul>
<ul>
<li id="sec-3-5">page 45<br/>
Casts can be a bit confusing at first. A cast is the syntax used to
request an explicit type conversion; coercion is just a more formal
word for ``conversion.'' 
</li>
</ul>
<ul>
<li id="sec-3-6">page 46<br/>
The authors point out that an expression like (i+j)++ is illegal, and
it's worth thinking for a moment about why. The ++ operator doesn't
just mean ``add one''; it means ``add one to a variable'' or ``make a
variable's value one more than it was before.'' But (i+j) is not a
variable, it's an expression; so there's no place for ++ to store the
incremented result. 


</li>
</ul>
<ul>
<li id="sec-3-7">page 52 Precedence and Order of Evaluation<br/>
To look at one more example, it might seem that the code



<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 7;
printf(<span style="color: #ffa07a;">"%d\n"</span>, i++ * i++);
</pre>

<p>
would have to print 56, because no matter which order the increments
        happen in, 7x8 is 8x7 is 56. But ++ just says that the
        increment happens later, not that it happens immediately, so
        this code could print 49 (if it chose to perform the
        multiplication first, and both increments later). And, it
        turns out that ambiguous expressions like this are such a bad
        idea that the ANSI C Standard does not require compilers to do
        anything reasonable with them at all, such that the above code
        might end up printing 42, or 8923409342, or 0, or crashing
        your computer.
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Chapter 4</h2>
<div class="outline-text-2" id="text-4">


<ul>
<li id="sec-4-1">page 77<br/>
<code>push(pop() - pop());   /* WRONG */</code>

<p>
Because + and * are commutative operations, the order in which the
popped operands are combined is irrelevant, but for - and / the left
and right operands must be distinguished. In the above, the order in
which the two calls of <code>pop</code> are evaluated is not defined. To
guarantee the right order, it is necessary to pop the first value into
a temporary variable as we did in = 
</p></li>
</ul>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">Chapter 5</h2>
<div class="outline-text-2" id="text-5">


<ul>
<li id="sec-5-1">page 96<br/>
the swap example on page 96 does work.



<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap1</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">q1</span>,<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">q2</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span>;
  temp = *q1;
  *q1 = *q2;
  *q2 = temp;
}
</pre>

<p>
But this swap does not work.
</p>


<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap2</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">q1</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">q2</span>)
{
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">temp</span>;
  temp = q1;
  q1 = q2;
  q2 = temp;
}
</pre>

</li>
</ul>
<ul>
<li id="sec-5-2">page 99<br/>
This explains, among other things, how getline and getop were able to
modify the arrays in the caller, even though we said that
call-by-value meant that functions can't modify variables in their
callers since they receive copies of the parameters. When a function
receives a pointer, it cannot modify the original pointer in the
caller, but it can definitely modify what the pointer points to. 
</li>
</ul>
<ul>
<li id="sec-5-3">page 104<br/>
As an example of what we can and can't do, given the lines



<pre class="src src-c"><span style="color: #98fb98;">char</span> <span style="color: #eedd82;">amessage</span>[] = <span style="color: #ffa07a;">"now is the time"</span>;
<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">pmessage</span> = <span style="color: #ffa07a;">"now is the time"</span>;
</pre>

<p>
we could say
</p>


<pre class="src src-c">amessage[0] = <span style="color: #ffa07a;">'N'</span>;
</pre>

<p>
to make amessage say "Now is the time". But if we tried to do
</p>


<pre class="src src-c">pmessage[0] = <span style="color: #ffa07a;">'N'</span>;
</pre>

<p>
(which, as you may recall, is equivalent to =*pmessage = 'N'=), it would
not necessarily work; we're not allowed to modify that string. (One
reason is that the compiler might have placed the ``little block of
characters'' in read-only memory. Another reason is that if we had
written
</p>


<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">pmessage</span> = <span style="color: #ffa07a;">"now is the time"</span>;
<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">qmessage</span> = <span style="color: #ffa07a;">"now is the time"</span>;
</pre>

<p>
the compiler might have used the same little block of memory to
initialize both pointers, and we wouldn't want a change to one to
alter the other.) 
</p>
</li>
</ul>
<ul>
<li id="sec-5-4">page 112<br/>

<p class="verse">
More generally, only the first dimension (subscript) of an array is free; all the others have to be specified.<br/>
</p>


<p>
This just says what we said already: when declaring an array as a
function parameter, you can leave off the first dimension because it
is the overall length and not knowing it causes no immediate problems
(unless you accidentally go off the end). But the compiler always
needs to know the other dimensions, so that it knows how the rown and
columns line up.
</p>
<p>
If a two-dimensional array is to be passed to a function, the
parameter declaration in the function must include the number of
columns; the number of rows i irrelevant, since what is passed is, as
before, a pointer to an array of rows, where each row is an array of
13 ints.
</p></li>
</ul>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">Chapter 6</h2>
<div class="outline-text-2" id="text-6">

<ul>
<li id="sec-6-1">page 135<br/>
<code>sizeof</code> returns the size counted in bytes, where the C definition of
``byte'' is ``the size of a char.'' In other words, <code>sizeof(char)</code> is
always 1. (It turns out that it's not necessarily the case, though,
that a byte or a char is 8 bits.) 
</li>
</ul>
<ul>
<li id="sec-6-2">page 138<br/>

<p class="verse">
Don't assume, however, that the size of a structure is the sum of the sizes of its members.<br/>
</p>


<p>
If this isn't the sort of thing you'd be likely to assume, you don't
have to remember the reason, which is mildly esoteric (having to do
with memory alignment requirements).
</p></li>
</ul>
<ul>
<li id="sec-6-3">page 142<br/>
We can test for this in two different ways, either before or after we
make the ``last'' recursive call:



<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">treeprint</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #eedd82;">p</span>)
{
        <span style="color: #00ffff;">if</span>(p-&gt;left != <span style="color: #7fffd4;">NULL</span>)
                treeprint(p-&gt;left);
        printf(<span style="color: #ffa07a;">"%4d %s\n"</span>, p-&gt;count, p-&gt;word);
        <span style="color: #00ffff;">if</span>(p-&gt;right != <span style="color: #7fffd4;">NULL</span>)
                treeprint(p-&gt;right);
}
</pre>

<p>
or
</p>


<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">treeprint</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tnode</span> *<span style="color: #eedd82;">p</span>)
{
        <span style="color: #00ffff;">if</span>(p == <span style="color: #7fffd4;">NULL</span>)
                <span style="color: #00ffff;">return</span>;

        treeprint(p-&gt;left);
        printf(<span style="color: #ffa07a;">"%4d %s\n"</span>, p-&gt;count, p-&gt;word);
        treeprint(p-&gt;right);
}
</pre>

<p>
Sometimes, there's little difference between one approach and the
other. Here, though, the second approach (which is
                equivalent to the code on page 142) has a distinct
                advantage: it will work even if the very first call is
                on an empty tree (in this case, if there were no words
                in the input). As we mentioned earlier, it's extremely
                nice if programs work well at their boundary
                conditions, even if we don't think those conditions
                are likely to occur.
</p>
</li>
</ul>
<ul>
<li id="sec-6-4">page 143<br/>



<pre class="src src-c"><span style="color: #98fb98;">char</span> <span style="color: #eedd82;">str</span>[] = <span style="color: #ffa07a;">"a"</span>;
<span style="color: #00ffff;">sizeof</span>(str); <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">2</span><span style="color: #ff7f24;">*/</span>
strlen(str); <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">1</span><span style="color: #ff7f24;">*/</span>
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">Chapter 7</h2>
<div class="outline-text-2" id="text-7">

<ul>
<li id="sec-7-1">page 152<br/>
Note that the stdio library generally does newline translation for
you. If you know that lines are terminated by a linefeed on Unix and a
carriage return on the Macintosh and a carriage-return/linefeed
combination on MS-DOS, you don't have to worry about these things in
C, because the line termination will always appear to a C program to
be a single '\n'.

</li>
</ul>
<ul>
<li id="sec-7-2">page 166<br/>
strstr(s,t)     return pointer to first t in s, or NULL if not present

</li>
</ul>
<ul>
<li id="sec-7-3">page 168(Random Number Gneration)<br/>
the code for returning a floating-point random number in the interval [0,1) should be

<p>
        <code>#define frand() ((double) rand() / (RAND_MAX+1.0))</code>
If you want to get random integers from M to N, you can use something like
</p>
<p>
        <code>M + (int)(frand() * (N-M+1))</code>
</p>
<p>
``[Setting] the seed for rand'' refers to the fact that, by default,
the sequence of pseudo-random numbers returned by rand is the same
each time your program runs. To randomize it, you can call srand at
the beginning of the program, handing it some truly random number,
such as a value having to do with the time of day. (One way is with
code like
</p>


<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;time.h&gt;</span>
srand((<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>)time((<span style="color: #98fb98;">time_t</span> *)<span style="color: #7fffd4;">NULL</span>));
</pre>

<p>
which uses the time function mentioned on page 256 in appendix B10.)
</p>
<p>
One other caveat about rand: don't try to generate random 0/1 values (to simulate a coin flip, perhaps) with code like
</p>
<p>
        <code>rand() % 2</code>
This looks like it ought to work, but it turns out that on some systems rand isn't always perfectly random, and returns values which consistently alternate even, odd, even, odd, etc. (In fact, for similar reasons, you shouldn't usually use rand() % N for any value of N.) A good way to get random 0/1 values would be
        <code>(int)(frand() * 2)</code>
based on the other frand() examples above.
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8">Chapter 8</h2>
<div class="outline-text-2" id="text-8">

</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9">Appendix A: Reference Manual</h2>
<div class="outline-text-2" id="text-9">

<ul>
<li id="sec-9-1">A.2.5.2 Character Constants<br/>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" /><col class="left" /><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Name</th><th scope="col" class="left">Abstract</th><th scope="col" class="left">character</th><th scope="col" class="left">Name</th><th scope="col" class="left">Abstract</th><th scope="col" class="left">Character</th></tr>
</thead>
<tbody>
<tr><td class="left">newline</td><td class="left">NT(LF)</td><td class="left">\n</td><td class="left">backslash</td><td class="left">\</td><td class="left">\\</td></tr>
<tr><td class="left">horizontal tab</td><td class="left">HT</td><td class="left">\t</td><td class="left">question mark</td><td class="left">?</td><td class="left">\?</td></tr>
<tr><td class="left">vertical</td><td class="left">VT</td><td class="left">\v</td><td class="left">single quote</td><td class="left">'</td><td class="left">\'</td></tr>
<tr><td class="left">backspace</td><td class="left">BS</td><td class="left">\b</td><td class="left">double quote</td><td class="left">"</td><td class="left">\"</td></tr>
<tr><td class="left">carriage return</td><td class="left">CR</td><td class="left">\r</td><td class="left">octal number</td><td class="left">ooo</td><td class="left">\ooo</td></tr>
<tr><td class="left">audible</td><td class="left">BEL</td><td class="left">\a</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
</tbody>
</table>


</li>
</ul>
<ul>
<li id="sec-9-2">A.8.6.1 Pointer Declarators<br/>
In a declaration T D where D has the form
 <code>*</code> type-qualifier-list<sub>opt</sub> D1
and the type of the identifier in the declaration T D1 is ``type-modifier T,'' the type of the
identifier of D is ``type-modifier type-qualifier-list pointer to T.'' Qualifiers following * apply
to pointer itself, rather than to the object to which the pointer points.

<p>
For example, consider the declaration
int *ap[];
</p>
<p>
Here, ap[] plays the role of D1; a declaration ``int ap[]'' (below) would give ap the type
``array of int,'' the type-qualifier list is empty, and the type-modifier is ``array of.'' Hence the
actual declaration gives ap the type ``array to pointers to int.''
</p></li>
</ul>
<ul>
<li id="sec-9-3">A.8.8 Type names<br/>



<pre class="src src-c"><span style="color: #98fb98;">int</span> 
<span style="color: #98fb98;">int</span> * 
<span style="color: #98fb98;">int</span> *[3]
<span style="color: #98fb98;">int</span> (*)[]
<span style="color: #98fb98;">int</span> *()
<span style="color: #98fb98;">int</span> (*[])(<span style="color: #98fb98;">void</span>)
</pre>

<p>
name respectively the types ``integer,'' ``pointer to integer,'' ``array of 3 pointers to integers,''
``pointer to an unspecified number of integers,'' ``function of unspecified parameters returning
pointer to integer,'' and ``array, of unspecified size, of pointers to functions with no
parameters each returning an integer.''
</p></li>
</ul>
<ul>
<li id="sec-9-4">A.12.3 Macro Definition and Expansion<br/>

<p>
First, if an occurrence of a
parameter in the replacement token sequence is immediately preceded by #, string quotes (")
are placed around the corresponding parameter, and then both the # and the parameter
identifier are replaced by the quoted argument. A \ character is inserted before each " or \
character that appears surrounding, or inside, a string literal or character constant in the
argument.
</p>
<p>
Second, if the definition token sequence for either kind of macro contains a ## operator, then
just after replacement of the parameters, each ## is deleted, together with any white space on
either side, so as to concatenate the adjacent tokens and form a new token. The effect is
undefined if invalid tokens are produced, or if the result depends on the order of processing of
the ## operators. Also, ## may not appear at the beginning or end of a replacement token
sequence.
</p>
<p>
Given the definition
</p>


<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">tempfile</span>(<span style="color: #eedd82;">dir</span>) #dir <span style="color: #ffa07a;">"%s"</span>
</pre>

<p>
the macro call <code>tempfile(/usr/tmp)</code> yields
</p>
<p>
 "/usr/tmp" "%s"
</p>
<p>
which will subsequently be catenated into a single string. After
</p>


<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">cat</span>(<span style="color: #eedd82;">x</span>, <span style="color: #eedd82;">y</span>) x ## y
</pre>


<p>
the call <code>cat(var, 123)</code> yields var123. However, the call <code>cat(cat(1,2),3)</code> is undefined:
the presence of ## prevents the arguments of the outer call from being expanded. Thus it
produces the token string
</p>
<p>
<code>cat ( 1 , 2 )3</code>
</p>
<p>
and )3 (the catenation of the last token of the first argument with the first token of the second)
is not a legal token. If a second level of macro definition is
introduced,
</p>


<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">xcat</span>(<span style="color: #eedd82;">x</span>, <span style="color: #eedd82;">y</span>)  cat(x,y)
</pre>

<p>
things work more smoothly; <code>xcat(xcat(1, 2), 3)</code> does produce 123, because the
expansion of xcat itself does not involve the ## operator.
</p></li>
</ul>
<ul>
<li id="sec-9-5">A.12.7 Error Generation<br/>
A preprocessor line of the form
 # error token-sequence<sub>opt</sub>
causes the preprocessor to write a diagnostic message that includes the token sequence.
</li>
</ul>
<ul>
<li id="sec-9-6">A.12.8 Pragmas<br/>
A control line of the form
 # pragma token-sequence<sub>opt</sub>
causes the preprocessor to perform an implementation-dependent action. An unrecognized
pragma is ignored.
</li>
</ul>
<ul>
<li id="sec-9-7">A.12.10 Predefined names<br/>
Several identifiers are predefined, and expand to produce special information. They, and also
the preprocessor expansion operator defined, may not be undefined or
redefined.

<ul>
<li>_<sub>LINE</sub>__ A decimal constant containing the current source line number.
</li>
<li>_<sub>FILE</sub>__ A string literal containing the name of the file being compiled.
</li>
<li>_<sub>DATE</sub>__ A string literal containing the date of compilation, in the form "Mmmm dd yyyy"
</li>
<li>_<sub>TIME</sub>__ A string literal containing the time of compilation, in the form "hh:mm:ss"
</li>
<li>_<sub>STDC</sub>__ The constant 1. It is intended that this identifier be
  defined to be 1 only in standard-conforming implementations.
</li>
</ul>





</li>
</ul>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10">Appendix B - Standard Library</h2>
<div class="outline-text-2" id="text-10">




<pre class="src src-c">&lt;assert.h&gt; &lt;ctype.h&gt; &lt;errno.h&gt; &lt;<span style="color: #98fb98;">float</span>.h&gt; &lt;limits.h&gt;
&lt;locale.h&gt; &lt;math.h&gt; &lt;setjmp.h&gt; &lt;signal.h&gt; &lt;stdarg.h&gt;
&lt;stddef.h&gt; &lt;stdio.h&gt; &lt;stdlib.h&gt; &lt;string.h&gt; &lt;time.h&gt;
</pre>

<ul>
<li id="sec-10-1">B.2 Character Class Tests: &lt;ctype.h&gt;<br/>



<pre class="src src-c">isalnum(c) isalpha(c) <span style="color: #98fb98;">or</span> <span style="color: #87cefa;">isdigit</span>(c) is <span style="color: #7fffd4;">true</span>
isalpha(c)
isupper(c) <span style="color: #98fb98;">or</span> <span style="color: #87cefa;">islower</span>(c) is <span style="color: #7fffd4;">true</span>
iscntrl(c) control <span style="color: #98fb98;">character</span>
<span style="color: #87cefa;">isdigit</span>(c) decimal <span style="color: #98fb98;">digit</span>
<span style="color: #87cefa;">isgraph</span>(c) printing <span style="color: #98fb98;">character</span> except <span style="color: #98fb98;">space</span>
<span style="color: #87cefa;">islower</span>(c) lower-<span style="color: #00ffff;">case</span> letter
isprint(c) printing <span style="color: #98fb98;">character</span> including <span style="color: #98fb98;">space</span>
<span style="color: #87cefa;">ispunct</span>(c) printing <span style="color: #98fb98;">character</span> except <span style="color: #98fb98;">space</span> <span style="color: #98fb98;">or</span> letter <span style="color: #98fb98;">or</span> <span style="color: #98fb98;">digit</span>
<span style="color: #87cefa;">isspace</span>(c) space, formfeed, newline, carriage <span style="color: #00ffff;">return</span>, tab, vertical <span style="color: #98fb98;">tab</span>
<span style="color: #87cefa;">isupper</span>(c) upper-<span style="color: #00ffff;">case</span> letter
isxdigit(c) hexadecimal <span style="color: #98fb98;">digit</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">tolower</span>(c) convert c <span style="color: #98fb98;">to</span> <span style="color: #87cefa;">lower</span> <span style="color: #00ffff;">case</span>
<span style="color: #98fb98;">int</span> toupper(c) convert c <span style="color: #98fb98;">to</span> <span style="color: #eedd82;">upper</span> <span style="color: #00ffff;">case</span>
</pre>

</li>
</ul>
<ul>
<li id="sec-10-2">B.5 Utility Functions: &lt;stdlib.h&gt;<br/>

<ul>
<li>double atof(const char <b>s) atof converts s to double; it is equivalent to strtod(s, (char*</b>)NULL).
</li>
<li>int atoi(const char <b>s) converts s to int; it is equivalent to (int)strtol(s, (char*</b>)NULL, 10).
</li>
<li>long atol(const char <b>s) converts s to long; it is equivalent to strtol(s, (char*</b>)NULL, 10).
</li>
<li>double strtod(const char *s, char **endp) strtod converts the prefix
  of s to double, ignoring leading white space; it stores a pointer to
  any unconverted suffix in *endp unless endp is NULL. If the answer
  would overflow, HUGE<sub>VAL</sub> is returned with the proper sign; if the
  answer would underflow, zero is returned. In either case errno is set to ERANGE.
</li>
<li>long strtol(const char *s, char **endp, int base) strtol converts
  the prefix of s to long, ignoring leading white space; it stores a
  pointer to any unconverted suffix in *endp unless endp is NULL. If
  base is between 2 and 36, conversion is done assuming that the input
  is written in that base. If base is zero, the base is 8, 10, or 16;
  leading 0 implies octal and leading 0x or 0X hexadecimal. Letters in
  either case represent digits from 10 to base-1; a leading 0x or 0X
  is permitted in base 16. If the answer would overflow, LONG<sub>MAX</sub> or
  LONG<sub>MIN</sub> is returned, depending on the sign of the result, and errno
  is set to ERANGE.
</li>
<li>unsigned long strtoul(const char *s, char **endp, int base)  strtoul
  is the same as strtol except that the result is unsigned long and
  the error value is ULONG<sub>MAX</sub>.
</li>
<li>int rand(void) rand returns a pseudo-random integer in the range 0
  to RAND<sub>MAX</sub>, which is at least 32767.
</li>
<li>void srand(unsigned int seed) srand uses seed as the seed for a new
  sequence of pseudo-random numbers. The initial seed is 1.
</li>
<li>void *calloc(size<sub>t</sub> nobj, size<sub>t</sub> size) calloc returns a pointer to
  space for an array of nobj objects, each of size size, or NULL if
  the request cannot be satisfied. The space is initialized to zero
  bytes.

</li>
<li>void *malloc(size<sub>t</sub> size) malloc returns a pointer to space for an
  object of size size, or NULL if the request cannot be satisfied. The space is uninitialized.
</li>
<li>void *realloc(void *p, size<sub>t</sub> size) realloc changes the size of the
  object pointed to by p to size. The contents will be unchanged up to
  the minimum of the old and new sizes. If the new size is larger, the
  new space is uninitialized. realloc returns a pointer to the new
  space, or NULL if the request cannot be satisfied, in which case *p is unchanged.
</li>
<li>void free(void *p)  free deallocates the space pointed to by p; it
  does nothing if p is NULL. p must be a pointer to space previously
  allocated by calloc, malloc, or realloc.

</li>
<li>void abort(void)  abort causes the program to terminate abnormally, as if by raise(SIGABRT).
</li>
<li>void exit(int status) exit causes normal program termination. atexit
  functions are called in reverse order of registration, open files
  are flushed, open streams are closed, and control is returned to the
  environment. How status is returned to the environment is
  implementation- dependent, but zero is taken as successful
  termination. The values EXIT<sub>SUCCESS</sub> and EXIT<sub>FAILURE</sub> may also be used.
</li>
<li>int atexit(void (*fcn)(void))  atexit registers the function fcn to
  be called when the program terminates normally; it returns non-zero
  if the registration cannot be made.

</li>
<li>int system(const char *s)  system passes the string s to the
  environment for execution. If s is NULL, system returns non-zero if
  there is a command processor. If s is not NULL, the return value is
  implementation-dependent.

</li>
<li>char *getenv(const char *name)  getenv returns the environment
  string associated with name, or NULL if no string exists. Details are implementation-dependent.
</li>
<li>void *bsearch(const void *key, const void *base, size<sub>t</sub> n, size<sub>t</sub>
  size, int (*cmp)(const void *keyval, const void *datum)) bsearch
  searches base<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup>&hellip;base[n-1] for an item that matches *key. The
  function cmp must return negative if its first argument (the search
  key) is less than its second (a table entry), zero if equal, and
  positive if greater. Items in the array base must be in ascending
  order. bsearch returns a pointer to a matching item, or NULL if none
  exists.

</li>
<li>void qsort(void *base, size<sub>t</sub> n, size<sub>t</sub> size, int (*cmp)(const void
  *, const void *)) qsort sorts into ascending order an array
  base<sup><a class="footref" name="fnr.1.2" href="#fn.1">1</a></sup>&hellip;base[n-1] of objects of size size. The comparison function cmp is as in bsearch.
</li>
<li>int abs(int n) abs returns the absolute value of its int argument.
</li>
<li>long labs(long n) labs returns the absolute value of its long argument.
</li>
<li>div<sub>t</sub> div(int num, int denom) div computes the quotient and
  remainder of num/denom. The results are stored in the int members
  quot and rem of a structure of type div<sub>t</sub>.

</li>
<li>ldiv<sub>t</sub> ldiv(long num, long denom) ldiv computes the quotient and
  remainder of num/denom. The results are stored in the long members
  quot and rem of a structure of type ldiv<sub>t</sub>
</li>
</ul>





</li>
</ul>
<ul>
<li id="sec-10-3">B.7 Variable Argument Lists: &lt;stdarg.h&gt;<br/>
The header &lt;stdarg.h&gt; provides facilities for stepping through a list of function arguments
of unknown number and type.



<pre class="src src-c"><span style="color: #98fb98;">va_list</span> <span style="color: #eedd82;">ap</span>;
va_start(<span style="color: #98fb98;">va_list</span> <span style="color: #eedd82;">ap</span>, lastarg);
<span style="color: #98fb98;">type</span> <span style="color: #87cefa;">va_arg</span>(<span style="color: #98fb98;">va_list</span> <span style="color: #eedd82;">ap</span>, <span style="color: #98fb98;">type</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">va_end</span>(<span style="color: #98fb98;">va_list</span> <span style="color: #eedd82;">ap</span>);
</pre>

</li>
</ul>
<ul>
<li id="sec-10-4">B.8 Non-local Jumps: &lt;setjmp.h&gt;<br/>
The declarations in &lt;setjmp.h&gt; provide a way to avoid the normal function call and return
sequence, typically to permit an immediate return from a deeply nested function call.
<ul>
<li>int setjmp(jmp<sub>buf</sub> env)
</li>
</ul>


<p>
The macro setjmp saves state information in env for use by longjmp. The return is
zero from a direct call of setjmp, and non-zero from a subsequent call of longjmp. A
call to setjmp can only occur in certain contexts, basically the test of if, switch, and
loops, and only in simple relational expressions.
</p>



<pre class="src src-c"><span style="color: #00ffff;">if</span> (setjmp(env) == 0)
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">get here on direct call </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">else</span>
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">get here by calling longjmp </span><span style="color: #ff7f24;">*/</span>
</pre>


<ul>
<li>void longjmp(jmp<sub>buf</sub> env, int val)
</li>
</ul>


<p>
longjmp restores the state saved by the most recent call to setjmp, using the
information saved in env, and execution resumes as if the setjmp function had just
executed and returned the non-zero value val. The function containing the setjmp
must not have terminated. Accessible objects have the values they had at the time
longjmp was called, except that non-volatile automatic variables in the function
calling setjmp become undefined if they were changed after the setjmp call.
</p>
</li>
</ul>
<ul>
<li id="sec-10-5">B.9 Signals: &lt;signal.h&gt;<br/>
The header &lt;signal.h&gt; provides facilities for handling exceptional conditions that arise
during execution, such as an interrupt signal from an external source
or an error in execution.

<p>
<code>void (*signal(int sig, void (*handler)(int)))(int)</code>
</p>
<p>
signal determines how subsequent signals will be handled. If handler is SIG<sub>DFL</sub>, the
implementation-defined default behavior is used, if it is SIG<sub>IGN</sub>, the signal is ignored;
otherwise, the function pointed to by handler will be called, with the argument of the type of
signal. Valid signals include
</p>
<p class="verse">
SIGABRT abnormal termination, e.g., from abort<br/>
SIGFPE arithmetic error, e.g., zero divide or overflow<br/>
SIGILL illegal function image, e.g., illegal instruction<br/>
SIGINT interactive attention, e.g., interrupt<br/>
SIGSEGV illegal storage access, e.g., access outside memory limits<br/>
SIGTERM termination request sent to this program<br/>
</p>


<p>
signal returns the previous value of handler for the specific signal, or SIG<sub>ERR</sub> if an error
occurs.
</p>
<p>
The initial state of signals is implementation-defined.
<code>int raise(int sig)</code>
raise sends the signal sig to the program; it returns non-zero if unsuccessful.
</p></li>
</ul>
<ul>
<li id="sec-10-6">B.11 Implementation-defined Limits: &lt;limits.h&gt; and &lt;float.h&gt;<br/>
The header &lt;limits.h&gt; defines constants for the sizes of integral types.
The values below are acceptable minimum magnitudes; larger values may be
used.

<p class="verse">
CHAR<sub>BIT</sub> 8 bits in a char<br/>
CHAR<sub>MAX</sub> UCHAR<sub>MAX</sub> or SCHAR<sub>MAX</sub> maximum value of char<br/>
CHAR<sub>MIN</sub> 0 or SCHAR<sub>MIN</sub> maximum value of char<br/>
INT<sub>MAX</sub> 32767 maximum value of int<br/>
INT<sub>MIN</sub> -32767 minimum value of int<br/>
LONG<sub>MAX</sub> 2147483647 maximum value of long<br/>
LONG<sub>MIN</sub> -2147483647 minimum value of long<br/>
SCHAR<sub>MAX</sub> +127 maximum value of signed char<br/>
SCHAR<sub>MIN</sub> -127 minimum value of signed char<br/>
SHRT<sub>MAX</sub> +32767 maximum value of short<br/>
SHRT<sub>MIN</sub> -32767 minimum value of short<br/>
UCHAR<sub>MAX</sub> 255 maximum value of unsigned char<br/>
UINT<sub>MAX</sub> 65535 maximum value of unsigned int<br/>
ULONG<sub>MAX</sub> 4294967295 maximum value of unsigned long<br/>
USHRT<sub>MAX</sub> 65535 maximum value of unsigned short<br/>
</p>


<p>
The names in the table below, a subset of &lt;float.h&gt;, are constants related
to floating-point arithmetic. When a value is given, it represents the
minimum magnitude for the corresponding quantity. Each implementation
defines appropriate values.
</p>
<p class="verse">
FLT<sub>RADIX</sub>  2  radix of exponent, representation, e.g., 2, 16<br/>
FLT<sub>ROUNDS</sub>    floating-point rounding mode for addition<br/>
FLT<sub>DIG</sub>    6  decimal digits of precision<br/>
FLT<sub>EPSILON</sub> 1E-5 smallest number x such that 1.0+x != 1.0 <br/>
FLT<sub>MANT</sub><sub>DIG</sub>   number of base FLT<sub>RADIX</sub> in mantissa<br/>
FLT<sub>MAX</sub> 1E+37 maximum floating-point number <br/>
FLT<sub>MAX</sub><sub>EXP</sub>  maximum n such that FLT<sub>RADIX</sub>(n-1) is representable<br/>
FLT<sub>MIN</sub> 1E-37 minimum normalized floating-point number<br/>
FLT<sub>MIN</sub><sub>EXP</sub>  minimum n such that 10(n) is a normalized number<br/>
DBL<sub>DIG</sub> 10 decimal digits of precision<br/>
DBL<sub>EPSILON</sub> 1E-9 smallest number x such that 1.0+x != 1.0<br/>
DBL<sub>MANT</sub><sub>DIG</sub>  number of base FLT<sub>RADIX</sub> in mantissa<br/>
DBL<sub>MAX</sub>  1E+37  maximum double floating-point number<br/>
DBL<sub>MAX</sub><sub>EXP</sub>  maximum n such that FLT<sub>RADIX</sub>(n-1) is representable<br/>
DBL<sub>MIN</sub>  1E-37  minimum normalized double floating-point number<br/>
DBL<sub>MIN</sub><sub>EXP</sub> minimum normalized double floating-point number<br/>
</p>


<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> DEFINITION NOT FOUND: 0
</p></li>
</ul>
</div>
</div>

</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-08-07 00:01:47 HKT</p>
<p class="author">Author: Shi Shougang</p>
<p class="creator">Org version 7.8.09 with Emacs version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
