<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>The C Programming Language Notes</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="title" content="The C Programming Language Notes"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2013-04-08 12:45:15 China Standard Time"/>
<meta name="author" content="Shi Shougang"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="stylesheet" href="./assets/stylesheet.css" type="text/css"/>
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="org-div-home-and-up" style="text-align:right;font-size:70%;white-space:nowrap;">
 <a accesskey="h" href="../../index.html"> UP </a>
 |
 <a accesskey="H" href="../../index.html"> HOME </a>
</div>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">The C Programming Language Notes</h1>

<p><a href="http://cm.bell-labs.com/cm/cs/cbook/">The C Programming Language</a>, second edition by <a href="http://www.cs.bell-labs.com/who/bwk/">Kernighan</a> and <a href="http://www.cs.bell-labs.com/who/dmr/">Ritchie</a>.
</p>
<p>
Other people working through the book may be interested in the <a href="http://www.eskimo.com/~scs/cclass/krnotes/top.html">Notes to Accompany The C Programming Language</a> by <a href="http://www.eskimo.com/~scs/">Steve Summit</a>, maintainer of
the <a href="http://c-faq.com/versions.html">comp.lang.c FAQ</a>. Also be aware of the <a href="http://cm.bell-labs.com/cm/cs/cbook/2ediffs.html">errata</a>.
</p>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Answers</a></li>
<li><a href="#sec-2">Chapter 1</a></li>
<li><a href="#sec-3">Chapter 2</a></li>
<li><a href="#sec-4">Chapter 4</a></li>
<li><a href="#sec-5">Chapter 5</a></li>
<li><a href="#sec-6">Chapter 6</a></li>
<li><a href="#sec-7">Chapter 7</a></li>
<li><a href="#sec-8">Chapter 8</a></li>
<li><a href="#sec-9">Appendix A: Reference Manual</a></li>
<li><a href="#sec-10">Appendix B - Standard Library</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Answers</h2>
<div class="outline-text-2" id="text-1">

<ul>
<li>There is a book, <a href="./The C Answer Book.pdf">The C Answer Book by Tondo and Gimpel</a>, that has
  answers to these exercises. 

</li>
<li><a href="http://www.bamsoftware.com/computers/tcpl-answers.tar.gz">The answer</a> by <a href="http://www.bamsoftware.com/computers/tcpl-answers.html">bamsoftware</a>.

</li>
<li><a href="http://clc-wiki.net/wiki/K&amp;R2_solutions">Another site</a> (based on an <a href="http://users.powernet.co.uk/eton/kandr2/">older one</a>) that has answers to most of the exercises.
</li>
</ul>


</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Chapter 1</h2>
<div class="outline-text-2" id="text-2">

<ul>
<li id="sec-2-1">page 5<br/>
The only way to learn a new programming language is by writing
programs in it.
</li>
</ul>
<ul>
<li id="sec-2-2">page 11<br/>
you must match up the arguments to printf with the conversion specification; the compiler can't (or won't) generally check them for you or fix things up if you get them wrong. If fahr is a float, the code

<p>
        <code>printf("%d\n", fahr);</code>
</p>
<p>
will not work. You might ask, ``Can't the compiler see that %d needs
an integer and fahr is floating-point and do the conversion
automatically, just like in the assignments and comparisons on page
12?'' And the answer is, no. As far as the compiler knows, you've just
passed a character string and some other arguments to printf; it
doesn't know that there's a connection between the arguments and some
special characters inside the string. This is one of the implications
of the fact, stated earlier, that functions like printf are not
special.
</p></li>
</ul>
<ul>
<li id="sec-2-3">page 15<br/>
Notice that there is no semicolon at the end of a #define line.

<p>
Actually, all lines that begin with # are special; we'll learn more
about them later.
</p></li>
</ul>
<ul>
<li id="sec-2-4">page 16<br/>



<pre class="example">int c;
c = getchar();
</pre>

<p>
We must declare <code>c</code> to be a type big enough to hold any value that
<code>getchar</code> returns. We can't use <code>char</code> since <code>c</code> must be big enough to
hold <code>EOF</code> in addition to any possible <code>char</code>. Therefore we use <code>int</code>.
</p></li>
</ul>
<ul>
<li id="sec-2-5">page 17<br/>
The line <code>while ((c = getchar()) !</code> EOF)= epitomizes the cryptic
brevity which C is notorious for. 

<p>
We have four things to do:
</p>
<ol>
<li>call <code>getchar</code>,
</li>
<li>assign its return value to a variable,
</li>
<li>test the return value against <code>EOF</code>, and
</li>
<li>process the character (in this case, print it again).
</li>
</ol>


<p>
how do you send EOF? The answer depends on what kind of computer
you're using. On Unix and Unix-related systems, it's almost always
control-D. On MS-DOS machines, it's control-Z followed by the RETURN
key. Under Think C on the Macintosh, it's control-D, just like Unix.
On other systems, you may have to do some research to learn how to
send EOF.
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Chapter 2</h2>
<div class="outline-text-2" id="text-3">


<ul>
<li id="sec-3-1">page 39<br/>
Be careful to distinguish between a character constant and a string
that contains a single character: 'x' is not the same as "x". The
former is an integer used to produce the numeric value of the letter x
in the machine;s character set. The latter is an array of characters
that contains one character( the letter x) and a '\0'.

<p>
Name in different enumerations must be distinct. Values need not be
distinct in the same enumeration.
</p></li>
</ul>
<ul>
<li id="sec-3-2">page 40<br/>
External and static variables are initialized to zero by default.

</li>
</ul>
<ul>
<li id="sec-3-3">page 41<br/>
The % operator cannot be applied to <code>float</code> or <code>double</code>. The direction
of truncation for / and the sign of the result for % are
machine-dependent for negative operands, as is the action taken on
overflow or underflow. This means that -7 / 4 might be -1 or -2, and
-7 % 4 might be -3 or +1. 

</li>
</ul>
<ul>
<li id="sec-3-4">page 44<br/>
the lower type is promoted to the higher type, where the order of the
types is 
 <code>char &lt; short int &lt; int &lt; long int &lt; float &lt; double &lt; long double</code>
</li>
</ul>
<ul>
<li id="sec-3-5">page 45<br/>
Casts can be a bit confusing at first. A cast is the syntax used to
request an explicit type conversion; coercion is just a more formal
word for ``conversion.'' 
</li>
</ul>
<ul>
<li id="sec-3-6">page 46<br/>
The authors point out that an expression like (i+j)++ is illegal, and
it's worth thinking for a moment about why. The ++ operator doesn't
just mean ``add one''; it means ``add one to a variable'' or ``make a
variable's value one more than it was before.'' But (i+j) is not a
variable, it's an expression; so there's no place for ++ to store the
incremented result. 


</li>
</ul>
<ul>
<li id="sec-3-7">page 52 Precedence and Order of Evaluation<br/>
To look at one more example, it might seem that the code



<pre class="example">int i = 7;
printf("%d\n", i++ * i++);
</pre>

<p>
would have to print 56, because no matter which order the increments
        happen in, 7x8 is 8x7 is 56. But ++ just says that the
        increment happens later, not that it happens immediately, so
        this code could print 49 (if it chose to perform the
        multiplication first, and both increments later). And, it
        turns out that ambiguous expressions like this are such a bad
        idea that the ANSI C Standard does not require compilers to do
        anything reasonable with them at all, such that the above code
        might end up printing 42, or 8923409342, or 0, or crashing
        your computer.
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Chapter 4</h2>
<div class="outline-text-2" id="text-4">


<ul>
<li id="sec-4-1">page 77<br/>
<code>push(pop() - pop());   /* WRONG */</code>

<p>
Because + and * are commutative operations, the order in which the
popped operands are combined is irrelevant, but for - and / the left
and right operands must be distinguished. In the above, the order in
which the two calls of <code>pop</code> are evaluated is not defined. To
guarantee the right order, it is necessary to pop the first value into
a temporary variable as we did in = 
</p></li>
</ul>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">Chapter 5</h2>
<div class="outline-text-2" id="text-5">


<ul>
<li id="sec-5-1">page 96<br/>
the swap example on page 96 does work.



<pre class="example">void swap1(int *q1,int *q2)
{
  int temp;
  temp = *q1;
  *q1 = *q2;
  *q2 = temp;
}
</pre>

<p>
But this swap does not work.
</p>


<pre class="example">void swap2(int *q1, int *q2)
{
  int *temp;
  temp = q1;
  q1 = q2;
  q2 = temp;
}
</pre>

</li>
</ul>
<ul>
<li id="sec-5-2">page 99<br/>
This explains, among other things, how getline and getop were able to
modify the arrays in the caller, even though we said that
call-by-value meant that functions can't modify variables in their
callers since they receive copies of the parameters. When a function
receives a pointer, it cannot modify the original pointer in the
caller, but it can definitely modify what the pointer points to. 
</li>
</ul>
<ul>
<li id="sec-5-3">page 104<br/>
As an example of what we can and can't do, given the lines



<pre class="example">char amessage[] = "now is the time";
char *pmessage = "now is the time";
</pre>

<p>
we could say
</p>


<pre class="example">amessage[0] = 'N';
</pre>

<p>
to make amessage say "Now is the time". But if we tried to do
</p>


<pre class="example">pmessage[0] = 'N';
</pre>

<p>
(which, as you may recall, is equivalent to =*pmessage = 'N'=), it would
not necessarily work; we're not allowed to modify that string. (One
reason is that the compiler might have placed the ``little block of
characters'' in read-only memory. Another reason is that if we had
written
</p>


<pre class="example">char *pmessage = "now is the time";
char *qmessage = "now is the time";
</pre>

<p>
the compiler might have used the same little block of memory to
initialize both pointers, and we wouldn't want a change to one to
alter the other.) 
</p>
</li>
</ul>
<ul>
<li id="sec-5-4">page 112<br/>

<p class="verse">
More generally, only the first dimension (subscript) of an array is free; all the others have to be specified.<br/>
</p>


<p>
This just says what we said already: when declaring an array as a
function parameter, you can leave off the first dimension because it
is the overall length and not knowing it causes no immediate problems
(unless you accidentally go off the end). But the compiler always
needs to know the other dimensions, so that it knows how the rown and
columns line up.
</p>
<p>
If a two-dimensional array is to be passed to a function, the
parameter declaration in the function must include the number of
columns; the number of rows i irrelevant, since what is passed is, as
before, a pointer to an array of rows, where each row is an array of
13 ints.
</p></li>
</ul>
<ul>
<li id="sec-5-5">page 120<br/>
The generic pointer type void * is used for the pointer
arguments. Any pointer can be cast to void * and back again without
loss of information, so we can call qsort by casting arguments to void
*.
</li>
</ul>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">Chapter 6</h2>
<div class="outline-text-2" id="text-6">

<ul>
<li id="sec-6-1">page 135<br/>
<code>sizeof</code> returns the size counted in bytes, where the C definition of
``byte'' is ``the size of a char.'' In other words, <code>sizeof(char)</code> is
always 1. (It turns out that it's not necessarily the case, though,
that a byte or a char is 8 bits.) 

<p>
Strictly, <code>sizeof</code> produces an unsigned integer value whose type,
<code>size_t</code>, is defined in the header <code>&lt;stddef.h&gt;</code>.
</p>
<p>
A <code>sizeof</code> can not be used in a <code>#if</code> line, because the preprocessor
does not parse type names. But the expression in the <code>#define</code> is not
evaluated by the preprocessor.
</p>
</li>
</ul>
<ul>
<li id="sec-6-2">page 138<br/>

<p class="verse">
Don't assume, however, that the size of a structure is the sum of the sizes of its members.<br/>
</p>


<p>
If this isn't the sort of thing you'd be likely to assume, you don't
have to remember the reason, which is mildly esoteric (having to do
with memory alignment requirements).
</p></li>
</ul>
<ul>
<li id="sec-6-3">page 142<br/>
We can test for this in two different ways, either before or after we
make the ``last'' recursive call:



<pre class="example">void treeprint(struct tnode *p)
{
        if(p-&gt;left != NULL)
                treeprint(p-&gt;left);
        printf("%4d %s\n", p-&gt;count, p-&gt;word);
        if(p-&gt;right != NULL)
                treeprint(p-&gt;right);
}
</pre>

<p>
or
</p>


<pre class="example">void treeprint(struct tnode *p)
{
        if(p == NULL)
                return;

        treeprint(p-&gt;left);
        printf("%4d %s\n", p-&gt;count, p-&gt;word);
        treeprint(p-&gt;right);
}
</pre>

<p>
Sometimes, there's little difference between one approach and the
other. Here, though, the second approach (which is
                equivalent to the code on page 142) has a distinct
                advantage: it will work even if the very first call is
                on an empty tree (in this case, if there were no words
                in the input). As we mentioned earlier, it's extremely
                nice if programs work well at their boundary
                conditions, even if we don't think those conditions
                are likely to occur.
</p>
</li>
</ul>
<ul>
<li id="sec-6-4">page 143<br/>



<pre class="example">char str[] = "a";
sizeof(str); /*2*/
strlen(str); /*1*/
</pre>


</li>
</ul>
<ul>
<li id="sec-6-5">page 146<br/>
In effect, <code>typedef</code> is like <code>#define</code>, except that since it is
interpreted by the computer, it can cope with textual substitutions
that are beyond the capabilities of the preprocessor. For example,

<p> 
 <code>typedef int (*PFI)(char *, char *);</code>
</p>
<p>
creates the type PFI, for "pointer to function (of two char *
arguments) returning int," which can be used in contexts like
</p>
<p>
<code>PFI strcmp, numcmp;</code>
</p>
<p>
in the sort program.
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">Chapter 7</h2>
<div class="outline-text-2" id="text-7">

<ul>
<li id="sec-7-1">page 152<br/>
Note that the stdio library generally does newline translation for
you. If you know that lines are terminated by a linefeed on Unix and a
carriage return on the Macintosh and a carriage-return/linefeed
combination on MS-DOS, you don't have to worry about these things in
C, because the line termination will always appear to a C program to
be a single '\n'.

</li>
</ul>
<ul>
<li id="sec-7-2">page 154<br/>
A width or precision may be specified as *, in which case the value is
computed by converting the next argument (which must be an int). For
example, to print at most max characters from a string s,

<p>
<code>prinf("%.*s", max, s);</code>
</p>
</li>
</ul>
<ul>
<li id="sec-7-3">page 164<br/>
Confusingly, <code>gets</code> deletes the terminals '\n', and <code>puts</code> adds it.

</li>
</ul>
<ul>
<li id="sec-7-4">page 166<br/>
strstr(s,t)     return pointer to first t in s, or NULL if not present

</li>
</ul>
<ul>
<li id="sec-7-5">page 168(Random Number Gneration)<br/>
the code for returning a floating-point random number in the interval [0,1) should be

<p>
        <code>#define frand() ((double) rand() / (RAND_MAX+1.0))</code>
If you want to get random integers from M to N, you can use something like
</p>
<p>
        <code>M + (int)(frand() * (N-M+1))</code>
</p>
<p>
``[Setting] the seed for rand'' refers to the fact that, by default,
the sequence of pseudo-random numbers returned by rand is the same
each time your program runs. To randomize it, you can call srand at
the beginning of the program, handing it some truly random number,
such as a value having to do with the time of day. (One way is with
code like
</p>


<pre class="example">#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
srand((unsigned int)time((time_t *)NULL));
</pre>

<p>
which uses the time function mentioned on page 256 in appendix B10.)
</p>
<p>
One other caveat about rand: don't try to generate random 0/1 values (to simulate a coin flip, perhaps) with code like
</p>
<p>
        <code>rand() % 2</code>
This looks like it ought to work, but it turns out that on some systems rand isn't always perfectly random, and returns values which consistently alternate even, odd, even, odd, etc. (In fact, for similar reasons, you shouldn't usually use rand() % N for any value of N.) A good way to get random 0/1 values would be
        <code>(int)(frand() * 2)</code>
based on the other frand() examples above.
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8">Chapter 8</h2>
<div class="outline-text-2" id="text-8">


<ul>
<li id="sec-8-1">page 172<br/>
<code>open</code> is rather like the <code>fopen</code> discussed in Chapter 7, except that
instead of returning a file pointer, it returns a file descriptor,
which is just an <code>int</code>.
</li>
</ul>
</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9">Appendix A: Reference Manual</h2>
<div class="outline-text-2" id="text-9">

<ul>
<li id="sec-9-1">A2.1 Tokens<br/>
There are six classes of tokens: identifiers, keywords, constants,
string literals, operators, and other separators.
</li>
</ul>
<ul>
<li id="sec-9-2">A.2.5.2 Character Constants<br/>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" /><col class="left" /><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Name</th><th scope="col" class="left">Abstract</th><th scope="col" class="left">character</th><th scope="col" class="left">Name</th><th scope="col" class="left">Abstract</th><th scope="col" class="left">Character</th></tr>
</thead>
<tbody>
<tr><td class="left">newline</td><td class="left">NT(LF)</td><td class="left">\n</td><td class="left">backslash</td><td class="left">\</td><td class="left">\\</td></tr>
<tr><td class="left">horizontal tab</td><td class="left">HT</td><td class="left">\t</td><td class="left">question mark</td><td class="left">?</td><td class="left">\?</td></tr>
<tr><td class="left">vertical</td><td class="left">VT</td><td class="left">\v</td><td class="left">single quote</td><td class="left">'</td><td class="left">\'</td></tr>
<tr><td class="left">backspace</td><td class="left">BS</td><td class="left">\b</td><td class="left">double quote</td><td class="left">"</td><td class="left">\"</td></tr>
<tr><td class="left">carriage return</td><td class="left">CR</td><td class="left">\r</td><td class="left">octal number</td><td class="left">ooo</td><td class="left">\ooo</td></tr>
<tr><td class="left">audible</td><td class="left">BEL</td><td class="left">\a</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
</tbody>
</table>


</li>
</ul>
<ul>
<li id="sec-9-3">A.8.6.1 Pointer Declarators<br/>
In a declaration T D where D has the form
 <code>*</code> type-qualifier-list<sub>opt</sub> D1
and the type of the identifier in the declaration T D1 is ``type-modifier T,'' the type of the
identifier of D is ``type-modifier type-qualifier-list pointer to T.'' Qualifiers following * apply
to pointer itself, rather than to the object to which the pointer points.

<p>
For example, consider the declaration
int *ap[];
</p>
<p>
Here, ap[] plays the role of D1; a declaration ``int ap[]'' (below) would give ap the type
``array of int,'' the type-qualifier list is empty, and the type-modifier is ``array of.'' Hence the
actual declaration gives ap the type ``array to pointers to int.''
</p></li>
</ul>
<ul>
<li id="sec-9-4">A.8.8 Type names<br/>



<pre class="example">int 
int * 
int *[3]
int (*)[]
int *()
int (*[])(void)
</pre>

<p>
name respectively the types ``integer,'' ``pointer to integer,'' ``array of 3 pointers to integers,''
``pointer to an unspecified number of integers,'' ``function of unspecified parameters returning
pointer to integer,'' and ``array, of unspecified size, of pointers to functions with no
parameters each returning an integer.''
</p></li>
</ul>
<ul>
<li id="sec-9-5">A.12.3 Macro Definition and Expansion<br/>

<p>
First, if an occurrence of a
parameter in the replacement token sequence is immediately preceded by #, string quotes (")
are placed around the corresponding parameter, and then both the # and the parameter
identifier are replaced by the quoted argument. A \ character is inserted before each " or \
character that appears surrounding, or inside, a string literal or character constant in the
argument.
</p>
<p>
Second, if the definition token sequence for either kind of macro contains a ## operator, then
just after replacement of the parameters, each ## is deleted, together with any white space on
either side, so as to concatenate the adjacent tokens and form a new token. The effect is
undefined if invalid tokens are produced, or if the result depends on the order of processing of
the ## operators. Also, ## may not appear at the beginning or end of a replacement token
sequence.
</p>
<p>
Given the definition
</p>


<pre class="example">#define tempfile(dir) #dir "%s"
</pre>

<p>
the macro call <code>tempfile(/usr/tmp)</code> yields
</p>
<p>
 "/usr/tmp" "%s"
</p>
<p>
which will subsequently be catenated into a single string. After
</p>


<pre class="example">#define cat(x, y) x ## y
</pre>


<p>
the call <code>cat(var, 123)</code> yields var123. However, the call <code>cat(cat(1,2),3)</code> is undefined:
the presence of ## prevents the arguments of the outer call from being expanded. Thus it
produces the token string
</p>
<p>
<code>cat ( 1 , 2 )3</code>
</p>
<p>
and )3 (the catenation of the last token of the first argument with the first token of the second)
is not a legal token. If a second level of macro definition is
introduced,
</p>


<pre class="example">#define xcat(x, y)  cat(x,y)
</pre>

<p>
things work more smoothly; <code>xcat(xcat(1, 2), 3)</code> does produce 123, because the
expansion of xcat itself does not involve the ## operator.
</p></li>
</ul>
<ul>
<li id="sec-9-6">A.12.7 Error Generation<br/>
A preprocessor line of the form
 # error token-sequence<sub>opt</sub>
causes the preprocessor to write a diagnostic message that includes the token sequence.
</li>
</ul>
<ul>
<li id="sec-9-7">A.12.8 Pragmas<br/>
A control line of the form
 # pragma token-sequence<sub>opt</sub>
causes the preprocessor to perform an implementation-dependent action. An unrecognized
pragma is ignored.
</li>
</ul>
<ul>
<li id="sec-9-8">A.12.10 Predefined names<br/>
Several identifiers are predefined, and expand to produce special information. They, and also
the preprocessor expansion operator defined, may not be undefined or
redefined.

<ul>
<li>_<sub>LINE</sub>__ A decimal constant containing the current source line number.
</li>
<li>_<sub>FILE</sub>__ A string literal containing the name of the file being compiled.
</li>
<li>_<sub>DATE</sub>__ A string literal containing the date of compilation, in the form "Mmmm dd yyyy"
</li>
<li>_<sub>TIME</sub>__ A string literal containing the time of compilation, in the form "hh:mm:ss"
</li>
<li>_<sub>STDC</sub>__ The constant 1. It is intended that this identifier be
  defined to be 1 only in standard-conforming implementations.
</li>
</ul>




</li>
</ul>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10">Appendix B - Standard Library</h2>
<div class="outline-text-2" id="text-10">




<pre class="example">&lt;assert.h&gt; &lt;ctype.h&gt; &lt;errno.h&gt; &lt;float.h&gt; &lt;limits.h&gt;
&lt;locale.h&gt; &lt;math.h&gt; &lt;setjmp.h&gt; &lt;signal.h&gt; &lt;stdarg.h&gt;
&lt;stddef.h&gt; &lt;stdio.h&gt; &lt;stdlib.h&gt; &lt;string.h&gt; &lt;time.h&gt;
</pre>

<ul>
<li id="sec-10-1">B.2 Character Class Tests: &lt;ctype.h&gt;<br/>



<pre class="example">isalnum(c) isalpha(c) or isdigit(c) is true
isalpha(c)
isupper(c) or islower(c) is true
iscntrl(c) control character
isdigit(c) decimal digit
isgraph(c) printing character except space
islower(c) lower-case letter
isprint(c) printing character including space
ispunct(c) printing character except space or letter or digit
isspace(c) space, formfeed, newline, carriage return, tab, vertical tab
isupper(c) upper-case letter
isxdigit(c) hexadecimal digit
int tolower(c) convert c to lower case
int toupper(c) convert c to upper case
</pre>

</li>
</ul>
<ul>
<li id="sec-10-2">B.5 Utility Functions: &lt;stdlib.h&gt;<br/>



<pre class="example">+ double atof(const char *s) atof converts s to double; it is equivalent to strtod(s, (char**)NULL).
+ int atoi(const char *s) converts s to int; it is equivalent to (int)strtol(s, (char**)NULL, 10).
+ long atol(const char *s) converts s to long; it is equivalent to strtol(s, (char**)NULL, 10).
+ double strtod(const char *s, char **endp) strtod converts the prefix
  of s to double, ignoring leading white space; it stores a pointer to
  any unconverted suffix in *endp unless endp is NULL. If the answer
  would overflow, HUGE_VAL is returned with the proper sign; if the
  answer would underflow, zero is returned. In either case errno is set to ERANGE.
+ long strtol(const char *s, char **endp, int base) strtol converts
  the prefix of s to long, ignoring leading white space; it stores a
  pointer to any unconverted suffix in *endp unless endp is NULL. If
  base is between 2 and 36, conversion is done assuming that the input
  is written in that base. If base is zero, the base is 8, 10, or 16;
  leading 0 implies octal and leading 0x or 0X hexadecimal. Letters in
  either case represent digits from 10 to base-1; a leading 0x or 0X
  is permitted in base 16. If the answer would overflow, LONG_MAX or
  LONG_MIN is returned, depending on the sign of the result, and errno
  is set to ERANGE.
+ unsigned long strtoul(const char *s, char **endp, int base)  strtoul
  is the same as strtol except that the result is unsigned long and
  the error value is ULONG_MAX.
+ int rand(void) rand returns a pseudo-random integer in the range 0
  to RAND_MAX, which is at least 32767.
+ void srand(unsigned int seed) srand uses seed as the seed for a new
  sequence of pseudo-random numbers. The initial seed is 1.
+ void *calloc(size_t nobj, size_t size) calloc returns a pointer to
  space for an array of nobj objects, each of size size, or NULL if
  the request cannot be satisfied. The space is initialized to zero
  bytes.

+ void *malloc(size_t size) malloc returns a pointer to space for an
  object of size size, or NULL if the request cannot be satisfied. The space is uninitialized.
+ void *realloc(void *p, size_t size) realloc changes the size of the
  object pointed to by p to size. The contents will be unchanged up to
  the minimum of the old and new sizes. If the new size is larger, the
  new space is uninitialized. realloc returns a pointer to the new
  space, or NULL if the request cannot be satisfied, in which case *p is unchanged.
+ void free(void *p)  free deallocates the space pointed to by p; it
  does nothing if p is NULL. p must be a pointer to space previously
  allocated by calloc, malloc, or realloc.

+ void abort(void)  abort causes the program to terminate abnormally, as if by raise(SIGABRT).
+ void exit(int status) exit causes normal program termination. atexit
  functions are called in reverse order of registration, open files
  are flushed, open streams are closed, and control is returned to the
  environment. How status is returned to the environment is
  implementation- dependent, but zero is taken as successful
  termination. The values EXIT_SUCCESS and EXIT_FAILURE may also be used.
+ int atexit(void (*fcn)(void))  atexit registers the function fcn to
  be called when the program terminates normally; it returns non-zero
  if the registration cannot be made.

+ int system(const char *s)  system passes the string s to the
  environment for execution. If s is NULL, system returns non-zero if
  there is a command processor. If s is not NULL, the return value is
  implementation-dependent.

+ char *getenv(const char *name)  getenv returns the environment
  string associated with name, or NULL if no string exists. Details are implementation-dependent.
+ void *bsearch(const void *key, const void *base, size_t n, size_t
  size, int (*cmp)(const void *keyval, const void *datum)) bsearch
  searches base[0]...base[n-1] for an item that matches *key. The
  function cmp must return negative if its first argument (the search
  key) is less than its second (a table entry), zero if equal, and
  positive if greater. Items in the array base must be in ascending
  order. bsearch returns a pointer to a matching item, or NULL if none
  exists.

+ void qsort(void *base, size_t n, size_t size, int (*cmp)(const void
  *, const void *)) qsort sorts into ascending order an array
  base[0]...base[n-1] of objects of size size. The comparison function cmp is as in bsearch.
+ int abs(int n) abs returns the absolute value of its int argument.
+ long labs(long n) labs returns the absolute value of its long argument.
+ div_t div(int num, int denom) div computes the quotient and
  remainder of num/denom. The results are stored in the int members
  quot and rem of a structure of type div_t.

+ ldiv_t ldiv(long num, long denom) ldiv computes the quotient and
  remainder of num/denom. The results are stored in the long members
  quot and rem of a structure of type ldiv_t

</pre>



</li>
</ul>
<ul>
<li id="sec-10-3">B.7 Variable Argument Lists: &lt;stdarg.h&gt;<br/>
The header &lt;stdarg.h&gt; provides facilities for stepping through a list of function arguments
of unknown number and type.



<pre class="example">va_list ap;
va_start(va_list ap, lastarg);
type va_arg(va_list ap, type);
void va_end(va_list ap);
</pre>

</li>
</ul>
<ul>
<li id="sec-10-4">B.8 Non-local Jumps: &lt;setjmp.h&gt;<br/>
The declarations in &lt;setjmp.h&gt; provide a way to avoid the normal function call and return
sequence, typically to permit an immediate return from a deeply nested function call.
<ul>
<li>int setjmp(jmp<sub>buf</sub> env)
</li>
</ul>


<p>
The macro setjmp saves state information in env for use by longjmp. The return is
zero from a direct call of setjmp, and non-zero from a subsequent call of longjmp. A
call to setjmp can only occur in certain contexts, basically the test of if, switch, and
loops, and only in simple relational expressions.
</p>



<pre class="example">if (setjmp(env) == 0)
/* get here on direct call */
else
/* get here by calling longjmp */
</pre>


<ul>
<li>void longjmp(jmp<sub>buf</sub> env, int val)
</li>
</ul>


<p>
longjmp restores the state saved by the most recent call to setjmp, using the
information saved in env, and execution resumes as if the setjmp function had just
executed and returned the non-zero value val. The function containing the setjmp
must not have terminated. Accessible objects have the values they had at the time
longjmp was called, except that non-volatile automatic variables in the function
calling setjmp become undefined if they were changed after the setjmp call.
</p>
</li>
</ul>
<ul>
<li id="sec-10-5">B.9 Signals: &lt;signal.h&gt;<br/>
The header &lt;signal.h&gt; provides facilities for handling exceptional conditions that arise
during execution, such as an interrupt signal from an external source
or an error in execution.

<p>
<code>void (*signal(int sig, void (*handler)(int)))(int)</code>
</p>
<p>
signal determines how subsequent signals will be handled. If handler is SIG<sub>DFL</sub>, the
implementation-defined default behavior is used, if it is SIG<sub>IGN</sub>, the signal is ignored;
otherwise, the function pointed to by handler will be called, with the argument of the type of
signal. Valid signals include
</p>
<p class="verse">
SIGABRT abnormal termination, e.g., from abort<br/>
SIGFPE arithmetic error, e.g., zero divide or overflow<br/>
SIGILL illegal function image, e.g., illegal instruction<br/>
SIGINT interactive attention, e.g., interrupt<br/>
SIGSEGV illegal storage access, e.g., access outside memory limits<br/>
SIGTERM termination request sent to this program<br/>
</p>


<p>
signal returns the previous value of handler for the specific signal, or SIG<sub>ERR</sub> if an error
occurs.
</p>
<p>
The initial state of signals is implementation-defined.
<code>int raise(int sig)</code>
raise sends the signal sig to the program; it returns non-zero if unsuccessful.
</p></li>
</ul>
<ul>
<li id="sec-10-6">B.11 Implementation-defined Limits: &lt;limits.h&gt; and &lt;float.h&gt;<br/>
The header &lt;limits.h&gt; defines constants for the sizes of integral types.
The values below are acceptable minimum magnitudes; larger values may be
used.



<pre class="example">CHAR_BIT 8 bits in a char
CHAR_MAX UCHAR_MAX or SCHAR_MAX maximum value of char
CHAR_MIN 0 or SCHAR_MIN maximum value of char
INT_MAX 32767 maximum value of int
INT_MIN -32767 minimum value of int
LONG_MAX 2147483647 maximum value of long
LONG_MIN -2147483647 minimum value of long
SCHAR_MAX +127 maximum value of signed char
SCHAR_MIN -127 minimum value of signed char
SHRT_MAX +32767 maximum value of short
SHRT_MIN -32767 minimum value of short
UCHAR_MAX 255 maximum value of unsigned char
UINT_MAX 65535 maximum value of unsigned int
ULONG_MAX 4294967295 maximum value of unsigned long
USHRT_MAX 65535 maximum value of unsigned short
</pre>

<p>
The names in the table below, a subset of &lt;float.h&gt;, are constants related
to floating-point arithmetic. When a value is given, it represents the
minimum magnitude for the corresponding quantity. Each implementation
defines appropriate values.
</p>


<pre class="example">FLT_RADIX  2  radix of exponent, representation, e.g., 2, 16
FLT_ROUNDS    floating-point rounding mode for addition
FLT_DIG    6  decimal digits of precision
FLT_EPSILON 1E-5 smallest number x such that 1.0+x != 1.0 
FLT_MANT_DIG   number of base FLT_RADIX in mantissa
FLT_MAX 1E+37 maximum floating-point number 
FLT_MAX_EXP  maximum n such that FLT_RADIX(n-1) is representable
FLT_MIN 1E-37 minimum normalized floating-point number
FLT_MIN_EXP  minimum n such that 10(n) is a normalized number
DBL_DIG 10 decimal digits of precision
DBL_EPSILON 1E-9 smallest number x such that 1.0+x != 1.0
DBL_MANT_DIG  number of base FLT_RADIX in mantissa
DBL_MAX  1E+37  maximum double floating-point number
DBL_MAX_EXP  maximum n such that FLT_RADIX(n-1) is representable
DBL_MIN  1E-37  minimum normalized double floating-point number
DBL_MIN_EXP minimum normalized double floating-point number
</pre>

</li>
</ul>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2013-04-08 12:45:15 China Standard Time</p>
<p class="author">Author: Shi Shougang</p>
<p class="creator">Org version 7.8.11 with Emacs version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
