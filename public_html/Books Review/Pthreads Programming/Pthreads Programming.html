<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Pthreads Programming</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="Pthreads Programming"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2013-04-14T18:55+0800"/>
<meta name="author" content="Shi Shougang"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="stylesheet" href="./assets/stylesheet.css" type="text/css"/>
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="org-div-home-and-up" style="text-align:right;font-size:70%;white-space:nowrap;">
 <a accesskey="h" href="../../index.html"> UP </a>
 |
 <a accesskey="H" href="../../index.html"> HOME </a>
</div>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Pthreads Programming</h1>



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Reference</a></li>
<li><a href="#sec-2">Chapter 1: Why Threads?</a>
<ul>
<li><a href="#sec-2-1">Overview</a></li>
<li><a href="#sec-2-2">Specifying Potential Parallelism in a Concurrent Programming Environment</a></li>
<li><a href="#sec-2-3">Parallel vs. Concurrent Programming</a></li>
<li><a href="#sec-2-4">Synchronization</a></li>
<li><a href="#sec-2-5">Who Am I? Who Are You?</a></li>
<li><a href="#sec-2-6">Terminating Thread Execution</a></li>
<li><a href="#sec-2-7">Why Use Threads Over Processes?</a></li>
<li><a href="#sec-2-8">A Structured Programming Environment</a></li>
<li><a href="#sec-2-9">Choosing Which Applications to Thread</a></li>
</ul>
</li>
<li><a href="#sec-3">Chapter 2 - Designing Threaded Programs</a>
<ul>
<li><a href="#sec-3-1">Some Common Problems</a></li>
<li><a href="#sec-3-2">Performance</a></li>
<li><a href="#sec-3-3">Example: An ATM Server</a></li>
</ul>
</li>
<li><a href="#sec-4">Chapter 3 - Synchronizing Pthreads</a>
<ul>
<li><a href="#sec-4-1">Overview</a></li>
<li><a href="#sec-4-2">Selecting the Right Synchronization Tool</a></li>
<li><a href="#sec-4-3">Mutex Variables</a></li>
<li><a href="#sec-4-4">Condition Variables</a></li>
<li><a href="#sec-4-5">Reader/Writer Locks</a></li>
<li><a href="#sec-4-6">Synchronization in the ATM Server</a></li>
<li><a href="#sec-4-7">Thread Pools</a></li>
</ul>
</li>
<li><a href="#sec-5">Chapter 4 - Managing Pthreads</a>
<ul>
<li><a href="#sec-5-1">Setting Thread Attributes</a></li>
<li><a href="#sec-5-2">The pthread<sub>once</sub> Mechanism</a></li>
<li><a href="#sec-5-3">Keys: Using Thread-Specific Data</a></li>
<li><a href="#sec-5-4">Cancellation</a></li>
<li><a href="#sec-5-5">Scheduling Pthreads</a></li>
<li><a href="#sec-5-6">Mutex Scheduling Attributes</a></li>
</ul>
</li>
<li><a href="#sec-6">Chapter 5 - Pthreads and UNIX</a>
<ul>
<li><a href="#sec-6-1">Overview</a></li>
<li><a href="#sec-6-2">Threads and Signals</a></li>
<li><a href="#sec-6-3">Threadsafe Library Functions and System Calls</a></li>
<li><a href="#sec-6-4">Cancellation-Safe Library Functions and System Calls</a></li>
<li><a href="#sec-6-5">Thread-Blocking Library Functions and System Calls</a></li>
<li><a href="#sec-6-6">Threads and Process Management</a></li>
<li><a href="#sec-6-7">Multiprocessor Memory Synchronization</a></li>
</ul>
</li>
<li><a href="#sec-7">Chapter 6: Practical Considerations</a>
<ul>
<li><a href="#sec-7-1">Understanding Pthreads Implementation</a></li>
<li><a href="#sec-7-2">Debugging</a></li>
<li><a href="#sec-7-3">Performance</a></li>
</ul>
</li>
<li><a href="#sec-8">Appendix C: Pthreads Quick Reference</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Reference</h2>
<div class="outline-text-2" id="text-1">

<ul>
<li>book POSIX.4: Programming for the Real World by Bill O. Gallmeister,
  from O'Reilly &amp; Associates, for in-depth discussion of the POSIX
  real-time extensions.
</li>
</ul>


<p>
POSIX Threads Programming
<a href="https://computing.llnl.gov/tutorials/pthreads/">https://computing.llnl.gov/tutorials/pthreads/</a>
</p>
<p>
Multithreaded Programming (POSIX pthreads Tutorial)
<a href="http://randu.org/tutorials/threads/">http://randu.org/tutorials/threads/</a>
</p>
<p>
Thread programming examples
<a href="http://www.cs.cf.ac.uk/Dave/C/node32.html">http://www.cs.cf.ac.uk/Dave/C/node32.html</a>
</p>
<p>
POSIX thread (pthread) libraries
<a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html">http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html</a>
</p></div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Chapter 1: Why Threads?</h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1">Overview</h3>
<div class="outline-text-3" id="text-2-1">

<p>The threads model takes a process and divides it into two parts:        
</p>
<ul>
<li>One contains resources used across the whole program (the
  processwide information),such as program instructions and global
  data. This part is still referred to as the process.  

</li>
<li>The other contains information related to the execution state, such
  as a program counter and a stack. This part is referred to as a
  <i>thread</i>.
</li>
</ul>


</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2">Specifying Potential Parallelism in a Concurrent Programming Environment</h3>
<div class="outline-text-3" id="text-2-2">

<p>  If the fork call returns to both the parent and child, why
  don't the parent and child execute the same instructions following
  the fork? UNIX programmers specify different code paths for parent
  and child by examining the return value of the fork call. The fork
  call always returns a value of 0 to the child and the child's PID to
  the parent.
</p>
<p>
 <b>A fork Call</b>
</p>


<pre class="src src-c"><span style="color: #00ffff;">if</span> ((pid = fork()) &lt; 0 ) {      
           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Fork system call failed </span><span style="color: #ff7f24;">*/</span>        
           .    
           perror(<span style="color: #ffa07a;">"fork"</span>), exit(1);     
}<span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (pid == 0) {   
           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Child only, pid is 0 </span><span style="color: #ff7f24;">*/</span>   
           .    
           <span style="color: #00ffff;">return</span> 0;    
}<span style="color: #00ffff;">else</span> { 
           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Parent only , pid is child's process ID </span><span style="color: #ff7f24;">*/</span>        
           .    
}
</pre>



<p>
When looking for concurrency, then, why choose multiple threads over
multiple processes? The overwhelming reason lies in the single largest
benefit of multithreaded programming: threads require less program and
system overhead to run than processes do. The operating system
performs less work on behalf of a multithreaded program than it does
for a multiprocess program. This translates into a performance gain
for the multithreaded program.
</p>
<ul>
<li id="sec-2-2-1">Cre ating a new thread: pthread<sub>create</sub><br/>



<pre class="src src-c"><span style="color: #98fb98;">pthread_t</span>       <span style="color: #eedd82;">thread1</span>;

pthread_create(&amp;thread1,        
          <span style="color: #7fffd4;">NULL</span>, 
          (<span style="color: #98fb98;">void</span> *) do_one_thing,        
          (<span style="color: #98fb98;">void</span> *) &amp;r1);
</pre>


<ul>
<li>A pointer to a buffer to which pthread<sub>create</sub> returns a value
  that identifies the newly created thread. This value, or
  handle, is of type pthread<sub>t</sub>.
</li>
<li>A pointer to a structure known as a thread attribute object.
</li>
<li>A pointer to the routine at which the new thread will start
  executing.
</li>
<li>A pointer to a parameter to be passed to the routine at which
  the new thread starts.
</li>
</ul>


</li>
</ul>
<ul>
<li id="sec-2-2-2">Threads are peers<br/>
</li>
</ul>
</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3">Parallel vs. Concurrent Programming</h3>
<div class="outline-text-3" id="text-2-3">

<p>We'll use concurrent programming in a general sense to refer to
environments in which the tasks we define can occur in any order. One
task can occur before or after another, and some or all tasks can be
performed at the same time. We'll use parallel programming to
specifically refer to the simultaneous execution of concurrent tasks
on different processors. Thus, all parallel programming is concurrent,
but not all concurrent programming is parallel.
</p>
<p>
Whether the threads actually run in parallel is a function of the
operating system and hardware on which they run. Because Pthreads was
designed in this way, a Pthreads program can run without modification
on uniprocessor as well as multiprocessor systems.
</p></div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4">Synchronization</h3>
<div class="outline-text-3" id="text-2-4">

<p>The <code>pthread_join</code> call provides synchronization for threads similar to
that which waitpid provides for processes, suspending its caller until
another thread exits. Unlike waitpid, which is specifically intended
for parent and child processes, you can use <code>pthread_join</code> between any
two threads in a program.
</p>
<p>
For this, we'll define a mutex variable (of type <code>pthread_mutex_t</code>) and
initialize it. (Just as a thread can have a thread attribute object, a
mutex can have a mutex attribute object that indicates its special
characteristics. Here, too, we'll pass a value of NULL for this
argument, indicating that we accept the default characteristics for
the new mutex.)
</p>


<pre class="src src-c"><span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">r3_mutex</span>=PTHREAD_MUTEX_INITIALIZER;

pthread_mutex_lock(&amp;r3_mutex);
pthread_mutex_unlock(&amp;r3_mutex);
</pre>


<ul>
<li id="sec-2-4-1">Sharing Process Resources<br/>
Independent processes share nothing. Threads share such process
resources as global variables and file descriptors. If one thread
changes the value of any such resource, the change will be evident to
any other thread in the process, if anyone cares to look. The sharing
of process resources among threads is one of the multithreaded
programming model's major performance advantages, as well as one of
its most difficult programming aspects. Having all of this context
available to all threads in the same memory facilitates communication
between threads. However, at the same time, it makes it easy to
introduce errors of the sort in which one thread affects the value of
a variable used by another thread in ways the other thread did not
expect.

</li>
</ul>
<ul>
<li id="sec-2-4-2">Communication<br/>
Multiple processes can use any of the many other UNIX Interprocess
Communication (IPC) mechanisms: sockets, shared memory, and messages,
to name a few. The multiprocess version of our program uses shared
memory, but the other methods are equally valid. Even the waitpid call
in our program could be used to exchange information, if the program
checked its return value. However, in the multiprocess world, all
types of IPC involve a call into the operating system—to initialize
shared memory or a message structure, for instance. This makes
communication between processes more expensive than communication
between threads.







</li>
</ul>
</div>

</div>

<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5">Who Am I? Who Are You?</h3>
<div class="outline-text-3" id="text-2-5">

<p>You can save this handle and use it to determine a thread's identity
using the pthread<sub>self</sub> and pthread<sub>equal</sub> function calls. 
</p>


<pre class="src src-c"><span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">io_thread</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
  pthread_create(&amp;io_thread, ...);
}
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">routine_x</span>(<span style="color: #98fb98;">void</span>)
{
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>;
  thread = pthread_self();
  <span style="color: #00ffff;">if</span>(phtread_equal(io_thread, thread)){
  }
}
</pre>

</div>

</div>

<div id="outline-container-2-6" class="outline-3">
<h3 id="sec-2-6">Terminating Thread Execution</h3>
<div class="outline-text-3" id="text-2-6">

<p> A thread can also explicitly exit with a call to pthread<sub>exit</sub>. You can
 terminate another thread by calling pthread<sub>cancel</sub>. In any of these
 cases, the Pthreads library runs any routines in its cleanup stack
 and any destructors in keys in which it has store values. 
</p><ul>
<li id="sec-2-6-1">Exit Status and Return Values<br/>
The Pthreads library may or may not save the exit status of a thread
when the thread exits, depending upon whether the thread is joinable
or detached. A joinable thread, the default state of a thread at its
creation, does have its exit status saved; a detached thread does not.
Detaching a thread gives the library a break and lets it immediately
reclaim the resources associated with the thread. Because the library
will not have an exit status for a detached thread, you cannot use a
<code>pthread_join</code> to join it.

<p>
What is the exit status of a thread? You can associate an exit status
with a thread in either of two ways:    
</p><ul>
<li>If the thread terminates explicitly with a call to pthread<sub>exit</sub>, the
  argument to the call becomes its exit status. 
</li>
<li>If the thread does not call pthread<sub>exit</sub>, the return value of the
  routine in which it started becomes its exit status.
</li>
</ul>





<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>      
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>    
<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>;       
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">arg</span>; 
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">internal_error</span> = -12;  
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">normal_error</span> = -10;    
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">success</span> = 1;   
<span style="color: #98fb98;">void</span> * <span style="color: #87cefa;">routine_x</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">arg_in</span>)  
{       
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">arg</span> = (<span style="color: #98fb98;">int</span> *)arg_in;     
  .     
  <span style="color: #00ffff;">if</span> ( <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">something that shouldn't have happened </span><span style="color: #ff7f24;">*/</span>) {  
    pthread_exit((<span style="color: #98fb98;">void</span> *) &amp;real_bad_error);     
  }<span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> ( <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">normal failure </span><span style="color: #ff7f24;">*/</span> ) {   
    <span style="color: #00ffff;">return</span> ((<span style="color: #98fb98;">void</span> *) &amp;normal_error);    
  }<span style="color: #00ffff;">else</span> {       
    <span style="color: #00ffff;">return</span> ((<span style="color: #98fb98;">void</span> *) &amp;success); 
  }     
}       
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span>      
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">argv</span>)     
{       
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>;     
  <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">statusp</span>;        
  .     
  pthread_create(&amp;thread, <span style="color: #7fffd4;">NULL</span>, routine_x, &amp;arg);       
  pthread_join(thread, &amp;statusp);       
  <span style="color: #00ffff;">if</span> (*statusp == PTHREAD_CANCELED) {   
    printf(<span style="color: #ffa07a;">"Thread was canceled.\n"</span>);   
  }<span style="color: #00ffff;">else</span> {       
    printf(<span style="color: #ffa07a;">"Thread completed and exit status is %ld.\n"</span>, *(<span style="color: #98fb98;">int</span> *)statusp);      
  }     
<span style="color: #00ffff;">return</span> 0;       
}
</pre>


<p>
A final note on pthread<sub>join</sub> is in order. Its purpose is to allow a
single thread to wait on another's termination. The result of having
multiple threads concurrently call pthread<sub>join</sub> is undefined in the
Pthreads standard.
</p></li>
</ul>
</div>

</div>

<div id="outline-container-2-7" class="outline-3">
<h3 id="sec-2-7">Why Use Threads Over Processes?</h3>
<div class="outline-text-3" id="text-2-7">

<p>Creating a new process can be expensive. It takes time. (A call into
the operating system is needed, and if the process creation triggers
process rescheduling activity, the operating system's
context-switching mechanism will become involved.) It takes memory.
(The entire process must be replicated.) Add to this the cost of
interprocess communication and synchronization of shared data, which
also may involve calls into the operating system kernel, and threads
provide an attractive alternative.
</p>
<p>
Threads can be created without replicating an entire process.
Furthermore, some, if not all, of the work of creating a thread is
done in user space rather than kernel space. When processes
synchronize, they usually have to issue system calls, a relatively
expensive operation that involves trapping into the kernel. But
threads can synchronize by simply monitoring a variable—in other
words, staying within the user address space of the program.
</p>

</div>

</div>

<div id="outline-container-2-8" class="outline-3">
<h3 id="sec-2-8">A Structured Programming Environment</h3>
<div class="outline-text-3" id="text-2-8">

</div>

</div>

<div id="outline-container-2-9" class="outline-3">
<h3 id="sec-2-9">Choosing Which Applications to Thread</h3>
<div class="outline-text-3" id="text-2-9">

</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Chapter 2 - Designing Threaded Programs</h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1">Some Common Problems</h3>
<div class="outline-text-3" id="text-3-1">

<p>The basic rule for managing shared resources is simple and twofold:     
</p><ul>
<li>Obtain a lock before accessing the resource.  
</li>
<li>Release the lock when you are finished with the resource.
</li>
</ul>

</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2">Performance</h3>
<div class="outline-text-3" id="text-3-2">

<ul>
<li>The memory and CPU cycles required to manage each thread, including
  the structures the operating system uses to manage them, plus the
  overhead for the Pthreads library and any special code in the
  operating system that supports the library.
</li>
<li>The CPU cycles spent for synchronization calls that enforce orderly
  access to shared data. These calls cost in CPU cycles to execute the
  calls.
</li>
<li>The time during which the application is inactive while one thread
  is waiting on another thread. This cost results from too many
  dependencies among threads and can be allayed by improved program
  design.
</li>
</ul>



</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3">Example: An ATM Server</h3>
<div class="outline-text-3" id="text-3-3">

<ul>
<li id="sec-3-3-1">Dynamically detaching a thread<br/>
The pthread<sub>detach</sub> function notifies the Pthreads library that we
don't want to join our worker threads: that is, we will never request
their exit status. If we don't explicitly tell the Pthreads library
that we don't care about a thread's exit status, it'll keep the shadow
of the thread alive indefinitely after the thread terminates (in the
same way that UNIX keeps the status of zombie processes around).
Detaching our worker threads frees the Pthreads library from storing
this information, thus saving space and time. We are still responsible
for freeing any space we dynamically allocated to hold the pthread<sub>t</sub>
itself.

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Chapter 3 - Synchronizing Pthreads</h2>
<div class="outline-text-2" id="text-4">


</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1">Overview</h3>
<div class="outline-text-3" id="text-4-1">

<p>Similarly, to make threads share data safely, we must ensure that
threads that would otherwise behave independently access shared data
in an orderly and controlled way. This concept is called
synchronization.
</p>
<p>
In a race condition, two or more threads access the same resource at
the same time.
</p>
</div>

</div>

<div id="outline-container-4-2" class="outline-3">
<h3 id="sec-4-2">Selecting the Right Synchronization Tool</h3>
<div class="outline-text-3" id="text-4-2">

<ul>
<li id="sec-4-2-1">pthread<sub>join</sub> functions<br/>
pthread<sub>join</sub> allows one thread to suspend execution until another has
terminated.

</li>
</ul>
<ul>
<li id="sec-4-2-2">Mutex variable functions<br/>
A mutex variable acts as a mutually exclusive lock, allowing threads
to control access to data. The threads agree that only one thread at a
time can hold the lock and access the data it protects. 
</li>
</ul>
<ul>
<li id="sec-4-2-3">Condition variable functions<br/>
A condition variable provides a way of naming an event in which
threads have a general interest. An event can be something as simple
as a counter's reaching a particular value or a flag being set or
cleared; it may be something more complex, involving a specific
coincidence of multiple events. Threads are interested in these
events, because such events signify that some condition has been met
that allows them to proceed with some particular phase of their
execution. The Pthreads library provides ways for threads both to
express their interest in a condition and to signal that an awaited
condition has been met. 
</li>
</ul>
<ul>
<li id="sec-4-2-4">pthread<sub>once</sub> function<br/>
pthread<sub>once</sub> is a specialized synchronization tool that ensures that
initialization routines get executed once and only once when called by
multiple threads.
</li>
</ul>
<ul>
<li id="sec-4-2-5">Some of the common synchronization mechanisms are:<br/>
<ul>
<li>Reader/writer exclusion Reader/writer locks allow multiple threads
  to read data concurrently but ensure that any thread writing to the data has exclusive access.
</li>
<li>hreadsafe data structures     You may find it useful to build
  synchronization primitives into a complex data structure so that
  each time you access it you don't need to make a separate call to
  synchronize concurrent access. 
</li>
<li>Semaphores    If your platform supports POSIX real-time extensions
  (POSIX.1b), you can take advantage of yet another common
  synchronization primitive for concurrent environments—semaphores. A
  counting semaphore is like a mutex but is associated with a counter.
</li>
</ul>


</li>
</ul>
</div>

</div>

<div id="outline-container-4-3" class="outline-3">
<h3 id="sec-4-3">Mutex Variables</h3>
<div class="outline-text-3" id="text-4-3">

<p>To protect a shared resource from a race condition, we use a type of
synchronization called mutual exclusion, or mutex for short.
</p>
<p>
However, we could take a different perspective and provide exclusive
access to the code paths or routines that access data. We call that
piece of code that must be executed atomically a critical section.
</p>
<p>
Using mutex variables in Pthreads is quite simple. Here's what you do:  
</p><ol>
<li>Create and initialize a mutex for each resource you want to
   protect, like a record in a database.        
</li>
<li>When a thread must access the resource, use pthread<sub>mutex</sub><sub>lock</sub> to
   lock the resource's mutex. The Pthreads library makes sure that
   only one thread at a time can lock the mutex; all other calls to
   the pthread<sub>mutex</sub><sub>lock</sub> function for the same mutex must wait until
   the thread currently holding the mutex releases it.  
</li>
<li>When the thread is finished with the resource, unlock the mutex by
   calling pthread<sub>mutex</sub><sub>unlock</sub>.
</li>
</ol>


<ul>
<li id="sec-4-3-1">Using Mutexes<br/>
<ul>
<li>static 
</li>
</ul>

<p><code>pthread_mutex_t global_data_mutex = PTHREAD_MUTEX_INITIALIZER;</code>
</p><ul>
<li>dynamic
</li>
</ul>




<pre class="src src-c"><span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutexp</span>;        
  .     
mutexp=(<span style="color: #98fb98;">pthread_mutex_t</span> *)malloc(<span style="color: #00ffff;">sizeof</span>(pthread_mutex_t));    
pthread_mutex_init(mutexp, <span style="color: #7fffd4;">NULL</span>);
</pre>


</li>
</ul>
<ul>
<li id="sec-4-3-2">Using pthread<sub>mutex</sub><sub>trylock</sub><br/>
Somewhat more acceptable is the specialized use of
pthread<sub>mutex</sub><sub>trylock</sub> by real-time programmers to poll for state
changes. This practice may be inefficient, but it does allow real-time
programs to respond quickly to a condition that warrants speed.

<p>
Another situation in which a pthread<sub>mutex</sub><sub>trylock</sub> is often used is in
detecting and avoiding deadlock in locking hierarchies and priority
inversion situations.
</p></li>
</ul>
<ul>
<li id="sec-4-3-3">Some Shortcomings of Mutexes<br/>
read and write lock

<p>
In some circumstances, it would be useful if we could define a
recursivelock: that is a lock that can be relocked any number of times
by its current holder. It would be nice if we could specify this
ability in a mutex attribute object. We can imagine the Pthreads
library associating an internal counter with a recursive mutex to
count the number of times its current holder has called
pthread<sub>mutex</sub><sub>lock</sub>. Each time the current holder calls
pthread<sub>mutex</sub><sub>unlock</sub>, the library would decrement this counter. The
lock would not be released until the call that brings the count down
to zero is issued.
</p>
<p>
A recursive mutex is useful for a thread that makes a number of nested
calls to a routine that locks and manipulates a resource. You lock the
mutex recursively each time the thread enters the routine and unlock
it at all exit points. If the thread already holds the lock, the calls
merely increase and decrease the recursive count and don't deadlock
the thread. If you did not use a recursive mutex, you'd need to
distinguish somehow between the times when the thread already holds
the lock when it calls the routine and those when it needs to make a
prior mutex lock call.
</p>
</li>
</ul>
<ul>
<li id="sec-4-3-4">Contention for a Mutex<br/>
If more than one thread is waiting for a locked mutex, which thread is
the first to be granted the lock once it's released? The choice is
made according to the scheduling priorities of the individual threads.

<p>
The use of priorities in a multithreaded program can lead to a classic
multiprocessing problem: priority inversion. Priority inversion
involves a low priority thread that holds a lock that a higher
priority thread wants. Because the higher priority thread cannot
continue until the lower priority thread releases the lock, each
thread is actually treated as if it had the inverse of its intended
priority.
</p></li>
</ul>
<ul>
<li id="sec-4-3-5">Sharing a Mutex Among Processes<br/>
If your platform allows you to set the process-shared attribute, the
compile-time constant <sub>POSIX</sub><sub>THREAD</sub><sub>PROCESS</sub><sub>SHARED</sub> will be TRUE.

<p>
To set the process-shared attribute, supply the PTHREAD<sub>PROCESS</sub><sub>SHARED</sub>
constant in a pthread<sub>mutexattr</sub><sub>setshared</sub> call. To revert to a
process-private mutex, specify the PTHREAD<sub>PROCESS</sub><sub>PRIVATE</sub> constant.
Processes that share a mutex must be able to access it in shared
memory (created through System V shared memory mechanisms or through
mmap calls). 
</p>



<pre class="src src-c"><span style="color: #b0c4de;">        #include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>     
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>      
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>     
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>     
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>  
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/ipc.h&gt;</span>    
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/shm.h&gt;</span>    
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>   
<span style="color: #b0c4de;">#if</span><span style="color: #b0c4de;">n</span><span style="color: #b0c4de;">def</span> _POSIX_THREAD_PROCESS_SHARED    
<span style="color: #b0c4de;">#error</span> <span style="color: #ffa07a;">"This platform does not support process shared mutex"    </span>
<span style="color: #b0c4de;">#endif</span>  
<span style="color: #98fb98;">int</span>   <span style="color: #eedd82;">shared_mem_id</span>;    
<span style="color: #98fb98;">int</span>   *<span style="color: #eedd82;">shared_mem_ptr</span>;  
<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mptr</span>;  
<span style="color: #98fb98;">pthread_mutex_attr_t</span> <span style="color: #eedd82;">mutex_shared_attr</span>; 
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span>      
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)      
{       
  <span style="color: #98fb98;">pid_t</span>  <span style="color: #eedd82;">child_pid</span>;     
  <span style="color: #98fb98;">int</span>  <span style="color: #eedd82;">status</span>;  
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">initialize shared memory segment </span><span style="color: #ff7f24;">*/</span>        
  shared_mem_id = shmget(IPC_PRIVATE, 1*<span style="color: #00ffff;">sizeof</span>(pthread_mutex_t), 0660); 
  shared_mem_ptr = (<span style="color: #98fb98;">int</span> *)shmat(shared_mem_id, (<span style="color: #98fb98;">void</span> *)0, 0);   
  mptr = shared_mem_ptr;        
  pthread_mutexattr_init(&amp;mutex_shared_attr);   
  pthread_mutexattr_setshared(&amp;mutex_shared_attr, PTHREAD_PROCESS_SHARED);      
  pthread_mutex_init(mptr, &amp;mutex_shared_attr); 
  <span style="color: #00ffff;">if</span> ((child_pid = fork()) == 0) {      
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">child </span><span style="color: #ff7f24;">*/</span>   
           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">create more threads </span><span style="color: #ff7f24;">*/</span>    
           pthread_mutex_lock(mptr);    
           .    
  } <span style="color: #00ffff;">else</span> {      
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">parent </span><span style="color: #ff7f24;">*/</span>  
           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">create more threads </span><span style="color: #ff7f24;">*/</span>    
           pthread_mutex_lock(mptr);    
           .    
}
</pre>




</li>
</ul>
</div>

</div>

<div id="outline-container-4-4" class="outline-3">
<h3 id="sec-4-4">Condition Variables</h3>
<div class="outline-text-3" id="text-4-4">




<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>      
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>    
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">TCOUNT</span> 10       
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">WATCH_COUNT</span> 12  
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span> = 0;  
<span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">count_mutex</span> = PTHREAD_MUTEX_INITIALIZER;        
<span style="color: #98fb98;">pthread_cond_t</span> <span style="color: #eedd82;">count_threshold_cv</span> = PTHREAD_COND_INITIALIZER;   
<span style="color: #98fb98;">int</span>  <span style="color: #eedd82;">thread_ids</span>[3] = {0,1,2};   
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span>      
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)      
{       
     <span style="color: #98fb98;">int</span>      <span style="color: #eedd82;">i</span>;        
     <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[3];      
     pthread_create(&amp;threads[0],<span style="color: #7fffd4;">NULL</span>,inc_count, &amp;thread_ids[0]);        
     pthread_create(&amp;threads[1],<span style="color: #7fffd4;">NULL</span>,inc_count, &amp;thread_ids[1]);        
     pthread_create(&amp;threads[2],<span style="color: #7fffd4;">NULL</span>,watch_count, &amp;thread_ids[2]);      
     <span style="color: #00ffff;">for</span> (i = 0; i &lt; 3; i++) {  
              pthread_join(threads[i], <span style="color: #7fffd4;">NULL</span>);   
     }  
     <span style="color: #00ffff;">return</span> 0;  
}       
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">watch_count</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">idp</span>)      
{       
     pthread_mutex_lock(&amp;count_mutex)   
     <span style="color: #00ffff;">while</span> (count &lt;= WATCH_COUNT) {     
              pthread_cond_wait(&amp;count_threshold_cv,    
                               &amp;count_mutex);   
              printf(<span style="color: #ffa07a;">"watch_count(): Thread %d,Count is %d\n"</span>,  
                   *idp, count);        
     }  
     pthread_mutex_unlock(&amp;count_mutex);        
}       
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">inc_count</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">idp</span>)        
{       
     <span style="color: #00ffff;">for</span> (i =0; i &lt; TCOUNT; i++) {      
              pthread_mutex_lock(&amp;count_mutex); 
              count++;  
              printf(<span style="color: #ffc0cb; font-weight: bold;">"</span><span style="color: #ffa07a;">inc_count(): Thread %d, old count %d,\    </span>
<span style="color: #ffa07a;">                   new count %d\n"</span>, *idp, count - 1, count );   
              <span style="color: #00ffff;">if</span> (count == WATCH_COUNT) 
                   pthread_cond_signal(&amp;count_threshold_cv);    
              pthread_mutex_unlock(&amp;count_mutex);       
     }  
}
</pre>


<p>
A condition variable has a data type of pthread<sub>cond</sub><sub>t</sub>. You can
initialize it statically as we do in Example 3-7, or you can
initialize it dynamically by calling pthread<sub>cond</sub><sub>init</sub>, as
follows:        
</p>
<p>
<code>pthread_cond_init(&amp;count_threshold_cv, NULL);</code>
</p>
<p>
If count is not the desired value, the thread calls pthread<sub>cond</sub><sub>wait</sub>
to put itself into a wait on the count<sub>threshold</sub><sub>cv</sub> condition
variable. The pthread<sub>cond</sub><sub>wait</sub> function releases the count mutex
while the thread is waiting so other threads have the opportunity to
modify count.
</p>
<ul>
<li id="sec-4-4-1">The thread can wait on the condition variable.<br/>
To wait on a condition variable, a thread calls pthread<sub>cond</sub><sub>wait</sub> or
pthread<sub>cond</sub><sub>timedwait</sub>. 
</li>
</ul>
<ul>
<li id="sec-4-4-2">it can signal other threads waiting on the condition variable.<br/>
To release threads that are waiting on a condition variable, a thread
calls pthread<sub>cond</sub><sub>signal</sub> or pthread<sub>cond</sub><sub>broadcast</sub>.

</li>
</ul>
<ul>
<li id="sec-4-4-3">Using a Mutex with a Condition Variable<br/>
It is important to use condition variables and mutexes together
properly.

<p>
A call to pthread<sub>cond</sub><sub>wait</sub> requires that a locked mutex be passed in
along with the condition variable. The system releases the mutex on
the caller's behalf when the wait for the condition begins. In concert
with the actions of the waiting thread, the thread that issues the
pthread<sub>cond</sub><sub>signal</sub> or pthread<sub>cond</sub><sub>broadcast</sub> call holds the mutex at
the time of the call but must release it after the call. Then, when
the system wakes it up, a waiting thread can regain control of the
mutex. It too must release the mutex when it's finished with
it.     
</p>
</li>
</ul>
<ul>
<li id="sec-4-4-4">When Many Threads Are Waiting<br/>
If all waiting threads are of the same priority, they are released in
a first-in first-out order for each pthread<sub>cond</sub><sub>signal</sub> call that's
issued

<p>
The pthread<sub>cond</sub><sub>broadcast</sub> function releases all threads at once from
their waits on the condition variable, but there is a hitch.
</p>
<p>
 It does so by applying the same criterion it uses when selecting the
 thread it wakes when a phread<sub>cond</sub><sub>signal</sub> call signals a
 condition—scheduling order.The other threads are moved to the queue
 of threads that are waiting to acquire the mutex.
</p></li>
</ul>
<ul>
<li id="sec-4-4-5">Checking the Condition on Wake Up: Spurious Wake Ups<br/>
Well, we check the event one more time primarily to ensure
correctness: if multiple threads were waiting on the same condition
variable, another thread could have already been awakened, perhaps
decrementing the count, before our thread was able to run. Second, we
want to guard against a condition known as a spurious wake up. 
</li>
</ul>
<ul>
<li id="sec-4-4-6">Condition Variable Attributes<br/>
A Pthreads condition variable attribute object is of data type
<code>pthread_condattr_t</code>.You initialize and deinitialize the condition
variable attribute object by calling <code>pthread_condattr_init</code> and
<code>pthread_condattr_destroy</code>, respectively.







</li>
</ul>
</div>

</div>

<div id="outline-container-4-5" class="outline-3">
<h3 id="sec-4-5">Reader/Writer Locks</h3>
<div class="outline-text-3" id="text-4-5">

<p>We'll start by defining a reader/writer variable of type
<code>pthread_rdwr_t</code> and by creating the functions that operate on it
</p><ul>
<li id="sec-4-5-1">Reader/Writer Lock Functions<br/>



<pre class="src src-sh">pthread_rdwr_init_np    Initialize reader/writer lock   
pthread_rdwr_rlock_np   Obtain read lock        
pthread_rdwr_wlock_np   Obtain write lock       
pthread_rdwr_runlock_np Release read lock       
pthread_rdwr_wunlock_np Release write lock
</pre>

</li>
</ul>
<ul>
<li id="sec-4-5-2">implement<br/>



<pre class="src src-c"><span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">initialize</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_rdwr_init_np</span>(<span style="color: #98fb98;">pthread_rdwr_t</span> *<span style="color: #eedd82;">rdwrp</span>, <span style="color: #98fb98;">pthread_rdwrattr_t</span>  *<span style="color: #eedd82;">attrp</span> )    
{       
          rdwrp-&gt;readers_reading = 0;   
          rdwrp-&gt;writer_writing = 0;    
          pthread_mutex_init(&amp;(rdwrp-&gt;mutex), <span style="color: #7fffd4;">NULL</span>);    
          pthread_cond_init(&amp;(rdwrp-&gt;lock_free), <span style="color: #7fffd4;">NULL</span>); 
          <span style="color: #00ffff;">return</span> 0;     
}

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">read locking a read/write lock</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_rdwr_rlock_np</span>(<span style="color: #98fb98;">pthread_rdwr_t_np</span> *<span style="color: #eedd82;">rdwrp</span>)     
{       
          pthread_mutex_lock(&amp;(rdwrp-&gt;mutex));  
          <span style="color: #00ffff;">while</span>(rdwrp-&gt;writer_writing) {        
                  pthread_cond_wait(&amp;(rdwrp-&gt;lock_free), &amp;(rdwrp-&gt;mutex));      
          }     
          rdwrp-&gt;readers_reading++;     
          pthread_mutex_unlock(&amp;(rdwrp-&gt;mutex));        
          <span style="color: #00ffff;">return</span> 0;     
}
<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">write locking a read/write lock</span>
        <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_rdwr_wlock_np</span>(<span style="color: #98fb98;">pthread_rdwr_t_np</span> *<span style="color: #eedd82;">rdwrp</span>)     
{       
          pthread_mutex_lock(&amp;(rdwrp-&gt;mutex));  
          <span style="color: #00ffff;">while</span> (rdwrp-&gt;writer_writing || rdwrp-&gt;readers_reading) {     
                   pthread_cond_wait(&amp;(rdwrp-&gt;lock_free), &amp;(rdwrp-&gt;mutex));     
          }     
          rdwrp-&gt;writer_writing++;      
          pthread_mutex_unlock(&amp;(rdwrp-&gt;mutex));        
          <span style="color: #00ffff;">return</span> 0;     
}
<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">read unlocking a read/write lock</span>
        <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_rdwr_runlock_np</span>(<span style="color: #98fb98;">pthread_rdwr_t_np</span> *<span style="color: #eedd82;">rdwrp</span>) { 
          pthread_mutex_lock(&amp;(rdwrp-&gt;mutex));  
          <span style="color: #00ffff;">if</span> (rdwrp-&gt;readers_reading == 0) {    
                    pthread_mutex_unlock(&amp;(rdwrp-&gt;mutex));      
                    <span style="color: #00ffff;">return</span> -1;  
          } <span style="color: #00ffff;">else</span> {      
                    rdwrp-&gt;readers_reading--;   
                    <span style="color: #00ffff;">if</span> (rdwrp-&gt;readers_reading == 0)    
                              pthread_cond_signal(&amp;(rdwrp-&gt;lock_free)); 
                    pthread_mutex_unlock(&amp;(rdwrp-&gt;mutex));      
                    <span style="color: #00ffff;">return</span> 0;   
          }     
}
<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">write unlocking a reader/write lock</span>
        <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_rdwr_wunlock_np</span>(<span style="color: #98fb98;">pthread_rdwr_t_np</span> *<span style="color: #eedd82;">rdwrp</span>) { 
          pthread_mutex_lock(&amp;(rdwrp-&gt;mutex));  
          <span style="color: #00ffff;">if</span> (rdwrp-&gt;writer_writing == 0) {     
                    pthread_mutex_unlock(&amp;(rdwrp-&gt;mutex));      
                    <span style="color: #00ffff;">return</span> -1;  
          } <span style="color: #00ffff;">else</span> {      
                    rdwrp-&gt;writer_writing = 0;  
                    pthread_cond_broadcast(&amp;(rdwrp-&gt;lock_free));        
                    pthread_mutex_unlock(&amp;(rdwrp-&gt;mutex));      
                    <span style="color: #00ffff;">return</span> 0;   
          }     
}

</pre>




</li>
</ul>
<ul>
<li id="sec-4-5-3">issue<br/>
 If the lock is currently held by a reader and a writer is already
 waiting, any reader that comes along next will get the lock before
 the waiting writer. As long as one or more readers are waiting for
 the lock, regardless of when they made their requests or where in the
 waiting lists they're queued relative to any potential writers, the
 lock will continue to be held for reading.

<p>
The decision of how to handle incoming reads versus pending writes
depends on the priorities of a given system.    
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-4-6" class="outline-3">
<h3 id="sec-4-6">Synchronization in the ATM Server</h3>
<div class="outline-text-3" id="text-4-6">

</div>

</div>

<div id="outline-container-4-7" class="outline-3">
<h3 id="sec-4-7">Thread Pools</h3>
<div class="outline-text-3" id="text-4-7">

<p>but it can slow our server in a couple of different ways:       
</p><ul>
<li>We don't reuse idle threads to handle new requests. Rather, we
  create—and destroy—a thread for each request we receive.
  Consequently, our server spends a lot of time in the Pthreads
  library.
</li>
<li>We've added to each request's processing time (a request's latency,
  to use a term from an engineering design spec) the time it takes to
  create a thread. No wonder our ATM customers keep tapping the Enter
  button and scowling at the camera!
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">Chapter 4 - Managing Pthreads</h2>
<div class="outline-text-2" id="text-5">


</div>

<div id="outline-container-5-1" class="outline-3">
<h3 id="sec-5-1">Setting Thread Attributes</h3>
<div class="outline-text-3" id="text-5-1">

<p>we'd perform the following steps:       
</p><ol>
<li>Define an attribute object of type pthread<sub>attr</sub><sub>t</sub>.   
</li>
<li>Call pthread<sub>attr</sub><sub>init</sub> to declare and initialize the attribute object.       
</li>
<li>Make calls to specific Pthreads functions to set individual attributes in the object.        
</li>
<li>Specify the fully initialized attribute object to the
   pthread<sub>create</sub> call that creates the thread.
</li>
</ol>


<ul>
<li id="sec-5-1-1">Setting a Thread's Stack Size<br/>
 a process stack normally starts in high memory and works its way down
 in memory without anything in its way until it reaches 0. For a
 process with individual threads, one thread's stack is bounded by the
 start of the next thread's stack, even if the next thread isn't using
 all of its stack space.

<p>
To set a thread's stack size, we call pthread<sub>attr</sub><sub>init</sub> to declare and
initialize a custom thread attribute object (pthread<sub>attr</sub><sub>t</sub>)
</p>



<pre class="src src-c"><span style="color: #b0c4de;">  #define</span> <span style="color: #eedd82;">MIN_REQ_SSIZE</span> 81920     
  <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">default_stack_size</span>;      
  <span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">stack_size_custom_attr</span>;

  pthread_attr_init(&amp;stack_size_custom_attr);

<span style="color: #b0c4de;">  #ifdef</span> _POSIX_THREAD_ATTR_STACKSIZE     
  pthread_attr_getstacksize(&amp;stack_size_custom_attr,      
                 &amp;default_stack_size);    
  <span style="color: #00ffff;">if</span> (default_stack_size &lt; MIN_REQ_SSIZE) {;
    pthread_attr_setstacksize(&amp;stack_size_custom_attr,  
                   (<span style="color: #98fb98;">size_t</span>)MIN_REQ_SSIZE);      
}       
<span style="color: #b0c4de;">#endif</span>

</pre>

</li>
</ul>
<ul>
<li id="sec-5-1-2">Setting a Thread's Detached State<br/>
Detaching from a thread informs the Pthreads library that no other
thread will use the pthread<sub>join</sub> mechanism to synchronize with the
thread's exiting. Because the library doesn't preserve the exit status
of a detached thread, it can operate more efficiently and make the
library resources that were associated with a thread available for
reuse more quickly. If no other thread cares when a particular thread
in your program exits, consider detaching that thread.




<pre class="src src-c"><span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">detached_attr</span>;
pthread_attr_setdetachedstate(&amp;detached_attr, PTHREAD_CREATE_DETACHED);
pthread_create(&amp;thread, &amp;detached_attr, ...);
</pre>

</li>
</ul>
</div>

</div>

<div id="outline-container-5-2" class="outline-3">
<h3 id="sec-5-2">The pthread<sub>once</sub> Mechanism</h3>
<div class="outline-text-3" id="text-5-2">

<p>The pthread<sub>once</sub> mechanism is the tool of choice for these situations.
It, like mutexes and condition variables, is a synchronization tool,
but its specialty is handling synchronization among threads at
initialization time. 
</p>
<p>
Remember, our library's multithreaded. How do we know whether or not
another thread might be trying to initialize the same objects
simultaneously?
</p>
<ul>
<li id="sec-5-2-1">Example: The ATM Server's Communication Module<br/>
Thread A checks the value of srv<sub>comm</sub><sub>inited</sub> and finds FALSE. Thread B
checks the value and also finds it FALSE. Then they both go forward
and call srv<sub>comm</sub><sub>init</sub>. 

<p>
We'll consider two viable solutions:    
</p><ul>
<li>Adding a mutex to protect the srv<sub>comm</sub><sub>inited</sub> flag and
  server<sub>comm</sub><sub>init</sub> routine. Using PTHREAD<sub>MUTEX</sub><sub>INITIALIZER</sub>, we'll
  statically initialize this mutex.     
</li>
<li>Designating that the entire routine needs special synchronization
  handling by calling the pthread<sub>once</sub> function.
</li>
</ul>


</li>
</ul>
<ul>
<li id="sec-5-2-2">Using the pthread<sub>once</sub> mechanism<br/>
If we use the server<sub>comm</sub><sub>init</sub> routine only through the pthread<sub>once</sub>
mechanism, we can make the following synchronization guarantees:
<ul>
<li>No matter how many times it is invoked by one or more threads, the
  routine will be executed only once by its first caller.
</li>
<li>No caller will exit from the &lt;emphasis&gt;pthread<sub>once&lt</sub>;/emphasis&gt;
  mechanism until the routine's first caller has returned
</li>
</ul>




<pre class="src src-c"><span style="color: #98fb98;">pthread_once_t</span>      <span style="color: #eedd82;">srv_comm_inited_once</span> = PTHREAD_ONCE_INIT;   

pthread_once(&amp;srv_comm_inited_once, server_comm_init);
</pre>


<p>
no longer has to test a flag to determine whether to proceed with
initialization. Instead, it calls pthread<sub>once</sub>, specifying the once
block and the routine
</p>
<p>
You can declare multiple once blocks in a program, associating each
with a different routine. Be careful, though. Once you associate a
routine with the pthread<sub>once</sub> mechanism, you must always call it
through a pthread<sub>once</sub> call, using the same once block. You cannot
call the routine directly elsewhere in your program without subverting
the synchronization the pthread<sub>once</sub> mechanism is meant to provide
</p>
<p>
Notice that the pthread<sub>once</sub> interface does not allow you to pass
arguments to the routine that is protected by the once block. If
you're trying to fit a predefined routine with arguments into the
pthread<sub>once</sub> mechanism, you'll have to fiddle a bit with global
variables, wrapper routines, or environment variables to get it to
work properly.
</p>

</li>
</ul>
</div>

</div>

<div id="outline-container-5-3" class="outline-3">
<h3 id="sec-5-3">Keys: Using Thread-Specific Data</h3>
<div class="outline-text-3" id="text-5-3">

<ul>
<li id="sec-5-3-1">Overview<br/>
To maintain long-lived data associated with a thread, we normally have two options:     
<ul>
<li>Pass the data as an argument to each call the thread makes.   
</li>
<li>Store the data in a global variable associated with the thread.

<p>
 Most likely you don't have the option of redefining the library's
  call arguments. Because you don't necessarily know at compile time
  how many threads will be making library calls, it's very difficult
  to define an adequate number of global variables with the right
  amount of storage. Fortunately, the Pthreads standard provides a
  clever way of maintaining thread-specific data in such cases.
</p></li>
</ul>


<p>
Certain applications also use thread-specific data with keys to
associate special properties with a thread in one routine and then
retrieve them in another. Some examples include:
</p><ul>
<li>A resource management module (such as a memory manager or a file
  manager) could use a key to point to a record of the resources that
  have been allocated for a given thread. When the thread makes a call
  to allocate more resources, the module uses the key to retrieve the
  thread's record and process its request.
</li>
<li>A performance statistics module for threads could use a key to point
  to a location where it saves the starting time for a calling thread.
</li>
<li>A debugging module that maintains mutex statistics could use a key
  to point to a per-thread count of mutex locks and unlocks.
</li>
<li>A thread-specific exception-handling module, when servicing a try
  call (which starts execution of the normal code path), could use a
  key to point to a location to which to jump in case the thread
  encounters an exception. The occurrence of an exception triggers a
  catch call to the module. The module checks the key to determine
  where to unwind the thread's execution.
</li>
<li>A random number generation module could use a key to point to a
  location where it maintains a unique seed value and number stream
  for each thread that calls it to obtain random numbers.
</li>
</ul>


<p>
These examples share some common characteristics:       
</p><ul>
<li>They are libraries with internal state.       
</li>
<li>They don't require their callers to provide context in interface
  arguments. They don't burden the caller with maintaining this type
  of context in the global environment.
</li>
<li>In a nonthreaded environment, the data to which the key refers would
  normally be stored as static data.
</li>
</ul>


<p>
Note that thread-specific data is not a distinct data section like
global, heap, and stack. It offers no special system protection or
performance guarantees; it's as private or shared as other data in the
same data section. There are no special advantages to using
thread-specific data if you aren't writing a library and if you know
exactly how many threads will be in your program at a given time. If
this is the case, just allocate a global array with an element for
each known thread and store each thread's data in a separate element.
</p>

</li>
</ul>
<ul>
<li id="sec-5-3-2">Initializing a Key: pthread<sub>key</sub><sub>create</sub><br/>



<pre class="src src-c">        <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">pthread_key_t</span> <span style="color: #eedd82;">conn_key</span>;
     pthread_key_create(&amp;conn_key, (<span style="color: #98fb98;">void</span> *)free_conn);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">free_conn</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">connp</span>)      
{       
       free(connp);     
}
</pre>


<p>
The pthread<sub>key</sub><sub>create</sub> call takes two arguments: the key and a
destructor routine. 
</p>
<p>
        When you're done with a key, call pthread<sub>key</sub><sub>delete</sub> to allow
        the library to recover resources associated with the key
        itself.
</p></li>
</ul>
<ul>
<li id="sec-5-3-3">Associating Data with a Key<br/>
You must always use <code>pthread_setspecific</code> and <code>pthread_getspecific</code> to
refer to any data item that is being managed by a key.



<pre class="src src-c"><span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">connp</span>;
connp = (<span style="color: #98fb98;">int</span> *)malloc(<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>));
pthread_setspecific(conn_key, (<span style="color: #98fb98;">void</span> *)connp);
</pre>


<p>
The pthread<sub>setspecific</sub> routine takes, as an argument, a pointer to
the data to be associated with the key—not the data itself. 
</p>
</li>
</ul>
<ul>
<li id="sec-5-3-4">Retrieving Data from a Key<br/>
 Each routine uses a pointer, saved<sub>connp</sub>, to point to the connection
 identifier, 



<pre class="src src-c"><span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">saved_connp</span>;
pthread_getspecific(conn_key, (<span style="color: #98fb98;">void</span> **)&amp;saved_connp);   
write(*saved_connp,...);
</pre>


</li>
</ul>
<ul>
<li id="sec-5-3-5">Destructors<br/>
</li>
</ul>
</div>

</div>

<div id="outline-container-5-4" class="outline-3">
<h3 id="sec-5-4">Cancellation</h3>
<div class="outline-text-3" id="text-5-4">

<p>Cancellation allows one thread to terminate another.
</p>
<p>
Now you must reckon whether the thread you've targeted can be canceled
at all. The ability of a thread to go away or not go away when asked
by another thread is known as its cancelability state. Now you must
consider when it might go away—maybe immediately, maybe a bit later.
The degree to which a thread persists after it has been asked to go
away is known as its cancelability type
</p>
<ul>
<li id="sec-5-4-1">The Complication with Cancellation<br/>
The simplest approach is to restrict the use of cancellation to
threads that execute only in simple routines that do not hold locks or
ever put shared data in an inconsistent state. Another option is to
restrict cancellation to certain points at which a thread is known to
have neither locks nor resources. Lastly, you could create a cleanup
stack for the thread that is to be canceled; it can then use the
cleanup stack to release locks and reset the state of shared data.

</li>
</ul>
<ul>
<li id="sec-5-4-2">Cancelability Types and States<br/>
Because canceling a thread that holds locks and manipulates shared
data can be a tricky procedure, the Pthreads standard provides a
mechanism by which you can set a given thread's cancel ability 

<p>
A thread can set its own cancel ability only at run time, dynamically,
by calling into the Pthreads library.
</p>
</li>
</ul>
<ul>
<li id="sec-5-4-3">Cancellation Points: More on Deferred Cancellation<br/>
These pending cancellations are delivered to a thread at defined
locations in its code path. These locations are known as cancellation
points, and they come in two flavors:

<ul>
<li>Automatic cancellation points
  (pthread<sub>cond</sub><sub>wait</sub>,pthread<sub>cond</sub><sub>timedwait</sub>, and pthread<sub>join</sub>). The
  Pthreads library defines these function calls as cancellation points
  because they can block the calling thread. Rather than maintain the
  overhead of a blocked routine that's destined to be canceled, the
  Pthreads library considers these calls to be a license to kill the
  thread. Note that, if the thread for which the cancellation is
  pending does not call any of these functions, it may never actually
  be terminated. This is one of the reasons you may need to consider
  using a programmer-defined cancellation point.
</li>
<li>Programmer-defined cancellation points (pthread<sub>testcancel</sub>).To force
  a pending cancellation to be delivered at a particular point ina
  thread's code path, insert a call to pthread<sub>testcancel</sub>. The
  pthread<sub>testcancel</sub> function causes any pending cancellation to be
  delivered to the thread at the program location where it occurs. If
  no cancellation is pending on the thread, nothing happens. Thus, you
  can freely insert this call at those places in a thread's code path
  where it's safe for the thread to terminate. It's also prudent to
  call pthread<sub>testcancel</sub> before a thread starts a time-consuming
  operation. If a cancellation is pending on the thread, it's better
  to terminate it as soon as possible, rather than have it continue
  and consume system resources needlessly.
</li>
</ul>



</li>
</ul>
<ul>
<li id="sec-5-4-4">A Simple Cancellation Example<br/>



<pre class="src src-c"><span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">main:</span>

  <span style="color: #ff7f24;">/**** </span><span style="color: #ff7f24;">cancel each thread ***</span><span style="color: #ff7f24;">*/</span>        
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; NUM_THREADS; i++) {;  
    pthread_cancel(threads[i]); 
  }
<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">1.</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">last_state</span>;
pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &amp;last_state);

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">2.</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">last_state</span>, <span style="color: #eedd82;">last_type</span>;
pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &amp;last_state);
pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &amp;last_type);
pthread_testcancel();

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">3.</span>
pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &amp;last_type); 
pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &amp;last_state);
</pre>

</li>
</ul>
<ul>
<li id="sec-5-4-5">Cleanup Stacks<br/>
Pthreads associates a cleanup stack with each thread.

<p>
A cleanup stack contains pointers to routines to be executed just
before the thread terminates.By default the stack is empty; you use
pthread<sub>cleanup</sub><sub>push</sub> to add routines to the stack, and
pthread<sub>cleanup</sub><sub>pop</sub> to remove them. When the library processes a
thread's termination, the thread executes routines from the cleanup
stack in last-in first-out order.
</p>



<pre class="src src-c"> <span style="color: #ff7f24;">/*     </span>
<span style="color: #ff7f24;"> Cleanup routine: last_breath   </span>
<span style="color: #ff7f24;"> </span><span style="color: #ff7f24;">*/</span>     
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">last_breath</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">messagep</span>)        
{       
  printf(<span style="color: #ffa07a;">"\n\n%s last_breath cleanup routine: freeing 0x%x\n\n"</span>, messagep,      
          messagep);    
  free(messagep);       
}

pthread_cleanup_push((<span style="color: #98fb98;">void</span> *)last_breath, (<span style="color: #98fb98;">void</span> *)messagep);
</pre>


<p>
First, pthread<sub>cleanup</sub><sub>pop</sub> takes a single argument—an integer that can have either of two values:       
</p><ul>
<li>If the value of this argument is 1, the thread that called
  pthread<sub>cleanup</sub><sub>pop</sub> executes the cleanup routine whose pointer is
  being removed from the cleanup stack. Afterwards, the thread resumes
  at the line following its pthread<sub>cleanup</sub><sub>pop</sub> call. This allows a
  thread to execute a cleanup routine whether or not it is actually
  being terminated.
</li>
<li>If the value of this argument is 0, the pointer to the routine is
  popped off the cleanup stack, but the routine itself does not
  execute.
</li>
</ul>


<p>
Second, the Pthreads standard requires that there be one
pthread<sub>cleanup</sub><sub>pop</sub> for each pthread<sub>cleanup</sub><sub>push</sub> within a given
lexical scope of code.
</p>
<ul>
<li id="sec-5-4-5-1">Cancellation in the ATM Server<br/>
</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-5-5" class="outline-3">
<h3 id="sec-5-5">Scheduling Pthreads</h3>
<div class="outline-text-3" id="text-5-5">

<p>If your system supports the scheduling programming interface, the
compile-time constant <sub>POSIX</sub><sub>THREAD</sub><sub>PRIORITY</sub><sub>SCHEDULING</sub> will be TRUE.
</p>
<ul>
<li id="sec-5-5-1">Scheduling Priority and Policy<br/>
The eligibility of any given thread for special scheduling treatment
is determined by the settings of two thread-specific attributes:
<ul>
<li>Scheduling priority   A thread's scheduling priority, in relation to
  that of other threads, determines which thread gets preferential
  access to the available CPUs at any given time.
</li>
<li>Scheduling policy     A thread's scheduling policy is a way of
  expressing how threads of the same priority run and share the
  available CPUs.
</li>
</ul>

</li>
</ul>
<ul>
<li id="sec-5-5-2">Scheduling Scope and Allocation Domains<br/>



<pre class="src src-c"><span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">custom_sched_attr</span>;
pthread_attr_init(&amp;custom_sched_attr);
pthread_attr_setscope(&amp;custom_sched_attr, PTHREAD_SCOPE_SYSTEM);        
pthread_create(&amp;thread, &amp;custom_sched_attr, ...);
</pre>


<p>
The pthread<sub>attr</sub><sub>setscope</sub> function sets the scheduling-scope attribute
in a thread attribute object to either system-scope scheduling
(PTHREAD<sub>SCOPE</sub><sub>SYSTEM</sub>), or process-scope scheduling
(PTHREAD<sub>SCOPE</sub><sub>PROCESS</sub>).
</p>

<ul>
<li>When we say pool of threads, we mean: 
  In process scope: all other threads in the same process       
  In system scope: all threads of all processes in the same allocation domain   

</li>
<li>When we say scheduler, we mean:       
  In process scope: the Pthreads library and/or the scheduler in the operating system's kernel  
  In system scope: the scheduler in the operating system's kernel       

</li>
<li>When we say processing slot, we mean: 
  In process scope: the portion of CPU time allocated to the process as a whole within its allocation domain    
  In system scope: the portion of CPU time allocated to a specific thread within its allocation domain
</li>
</ul>


</li>
</ul>
<ul>
<li id="sec-5-5-3">Runnable and Blocked Threads<br/>
</li>
</ul>
<ul>
<li id="sec-5-5-4">Scheduling Policy<br/>
The two main scheduling policies are SCHED<sub>FIFO</sub> and SCHED-RR:
<ul>
<li>SCHED<sub>FIFO</sub>    This policy (first-in first-out) lets a thread run
  until it either exits or blocks. As soon as it becomes unblocked, a
  blocked thread that has given up its processing slot is placed at
  the end of its priority queue.
</li>
<li>SCHED<sub>RR</sub>      This policy (round robin) allows a thread to run for
  only a fixed amount of time before it must yield its processing slot
  to another thread of the same priority. This fixed amount of time is
  usually referred to as a quantum. When a thread is interrupted, it
  is placed at the end of its priority queue.
</li>
</ul>

</li>
</ul>
<ul>
<li id="sec-5-5-5">Using Priorities and Policies<br/>
</li>
</ul>
<ul>
<li id="sec-5-5-6">Setting Scheduling Policy and Priority<br/>
We specify it in calls to pthread<sub>attr</sub><sub>setschedpolicy</sub> to set the
scheduling policy and pthread<sub>attr</sub><sub>setschedparam</sub> to set the scheduling
priority



<pre class="src src-c"><span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">custom_sched_attr</span>;       
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fifo_max_prio</span>, <span style="color: #eedd82;">fifo_min_prio</span>;       
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sched_param</span> <span style="color: #eedd82;">fifo_param</span>;  
.       
.       
  pthread_attr_init(&amp;custom_sched_attr);        
  pthread_attr_setinheritsched(&amp;custom_sched_attr, PTHREAD_EXPLICIT_SCHED);     
  pthread_attr_setschedpolicy(&amp;custom_sched_attr, SCHED_FIFO);  
  fifo_max_prio = sched_get_priority_max(SCHED_FIFO);   
  fifo_min_prio = sched_get_priority_min(SCHED_FIFO);   
  fifo_mid_prio = (fifo_min_prio + fifo_max_prio)/2;    
  fifo_param.sched_priority = fifo_mid_prio;    
  pthread_attr_setschedparam(&amp;custom_sched_attr, &amp;fifo_param);  
  pthread_create(&amp;(threads[i]), &amp;custom_sched_attr, ....);
</pre>


<p>
The pthread<sub>attr</sub><sub>setschedparam</sub> function takes two arguments: the first is a thread attribute object, the second is a curious thing defined in the POSIX.1b standard and known as a struct sched<sub>param</sub>. It looks like this:      
</p>



<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sched_param</span> {;   
          <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sched_priority</span>;   
}
</pre>


<p>
The absolute values and actual range of the priorities depend upon the
implementation, but one thing's for certain—you can use
sched<sub>get</sub><sub>priority</sub><sub>max</sub> and sched<sub>get</sub><sub>priority</sub><sub>min</sub> to get a handle on
them.
</p>
<p>
Setting Policy and Priority Dynamically (sched.c)       
</p>



<pre class="src src-c">fifo_sched_param.sched_priority = fifo_min_prio;        
pthread_setschedparam(threads[i], SCHED_FIFO, &amp;fifo_min_prio)
</pre>


<p>
the pthread<sub>setschedparam</sub> call sets both policy and priority at the
same time. 
</p>

</li>
</ul>
<ul>
<li id="sec-5-5-7">Inheritance<br/>
Instead, you can specify that each thread should inherit its
scheduling characteristics from the thread that created it. Like other
per-thread scheduling attributes, the inheritance attribute is
specified in the attribute object used at thread creation





<pre class="src src-c"><span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">custom_sched_attr</span>;       
        .       
pthread_attr_init(&amp;custom_sched_attr);  
pthread_attr_setinheritsched(&amp;custom_sched_attr, PTHREAD_INHERIT_SCHED) 
        .       
pthread_create(&amp;thread, &amp;custom_sched_attr, ...);
</pre>


<p>
The pthread<sub>attr</sub><sub>setinheritsched</sub> function takes a thread attribute
object as its first argument and as its second argument either the
PTHREAD<sub>INHERIT</sub><sub>SCHED</sub> flag or the PTHREAD<sub>EXPLICIT</sub><sub>SCHED</sub> flag. You can
obtain the current inheritance attribute from an attribute object by
calling pthread<sub>attr</sub><sub>getinheritsched</sub>
</p>


</li>
</ul>
</div>

</div>

<div id="outline-container-5-6" class="outline-3">
<h3 id="sec-5-6">Mutex Scheduling Attributes</h3>
<div class="outline-text-3" id="text-5-6">

<p>The Pthreads standard allows (but does not require) implementations to
design mutexes that can give a priority boost to low priority threads
that hold them. We can associate a mutex with either of two priority
protocols that provide this feature: priority ceiling or priority
inheritance. 
</p>
<ul>
<li id="sec-5-6-1">Priority Ceiling<br/>
The priority ceiling protocol associates a scheduling priority with a
mutex. Thus equipped, a mutex can assign its holder an effective
priority equal to its own, if the mutex holder has a lower priority to
begin with.

<p>
If your platform supports the priority ceiling protocol, the
compile-time constant <sub>POSIX</sub><sub>THREAD</sub><sub>PRIO</sub><sub>PROTECT</sub> will be defined.
</p>


<pre class="src src-c"><span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">m1</span>;     
<span style="color: #98fb98;">pthread_mutexattr_t</span> <span style="color: #eedd82;">mutexattr_prioceiling</span>;      
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mutex_protocol</span>, <span style="color: #eedd82;">high_prio</span>;  
.       
high_prio = sched_get_priority_max(SCHED_FIFO); 
.       
pthread_mutexattr_init(&amp;mutexattr_prioceiling); 
pthread_mutexattr_getprotocol(&amp;mutexattr_prioceiling, &amp;mutex_protocol); 
pthread_mutexattr_setprotocol(&amp;mutexattr_prioceiling, PTHREAD_PRIO_PROTECT);    
pthread_mutexattr_setprioceiling(&amp;mutexattr_prioceiling, high_prio);    
pthread_mutex_init(&amp;m1, &amp;mutexattr_prioceiling);
</pre>


<p>
The priority protocol attribute can have one of three values:   
</p><ul>
<li>PTHREAD<sub>PRIO</sub><sub>NONE</sub>      The mutex uses no priority protocol.   
</li>
<li>PTHREAD<sub>PRIO</sub><sub>PROTECT</sub>   The mutex uses the priority ceiling protocol.  
</li>
<li>PTHREAD<sub>PRIO</sub><sub>INHERIT</sub>   The mutex uses the priority inheritance
  protocol.
</li>
</ul>



</li>
</ul>
<ul>
<li id="sec-5-6-2">Priority Inheritance<br/>
        The priority inheritance protocol lets a mutex elevate the
        priority of its holder to that of the waiting thread with the
        highest priority.

<p>
Because the priority inheritance protocol awards a priority boost to a
mutex holder only when it's absolutely needed, it can be more
efficient than the priority ceiling protocol.
</p>
<p>
        If your platform supports the priority inheritance feature,
        the compile-time constant <sub>POSIX</sub><sub>THREAD</sub><sub>PRIO</sub><sub>INHERIT</sub> will be
        TRUE
</p>



<pre class="src src-c"><span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">m1</span>;     
<span style="color: #98fb98;">pthread_mutexattr_t</span> <span style="color: #eedd82;">mutexattr_prioinherit</span>;      
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mutex_procotol</span>;     
.       
pthread_mutexattr_init(&amp;mutexattr_prioinherit); 
pthread_mutexattr_getprotocol(&amp;mutexattr_prioinherit, &amp;mutex_protocol); 
<span style="color: #00ffff;">if</span> (mutex_protocol != PTHREAD_PRIO_INHERIT) {;  
    pthread_mutexattr_setprotocol(&amp;mutexattr_prioinherit, PTHREAD_PRIO_INHERIT);        
}       
pthread_mutex_init(&amp;m1, &amp;mutexattr_prioinherit);        
</pre>


</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">Chapter 5 - Pthreads and UNIX</h2>
<div class="outline-text-2" id="text-6">


</div>

<div id="outline-container-6-1" class="outline-3">
<h3 id="sec-6-1">Overview</h3>
<div class="outline-text-3" id="text-6-1">

<ul>
<li>Threadsafe libraries 
        Most system libraries maintain internal data for the currently
        executing process in internal data. To allow multiple threads
        from the same process to execute library routines
        simultaneously, library implementors must somehow protect this
        data from unsynchronized accesses by otherwise cooperative
        threads. Libraries that eliminate such race conditions are
        known as threadsafe libraries. 

</li>
<li>Cancellation-safe library functions 
        If a thread is canceled while in the middle of a library call
  that is modifying a library's internal data, it may exit, leaving
  the data in an inconsistent or corrupted state. A library function
  in which a thread can be canceled safely is known as a
  cancellation-safe library routine.
</li>
</ul>


</div>

</div>

<div id="outline-container-6-2" class="outline-3">
<h3 id="sec-6-2">Threads and Signals</h3>
<div class="outline-text-3" id="text-6-2">

<p>This presented the Pthreads standard committee with three chief
challenges:     
</p><ul>
<li>A thread should be able to send and receive signals, yet, to
       allow this, a Pthreads implementation cannot subvert a
       single-threaded process's ability to process signals in the
       way it always has.
</li>
<li>When a signal is delivered to a multithreaded process, a Pthreads
  implementation must select one of the threads to perform the
  required action. 
</li>
<li>What can a thread do, while in a signal handler, that won't
       interfere with its mainline execution?
</li>
</ul>

<ul>
<li id="sec-6-2-1">Traditional Signal Processing<br/>
A process may choose to:
<ul>
<li>Ignore the signal (SIG<sub>IGN</sub>)   
</li>
<li>Use the default action (SIG<sub>DFL</sub>)
</li>
<li>Catch the signal, and execute a user-specified handler routine
</li>
</ul>


<p>
The arrival of a signal interrupts a process at its current point of
execution and transfers execution to a signal-handling routine. When
the signal handler returns, the process resumes at its prior execution
point. 
</p>
</li>
</ul>
<ul>
<li id="sec-6-2-2">Signal Processing in a Multithreaded World<br/>
If multiple threads are executing within a process when a signal is
delivered to it, the system must select a thread to process it. At the
highest level, the selection of the thread is dictated by how the
signal was generated, what action caused the signal, and what the
effective target of the signal is. 
<ul>
<li id="sec-6-2-2-1">Synchronously generated signals<br/>
The system is sending the process a signal because one of its threads
tried to divide by zero (SIGFPE), touch forbidden memory in the wrong
way (SIGSEGV), use a broken pipe (SIGPIPE), or do something else that
triggered an exception. 

<p>
        The other type of synchronously generated signal results from
        one thread in a process calling pthread<sub>kill</sub> to send a signal
        to another thread in the same process. 
</p>
<p>
Note that you shouldn't use pthread<sub>kill</sub> in place of cancellation or
condition variables
</p>
</li>
</ul>
<ul>
<li id="sec-6-2-2-2">Asynchronously generated signals<br/>
The arrival of these signals is asynchronous to the activities of any
and all threads within the process. They are typically job control
signals—SIGALRM, SIGHUP, SIGINT, and SIGKILL—or the user-defined
signals—SIGUSR1 and SIGUSR2. They are sent to the process by a kill
call and can be handled by almost any of its threads. 
</li>
</ul>
<ul>
<li id="sec-6-2-2-3">Per-thread signal masks<br/>
By default, the first thread in a child process inherits its signal
mask from the thread in its parent that called fork. Additional
threads inherit the signal mask of the thread that issued the
pthread<sub>create</sub> that created them. Use the pthread<sub>sigmask</sub> call to
block and unblock signals in the mask.

<p>
When an asynchronously generated signal arrives at a process, it is
handled once by exactly one thread in the process. The system selects
this thread by referring to the collection of per-thread signal masks
of all the threads. If more than one thread has the signal unblocked,
the system arbitrarily selects one of them.
</p>


</li>
</ul>
<ul>
<li id="sec-6-2-2-4">Per-process signal actions<br/>
Although each thread has its own signal mask, all threads in a process
must share the process's own signal action (sigaction) structure.
Consequently, if a process specifies that a given signal should be
ignored, it will be ignored, regardless of to which thread in the
process the system delivers it. Similarly, if a process's sigaction
structure deems that a certain signal should be subjected to the
default action (whatever that might be for the signal) or processed by
a signal handler, the specified action will be carried out when the
signal is delivered to any of the process's threads. 

<p>
Any thread can make a sigaction call to set the action for a signal.
If a thread calls sigaction to set the SIG<sub>IGN</sub> action for the SIGTERM
signal, any other thread in the same process that does not block this
signal is prepared to ignore a SIGTERM should one be delivered to it.
If a thread assigns the ei-e-io signal handler to the SIGIO signal,
any thread selected to handle SIGIO will call ei-e-io. 
</p>
</li>
</ul>
<ul>
<li id="sec-6-2-2-5">Putting it all together<br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-6-2-3">Threads in Signal Handlers<br/>
But where are the Pthreads calls? They're not in either of these
lists! In fact, the Pthreads standard specifies that the behavior of
all Pthreads functions is undefined when the function is called from a
signal handler.



<p>
To make our program take an action when a signal arrives we can use sigwait as follows:         
</p><ul>
<li>Mask the interesting signals in all threads so that their arrival is made pending. The sigwait call will detect these signals.        
</li>
<li>Create a dedicated thread that waits specifically for interesting signals to arrive.  
</li>
<li>Insert a simple loop in the dedicated thread's code that calls
  sigwait, indicating the signals that it will handle. Add the action
  routine that executes when the sigwait call returns. 
</li>
</ul>


</li>
</ul>
<ul>
<li id="sec-6-2-4">A Simple Example<br/>




<pre class="src src-c"><span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">stats_thread</span>; 
<span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">stats_lock</span> = PTHREAD_MUTEX_INITIALIZER; 
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span>      
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)      
{       
.       
sigset_t sigs_to_block; 
.       
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set main thread's signal mask to block SIGUSR1.      </span>
<span style="color: #ff7f24;">All other threads will inherit mask and have it blocked too     </span>
<span style="color: #ff7f24;">*/</span>      
sigemptyset(&amp;sigs_to_block);    
sigaddset(&amp;sigs_to_block, SIGUSR1);     
pthread_sigmask(SIG_BLOCK, &amp;sigs_to_block, <span style="color: #7fffd4;">NULL</span>);       
.       
pthread_create(&amp;stats_thread, <span style="color: #7fffd4;">NULL</span>, report_stats, <span style="color: #7fffd4;">NULL</span>);        
}

<span style="color: #98fb98;">void</span> * <span style="color: #87cefa;">report_stats</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">p</span>)    
{       
<span style="color: #98fb98;">sigset_t</span> <span style="color: #eedd82;">sigs_to_catch</span>; 
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">caught</span>;     
sigemptyset(&amp;sigs_to_catch);    
sigaddset(&amp;sigs_to_catch, SIGUSR1);     
<span style="color: #00ffff;">for</span> (;;) {      
      sigwait(&amp;sigs_to_catch, &amp;caught); 
      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Proceed to lock mutex and display statistics </span><span style="color: #ff7f24;">*/</span>        
      pthread_mutex_lock(&amp;stats_lock);  
      display_stats();  
      pthread_mutex_unlock(&amp;stats_lock);        
      } 
<span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;    
}
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-6-3" class="outline-3">
<h3 id="sec-6-3">Threadsafe Library Functions and System Calls</h3>
<div class="outline-text-3" id="text-6-3">

<ul>
<li id="sec-6-3-1">Threadsafe and Reentrant Functions<br/>
The degree to which a library function or routine allows itself to
have multiple instances of itself in progress at the same time is
known as its reentrancy. 
</li>
</ul>
<ul>
<li id="sec-6-3-2">Functions That Return Pointers to Static Data<br/>
</li>
</ul>
<ul>
<li id="sec-6-3-3">Using Thread-Unsafe Functions in a Multithreaded Program<br/>
</li>
</ul>
</div>

</div>

<div id="outline-container-6-4" class="outline-3">
<h3 id="sec-6-4">Cancellation-Safe Library Functions and System Calls</h3>
<div class="outline-text-3" id="text-6-4">

<ul>
<li id="sec-6-4-1">Cancellation Points in System and Library Calls<br/>
we know of four Pthreads function calls that act as cancellation
points: they are pthread<sub>testcancel</sub>, pthread<sub>cond</sub><sub>wait</sub>,
pthread<sub>cond</sub><sub>timedwait</sub>, and pthread<sub>join</sub>. 
</li>
</ul>
</div>

</div>

<div id="outline-container-6-5" class="outline-3">
<h3 id="sec-6-5">Thread-Blocking Library Functions and System Calls</h3>
<div class="outline-text-3" id="text-6-5">

</div>

</div>

<div id="outline-container-6-6" class="outline-3">
<h3 id="sec-6-6">Threads and Process Management</h3>
<div class="outline-text-3" id="text-6-6">

<ul>
<li id="sec-6-6-1">Calling fork from a Thread<br/>
In a Pthreads-compliant implementation, the fork call always creates a
new child process with a single thread, regardless of how many threads
its parent may have had at the time of the call. Furthermore, the
child's thread is a replica of the thread in the parent that called
fork—including a process address space shared by all of its parent's
threads and its parent thread's per-thread stack. 

<p>
Consider the headaches:         
</p><ul>
<li>The new single-threaded child process could inherit held locks from
  threads in the parent that don't exist in the child. It may have no
  idea what these locks mean, let alone realize that it holds one of
  them. Confusion and deadlock are in the forecast.     
</li>
<li>The child process could inherit heap areas that were allocated by
  threads in the parent that don't exist in the child. Here we see
  memory leaks, data loss, and bug reports.     
</li>
</ul>


<p>
The Pthreads standard defines the pthread<sub>atfork</sub> call to help you
manage these problems. The pthread<sub>atfork</sub> function allows a parent
process to specify preparation and cleanup routines that parent and
child processes run as part of the fork operation. Using these
routines a parent or child process can manage the release and
reacquisition of locks and resources before and after the fork. 
</p>
<ul>
<li id="sec-6-6-1-1">Fork-handling stacks<br/>
To perform its magic, the pthread<sub>atfork</sub> call pushes addresses of preparation and cleanup routines on any of three fork-handling stacks:        
<ul>
<li>Routines placed on the prepare stack are run in the parent before the fork.   
</li>
<li>Routines placed on the parent stack are run in the parent after the fork.     
</li>
<li>Routines placed on the child stack are run in the child after the
  fork.
</li>
</ul>


<p>
Before pursuing this course, you should consider a less complex alternative:    
</p><ul>
<li>If possible, fork before you've created any threads.  Instead of
  forking, create a new thread. If you are forking to exec a binary
  image, can you convert the image to a callable shared library to
  which you could simply link?  

</li>
<li>Consider the surrogate parent model.   In the surrogate parent
  model, a program forks a child process at initialization time. The
  sole purpose of the child is to serve as a sort of "surrogate
  parent" for the original process should it ever need to fork another
  child. After initialization, the original parent can proceed to
  create its additional threads. When it wants to exec an image, it
  communicates this to its child (which has remained single-threaded).
  The child then performs the fork and exec on behalf of the original
  process.
</li>
</ul>


</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-6-6-2">Calling exec from a Thread<br/>
With this in mind, the Pthreads standard specifies that an exec call
from any thread must terminate all threads in the process and start a
single new thread at main in the new image. 

</li>
</ul>
<ul>
<li id="sec-6-6-3">Process Exit and Threads<br/>
Regardless of whether or not a process contains multiple threads, it can be terminated when:    
<ul>
<li>Any thread in it makes an exit system call.   
</li>
<li>The thread running the main routine completes its execution.  
</li>
<li>A fatal signal is delivered. 
</li>
</ul>


</li>
</ul>
</div>

</div>

<div id="outline-container-6-7" class="outline-3">
<h3 id="sec-6-7">Multiprocessor Memory Synchronization</h3>
<div class="outline-text-3" id="text-6-7">


<p>
The functions that must synchronize memory operations include:  
</p>



<pre class="src src-sh">pthread_cond_broadcast  
pthread_mutex_unlock    
pthread_cond_signal     
sem_post        
pthread_cond_timedwait  
sem_trywait     
pthread_cond_wait       
sem_wait        
pthread_create  
fork    
pthread_join    
<span style="color: #b0c4de;">wait</span>    
pthread_mutex_trylock   
waitpid 
pthread_mutex_lock      
</pre>

</div>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">Chapter 6: Practical Considerations</h2>
<div class="outline-text-2" id="text-7">


</div>

<div id="outline-container-7-1" class="outline-3">
<h3 id="sec-7-1">Understanding Pthreads Implementation</h3>
<div class="outline-text-3" id="text-7-1">

<p>Pthreads implementations fall into three basic categories: 
</p><ul>
<li>Based on pure user space.     
</li>
<li>Based on pure kernel thread.  
</li>
<li>Implementations somewhere between the two. These hybrid
  implementations are referred to variously as two-level schedulers,
  lightweight processes (LWPs), or activations
</li>
</ul>


</div>

</div>

<div id="outline-container-7-2" class="outline-3">
<h3 id="sec-7-2">Debugging</h3>
<div class="outline-text-3" id="text-7-2">

<ul>
<li id="sec-7-2-1">Overview<br/>
First of all, you'll investigate types of programming errors that
result from thread synchronization problems, namely deadlocks and race
conditions. Second, once you've seen a problem (for instance, some
data corruption or a hang), you'll discover you may have a hard time
duplicating it. Because the alignment of events among threads that run
concurrently is largely left up to chance, errors, once found, may be
unrepeatable. Finally, because threads are a new technology, many
vendors have yet to upgrade their debuggers to operate well on
threaded programs. 

</li>
</ul>
<ul>
<li id="sec-7-2-2">Deadlock<br/>
</li>
</ul>
</div>

</div>

<div id="outline-container-7-3" class="outline-3">
<h3 id="sec-7-3">Performance</h3>
<div class="outline-text-3" id="text-7-3">

</div>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8">Appendix C: Pthreads Quick Reference</h2>
<div class="outline-text-2" id="text-8">





<pre class="src src-sh"><span style="color: #87cefa;">pthread_atfork</span> ( )      

int pthread_atfork (    
<span style="color: #87cefa;">void</span> (*prepare)(void),  
<span style="color: #87cefa;">void</span> (*parent)(void),   
<span style="color: #87cefa;">void</span> (*child)(void));   

Declares procedures to be called before and after a fork call. The prepare fork handler runs<span style="color: #00ffff;"> in</span> the parent process before the fork. After the fork, the parent handler runs<span style="color: #00ffff;"> in</span> the parent process, and the child handler runs<span style="color: #00ffff;"> in</span> the child process.     

<span style="color: #87cefa;">pthread_attr_destroy</span>( ) 

int pthread_attr_destroy (      
pthread_attr_t *attr);  

Destroys a thread attribute object.     

<span style="color: #87cefa;">pthread_attr_getdetachstate</span>( )  

int pthread_attr_getdetachstate (       
const pthread_attr_t *attr,     
int *detachstate);      

Obtains the setting of the detached state of a thread.  

<span style="color: #87cefa;">pthread_attr_getinheritsched</span>( ) 

int pthread_attr_getinheritsched (      
const pthread_attr_t *attr,     
int *inheritsched);     
Obtains the setting of the scheduling inheritance of a thread.  

<span style="color: #87cefa;">pthread_attr_getschedparam</span>( )   

int pthread_attr_getschedparam (        
const pthread_attr_t *attr,     
struct sched_param *param);     

Obtains the parameters (<span style="color: #00ffff;">for</span> instance, the scheduling priority) associated with the scheduling policy attribute of a thread.     

<span style="color: #87cefa;">pthread_attr_getschedpolicy</span>( )  

int pthread_attr_getschedpolicy (       
const pthread_attr_t *attr,     
int *policy);   

Obtains the setting of the scheduling policy of a thread.       

<span style="color: #87cefa;">pthread_attr_getscope</span>( )        

int pthread_attr_getscope (     
const pthread_attr_t *attr,     
int *scope);    

Obtains the setting of the scheduling scope of a thread.        

<span style="color: #87cefa;">pthread_attr_getstackaddr</span>( )    

int pthread_attr_getstackaddr ( 
const pthread_attr_t *attr,     
void **stackaddr);      

Obtains the stack address of a thread.  

<span style="color: #87cefa;">pthread_attr_getstacksize</span>( )    

int pthread_attr_getstacksize ( 
const pthread_attr_t *attr,     
size_t *stacksize);     

Obtains the stack size of a thread.     

<span style="color: #87cefa;">pthread_attr_init</span>( )    

int pthread_attr_init ( 
pthread_attr_t *attr);  

Initializes a thread attribute object. A thread specifies a thread attribute object<span style="color: #00ffff;"> in</span> its calls to pthread_create to set the characteristics of newly created threads.         

<span style="color: #87cefa;">pthread_attr_setdetachstate</span>( )  

int pthread_attr_setdetachstate (       
pthread_attr_t *attr,   
int detachstate);       

Adjusts the detached state of a thread. A thread<span style="color: #ffa07a;">'s detached state can be joinable (PTHREAD_CREATE_JOINABLE) or it can be detached (PTHREAD_CREATE_DETACHED).    </span>

<span style="color: #ffa07a;">pthread_attr_setinheritsched( ) </span>

<span style="color: #ffa07a;">int pthread_attr_setinheritsched (      </span>
<span style="color: #ffa07a;">pthread_attr_t *attr,   </span>
<span style="color: #ffa07a;">int inherit);   </span>

<span style="color: #ffa07a;">Adjusts the scheduling inheritance of a thread. A thread can inherit the scheduling policy and the parameters of its creator thread (PTHREAD_INHERIT_SCHED) or obtain them from the thread attribute object specified in the pthread_create call (PTHREAD_EXPLICIT_SCHED).      </span>

<span style="color: #ffa07a;">pthread_attr_setschedparam( )   </span>

<span style="color: #ffa07a;">int pthread_attr_setschedparam (        </span>
<span style="color: #ffa07a;">pthread_attr_t *attr,   </span>
<span style="color: #ffa07a;">const struct sched_param *param);       </span>

<span style="color: #ffa07a;">Adjusts the parameters (for instance, the scheduling priority) associated with the scheduling policy of a thread. The scheduling priority parameter (as specified in the struct sched_param) depends upon the selected scheduling policy (SCHED_FIFO, SCHED_RR, or SCHED_OTHER). Use sched_get_priority_max and sched_get_priority_min to obtain the maximum and minimum priority settings for a given policy.  </span>

<span style="color: #ffa07a;">pthread_attr_setschedpolicy( )  </span>

<span style="color: #ffa07a;">int pthread_attr_setschedpolicy (       </span>
<span style="color: #ffa07a;">pthread_attr_t *attr,   </span>
<span style="color: #ffa07a;">int policy);    </span>

<span style="color: #ffa07a;">Adjusts the scheduling policy of a thread. Pthreads defines the SCHED_FIFO, SCHED_RR, and SCHED_OTHER policies.         </span>

<span style="color: #ffa07a;">pthread_attr_setscope( )        </span>

<span style="color: #ffa07a;">int pthread_attr_setscope (     </span>
<span style="color: #ffa07a;">pthread_attr_t *attr,   </span>
<span style="color: #ffa07a;">int scope);     </span>

<span style="color: #ffa07a;">Adjusts the scheduling scope of a thread. A thread can use system-scope scheduling (PTHREAD_SCOPE_SYSTEM), in which case the operating system compares the priorities of all runnable threads of all processes systemwide in order to select a thread to run on an available CPU. Alternatively, it can use process-scope scheduling (PTHREAD_SCOPE_PROCESS), in which case only the highest priority runnable thread in a process competes against the highest priority threads of other processes in the system'</span>s scheduling activity.        

<span style="color: #87cefa;">pthread_attr_setstackaddr</span>( )    

int pthread_attr_setstackaddr ( 
pthread_attr_t *attr,   
void *stackaddr);       

Adjusts the stack address of a thread.  

<span style="color: #87cefa;">pthread_attr_setstacksize</span>( )    

int pthread_attr_setstacksize ( 
pthread_attr_t *attr,   
size_t stacksize);      

Adjusts the stack size of a thread. The stack size must be greater than or equal to PTHREAD_STACK_MIN.  

<span style="color: #87cefa;">pthread_cancel</span>( )       

int pthread_cancel (    
pthread_t thread);      

Cancels the specified thread.   

<span style="color: #87cefa;">pthread_cleanup_pop</span>( )  

void pthread_cleanup_pop (      
int execute);   

Removes the routine from the top of a thread<span style="color: #ffa07a;">'s cleanup stack, and if execute is nonzero, runs it.       </span>

<span style="color: #ffa07a;">pthread_cleanup_push( ) </span>

<span style="color: #ffa07a;">void pthread_cleanup_push (     </span>
<span style="color: #ffa07a;">void (*routine)(void *),        </span>
<span style="color: #ffa07a;">void *arg);     </span>

<span style="color: #ffa07a;">Places a routine on the the top of a thread'</span>s cleanup stack, and  when the routine is called, ensures that the specified argument is passed to it.      

<span style="color: #87cefa;">pthread_condattr_destroy</span>( )     

int pthread_condattr_destroy (  
pthread_condattr_t *attr);      

Destroys a condition variable attribute object.         

<span style="color: #87cefa;">pthread_condattr_getpshared</span>( )  

int pthread_condattr_getpshared (       
pthread_condattr_t *attr,       
int *pshared);  

Obtains the process-shared setting of a condition variable attribute object.    

<span style="color: #87cefa;">pthread_condattr_init</span>( )        

int pthread_condattr_init (     
pthread_condattr_t *attr);      

Initializes a condition variable attribute object. A thread specifies a condition variable attribute object<span style="color: #00ffff;"> in</span> its calls to pthread_cond_init to set the characteristics of new condition variables.    

<span style="color: #87cefa;">pthread_condattr_setpshared</span>( )  

int pthread_condattr_setpshared (       
pthread_condattr_t *attr,       
int pshared);   

Sets the process-shared attribute<span style="color: #00ffff;"> in</span> a condition variable attribute object to either PTHREAD_PROCESS_SHARED or PTHREAD_PROCESS_PRIVATE.         

<span style="color: #87cefa;">pthread_cond_broadcast</span>( )       

int pthread_cond_broadcast (    
pthread_cond_t *cond);  

Unblocks all threads that are waiting on a condition variable.  

<span style="color: #87cefa;">pthread_cond_destroy</span>( ) 

int pthread_cond_destroy (      
pthread_cond_t *cond);  

Destroys a condition variable.  

<span style="color: #87cefa;">pthread_cond_init</span>( )    

int pthread_cond_init ( 
pthread_cond_t *cond,   
const pthread_condattr_t *attr);        

Initializes a condition variable with the attributes specified<span style="color: #00ffff;"> in</span> the specified condition variable attribute object. If attr is NULL, the default attributes are used.  

<span style="color: #87cefa;">pthread_cond_signal</span>( )  

int pthread_cond_signal(        
pthread_cond_t *cond);  

Unblocks at least one thread waiting on a condition variable. The scheduling priority determines which thread is awakened.      

<span style="color: #87cefa;">pthread_cond_timedwait</span>( )       

int pthread_cond_timedwait (    
pthread_cond_t *cond,   
pthread_mutex_t *mutex, 
const struct timespec *abstime);        

Atomically unlocks the specified mutex, and places the calling thread into a wait state. When the specified condition variable is signaled or broadcast, or the system time is greater than or equal to abstime, this <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">reacquires</span> the mutex and resumes its caller.     

<span style="color: #87cefa;">pthread_cond_wait</span>( )    

int pthread_cond_wait ( 
pthread_cond_t *cond,   
pthread_mutex_t *mutex);        

Atomically unlocks the specified mutex, and places the calling thread into a wait state. When the specified condition variable is signaled or broadcasted, this <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">reacquires</span> the mutex and resumes its caller.   

<span style="color: #87cefa;">pthread_create</span>( )       

int pthread_create (    
pthread_t *thread,      
const pthread_attr_t *attr,     
void *(*start_routine)(void *), 
void *arg);     

Creates a thread with the attributes specified<span style="color: #00ffff;"> in</span> attr. If attr is NULL, the default attributes are used. The thread argument receives a thread handle for the new thread. The new thread starts execution<span style="color: #00ffff;"> in</span> start_routine and is passed the single specified argument.        

<span style="color: #87cefa;">pthread_detach</span>( )       

int pthread_detach (    
pthread_t thread);      

Marks a thread<span style="color: #ffa07a;">'s internal data structures for deletion. When a detached thread terminates, the system reclaims the storage used for its thread object.  </span>

<span style="color: #ffa07a;">pthread_equal( )        </span>

<span style="color: #ffa07a;">int pthread_equal (     </span>
<span style="color: #ffa07a;">pthread_t t1,   </span>
<span style="color: #ffa07a;">pthread_t t2);  </span>

<span style="color: #ffa07a;">Compares one thread handle to another thread handle.    </span>

<span style="color: #ffa07a;">pthread_exit( ) </span>

<span style="color: #ffa07a;">void pthread_exit (     </span>
<span style="color: #ffa07a;">void *value);   </span>

<span style="color: #ffa07a;">Terminates the calling thread, returning the specified value to any thread that may have previously issued a pthread_join on the thread.        </span>

<span style="color: #ffa07a;">pthread_getschedparam( )        </span>

<span style="color: #ffa07a;">int pthread_getschedparam (     </span>
<span style="color: #ffa07a;">pthread_t thread,       </span>
<span style="color: #ffa07a;">int *policy,    </span>
<span style="color: #ffa07a;">struct sched_param *param);     </span>

<span style="color: #ffa07a;">Obtains both the scheduling policy and scheduling parameters of an existing thread. (This function differs from the pthread_attr_getschedpolicy function and the pthread_attr_getschedparam function in that the latter functions return the policy and parameters that will be used whenever a new thread is created.)         </span>

<span style="color: #ffa07a;">pthread_getspecific( )  </span>

<span style="color: #ffa07a;">void *pthread_getspecific (     </span>
<span style="color: #ffa07a;">pthread_key_t key);     </span>

<span style="color: #ffa07a;">Obtains the thread-specific data value associated with the specified key in the calling thread.         </span>

<span style="color: #ffa07a;">pthread_join( ) </span>

<span style="color: #ffa07a;">int pthread_join (      </span>
<span style="color: #ffa07a;">pthread_t thread,       </span>
<span style="color: #ffa07a;">void **value_ptr);      </span>

<span style="color: #ffa07a;">Causes the calling thread to wait for the specified thread'</span>s termination. The value_ptr parameter receives the return value of the terminating thread.  

<span style="color: #87cefa;">pthread_key_create</span>( )   

int pthread_key_create (        
pthread_key_t *key,     
<span style="color: #87cefa;">void</span> (*destructor)(void *));    

Generates a unique thread-specific key that<span style="color: #ffa07a;">'s visible to all threads in a process. Although different threads can use the same key, the value any thread associates with the key (by calling pthread_specific) are specific to that thread alone and persist for the life of that thread. When a thread terminates, its thread-specific data value is destroyed (but the key persists until pthread_key_destroy is called). If a destructor routine was specified for the key in the pthread_key_create call, it'</span>s then called<span style="color: #00ffff;"> in</span> the thread<span style="color: #ffa07a;">'s context with the thread-specific data value associated with the key as an argument.      </span>

<span style="color: #ffa07a;">pthread_key_delete( )   </span>

<span style="color: #ffa07a;">int pthread_key_delete (        </span>
<span style="color: #ffa07a;">pthread_key_t key);     </span>

<span style="color: #ffa07a;">Deletes a thread-specific key.  </span>

<span style="color: #ffa07a;">pthread_kill( ) </span>

<span style="color: #ffa07a;">int pthread_kill (      </span>
<span style="color: #ffa07a;">pthread_t thread,       </span>
<span style="color: #ffa07a;">int sig);       </span>

<span style="color: #ffa07a;">Delivers a signal to the specified thread.      </span>

<span style="color: #ffa07a;">pthread_mutexattr_destroy( )    </span>

<span style="color: #ffa07a;">int pthread_mutexattr_destroy ( </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr);     </span>

<span style="color: #ffa07a;">Destroys a mutex attribute object.      </span>

<span style="color: #ffa07a;">pthread_mutexattr_getprioceiling( )     </span>

<span style="color: #ffa07a;">int pthread_mutexattr_getprioceiling (  </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr,      </span>
<span style="color: #ffa07a;">int *prioceiling);      </span>

<span style="color: #ffa07a;">Obtains the priority ceiling of a mutex attribute object.       </span>

<span style="color: #ffa07a;">pthread_mutexattr_getprotocol( )        </span>

<span style="color: #ffa07a;">int pthread_mutexattr_getprotocol(      </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr,      </span>
<span style="color: #ffa07a;">int *protocol); </span>

<span style="color: #ffa07a;">Obtains the protocol of a mutex attribute object.       </span>

<span style="color: #ffa07a;">pthread_mutexattr_getpshared( ) </span>

<span style="color: #ffa07a;">int pthread_mutexattr_getpshared(       </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr,      </span>
<span style="color: #ffa07a;">int *pshared);  </span>

<span style="color: #ffa07a;">Obtains the process-shared setting of a mutex attribute object.         </span>

<span style="color: #ffa07a;">pthread_mutexattr_init( )       </span>

<span style="color: #ffa07a;">int pthread_mutexattr_init (    </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr);     </span>

<span style="color: #ffa07a;">Initializes a mutex attribute object. A thread specifies a mutex attribute object in its calls to pthread_mutex_init to set the characteristics of new mutexes.         </span>

<span style="color: #ffa07a;">pthread_mutexattr_setprioceiling( )     </span>

<span style="color: #ffa07a;">int pthread_mutexattr_setprioceiling (  </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr,      </span>
<span style="color: #ffa07a;">int prioceiling);       </span>

<span style="color: #ffa07a;">Sets the priority ceiling attribute of a mutex attribute object.        </span>

<span style="color: #ffa07a;">pthread_mutexattr_setprotocol( )        </span>

<span style="color: #ffa07a;">int pthread_mutexattr_setprotocol(      </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr,      </span>
<span style="color: #ffa07a;">int protocol);  </span>

<span style="color: #ffa07a;">Sets the protocol attribute of a mutex attribute object. There are three valid settings: PTHREAD_PRIO_INHERIT, PTHREAD_PRIO_PROTECT, or PTHREAD_PRIO_NONE.      </span>

<span style="color: #ffa07a;">pthread_mutexattr_setpshared( ) </span>

<span style="color: #ffa07a;">int pthread_mutexattr_setpshared(       </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr,      </span>
<span style="color: #ffa07a;">int pshared);   </span>

<span style="color: #ffa07a;">Sets the process-shared attribute of a mutex attribute object to PTHREAD_PROCESS_SHARED or PTHREAD_PROCESS_PRIVATE.     </span>

<span style="color: #ffa07a;">pthread_mutex_destroy( )        </span>

<span style="color: #ffa07a;">int pthread_mutex_destroy (     </span>
<span style="color: #ffa07a;">pthread_mutex_t *mutex);        </span>

<span style="color: #ffa07a;">Destroys a mutex.       </span>

<span style="color: #ffa07a;">pthread_mutex_init( )   </span>

<span style="color: #ffa07a;">int pthread_mutex_init (        </span>
<span style="color: #ffa07a;">pthread_mutex_t *mutex, </span>
<span style="color: #ffa07a;">const pthread_mutexattr_t *attr);       </span>

<span style="color: #ffa07a;">Initializes a mutex with the attributes specified in the specified mutex attribute object. If attr is NULL, the default attributes are used.    </span>

<span style="color: #ffa07a;">pthread_mutex_lock( )   </span>

<span style="color: #ffa07a;">int pthread_mutex_lock (        </span>
<span style="color: #ffa07a;">pthread_mutex_t *mutex);        </span>

<span style="color: #ffa07a;">Locks an unlocked mutex. If the mutex is already locked, the calling thread blocks until the thread that currently holds the mutex releases it.         </span>

<span style="color: #ffa07a;">pthread_mutex_trylock( )        </span>

<span style="color: #ffa07a;">int pthread_mutex_trylock (     </span>
<span style="color: #ffa07a;">pthread_mutex_t *mutex);        </span>

<span style="color: #ffa07a;">Tries to lock a mutex. If the mutex is already locked, the calling thread returns without waiting for the mutex to be freed.    </span>

<span style="color: #ffa07a;">pthread_mutex_unlock( ) </span>

<span style="color: #ffa07a;">int pthread_mutex_unlock (      </span>
<span style="color: #ffa07a;">pthread_mutex_t *mutex);        </span>

<span style="color: #ffa07a;">Unlocks a mutex. The scheduling priority determines which blocked thread is resumed. The resumed thread may or may not succeed in its next attempt to lock the mutex, depending upon whether another thread has locked the mutex in the interval between the thread'</span>s being resumed and its issuing the pthread_mutex_lock call.        

<span style="color: #87cefa;">pthread_once</span>( ) 

int pthread_once (      
pthread_once_t *once_block,     
<span style="color: #87cefa;">void</span> (*init_routine) (void);    

Ensures that init_routine will run just once regardless of how many threads<span style="color: #00ffff;"> in</span> a process call it. All threads issue calls to the routine by making identical pthread_once calls (with the same once_block and init_routine). The thread that first makes the pthread_once call succeeds<span style="color: #00ffff;"> in</span> running the routine; subsequent pthread_once calls from other threads do not run the routine.        

<span style="color: #87cefa;">pthread_self</span>( ) 

pthread_t pthread_self (        
void);  

Obtains the thread handle of the calling thread.        

<span style="color: #87cefa;">pthread_setcancelstate</span>( )       

int pthread_setcancelstate (    
int state,      
int *oldstate); 

Sets a thread<span style="color: #ffa07a;">'s cancelability state. You can enable a thread'</span>s cancellation by specifying the PTHREAD_CANCEL_ENABLE state, or disable it by specifying PTHREAD_CANCEL_DISABLE.  

<span style="color: #87cefa;">pthread_setcanceltype</span>( )        

int pthread_setcanceltype (     
int type,       
int *oldtype);  

Sets a thread<span style="color: #ffa07a;">'s cancelability type. To allow a thread to receive cancellation orders only at defined cancellation points, you can specify the PTHREAD_CANCEL_DEFERRED type; this is the default. To allow a thread to be canceled at any point during its execution, you can specify PTHREAD_CANCEL_ASYNCHRONOUS.       </span>

<span style="color: #ffa07a;">pthread_setschedparam( )        </span>

<span style="color: #ffa07a;">int pthread_setschedparam (     </span>
<span style="color: #ffa07a;">pthread_t thread,       </span>
<span style="color: #ffa07a;">int policy,     </span>
<span style="color: #ffa07a;">const struct sched_param *param);       </span>

<span style="color: #ffa07a;">Adjusts the scheduling policy and scheduling parameters of an existing thread. (This function differs from the functions pthread_attr_setschedpolicy and pthread_attr_setschedparam in that they set the policy and parameters that will be used whenever a new thread is created.)     </span>

<span style="color: #ffa07a;">pthread_setspecific( )  </span>

<span style="color: #ffa07a;">int pthread_setspecific (       </span>
<span style="color: #ffa07a;">pthread_key_t key,      </span>
<span style="color: #ffa07a;">void *value);   </span>

<span style="color: #ffa07a;">Sets the thread-specific data value associated with the specified key in the calling thread.    </span>

<span style="color: #ffa07a;">pthread_sigmask( )      </span>

<span style="color: #ffa07a;">int pthread_sigmask (   </span>
<span style="color: #ffa07a;">int how,        </span>
<span style="color: #ffa07a;">const sigset_t *set,    </span>
<span style="color: #ffa07a;">sigset_t *oset);        </span>

<span style="color: #ffa07a;">Examines or changes the calling thread'</span>s signal mask.   

<span style="color: #87cefa;">pthread_testcancel</span>( )   

void pthread_testcancel (void); 

Requests that any pending cancellation request be delivered to the calling thread.
</pre>

</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2013-04-14T18:55+0800</p>
<p class="author">Author: Shi Shougang</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
